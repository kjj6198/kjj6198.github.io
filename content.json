{"meta":{"title":"欠・擬合 | UNder-fitting","subtitle":"Fun Driven Frontend Developer 最近的夢想是能夠光榮地回鄉工作。\n如果你也對日劇、機器學習、日文、前後端開發、React、程式、咖啡有興趣，或許我們可以聊聊\n","description":"Fun Driven Frontend Developer 最近的夢想是能夠光榮地回鄉工作。\ninterested in #frontend #react #redux #rxjs #japanese #machine-learning\n","author":"Kalan","url":"http://kjj6198.github.io"},"pages":[],"posts":[{"title":"你可能不知道的 Sass 技巧","slug":"Sass","date":"2017-08-18T09:11:38.000Z","updated":"2017-08-21T18:53:29.000Z","comments":true,"path":"2017/08/18/Sass/","link":"","permalink":"http://kjj6198.github.io/2017/08/18/Sass/","excerpt":"","text":"我發現有許多前端工程師只把 sass 當作有變數、nested class 跟 &amp; 的 CSS 來撰寫。 在 Sass 當中有許多好用的函式跟功能，如果不知道如何使用的話，對一個強大的預處理器來說，這是件相當可惜的事情。Sass3.5 的更新加強了對 css variable 的支持。 在考慮使用 CSS in Javascript 或是引入 PostCSS 的 plugin 之前，先看看是否能夠用 Sass 達到同樣的目的吧！ 資料型別 List, Map除了一般的變數用 $ 開頭宣告之外，其實在 Sass 當中還有兩種資料型別，List 和 Map。List 就像一般 array，而 Map 有點像是 Object。 如果運用得好，我們可以收斂一下常見的變數，像是 color, font, size 等等。同時 List 與 Map 在 Sass 當中提供了一些函數來操作，像是 map-get map-has-key 等等，以下我們以常見的顏色管理做舉例。 MapSass 的 Map 類似 Javascript 當中的 Object 的功能，提供了 key-value 的方式儲存變數，並且內建一些函式以供操作。 在顏色宣告時，我們通常都會這樣寫： 123456789101112131415$mainColor: #aaa;$fontColor: #333;$dangerColor: red;.word &#123; color: $fontColor;&#125;.container &#123; background-color: $mainColor;&#125;.btn.danger &#123; background-color: $dangerColor;&#125; 如果將原本的變數改寫為 Map 的形式： 1234567891011121314151617$colors: ( main: #aaa, font: #333, danger: red);.word &#123; color: map-get($colors, font);&#125;.container &#123; background-color: map-get($colors, main);&#125;.btn.danger &#123; background-color: map-get($colors, danger);&#125; 當然，這個函數還有一些優化的空間，我們下面會再做介紹。 其他 API map-get map-has-key merge-map ListList 可以簡單的聯想為 array，Sass 內建了一些函數提供操作 List。List 的內容可以是顏色、字串、甚至塞入 Map 也可以。比如說我們想要對一連串的 content 賦值： 12345678.tag.danger::before &#123; content: \"danger\";&#125;.tag.normal::before &#123; content: \"normal\";&#125;//... 當內容一多，寫這種重複的 CSS 是一件很痛苦的事，這時候就可以使用 List 簡化操作。使用 Map 或是 List，也可以用 @each...in 的迴圈來遍歷整個 Map 或是 List。 123456789101112$contentList: ('danger', 'normal', 'suck');@each $content in $contentList &#123; .tag.#&#123;$content&#125;::before &#123; content: $content; &#125;&#125;// compiled.tag.danger &#123;&#125;.tag.normal &#123;&#125;.tag.suck &#123;&#125; 管理 z-index運用 List 當中的 API 來管理複雜的 z-index。 z-index 一直是每個前端工程師的心頭之痛，因為很容易就使用 magic number 來管理。一般的解決方法是用變數的方式來管理： 12345678910$zindex-dropdown-backdrop: 990 !default;$zindex-navbar: 1000 !default;$zindex-dropdown: 1000 !default;$zindex-fixed: 1030 !default;$zindex-sticky: 1030 !default;$zindex-modal-backdrop: 1040 !default;$zindex-modal: 1050 !default;$zindex-popover: 1060 !default;$zindex-tooltip: 1070 !default;// 取自 bootstrap 代碼 我們可以運用 index 這個 API 搭配 List 達到類似的效果： 123456789101112131415161718192021222324$zIndexs: ( 'dropdown-backdrop', 'navbar', 'normal', 'dropdown', 'fixed', 'sticky', 'modal-backdrop', 'modal', 'popover', 'tooltip');.dropdown &#123; z-index: index($zIndexs, 'dropdown') // 類似 indexOf&#125;.dropdown-backdrop &#123; z-index: index($zIndexs, 'dropdown-backdrop');&#125;// ....tooltip &#123; z-index: index($zIndexs, 'tooltip');&#125; 這樣一來，我們除了可以減少變數前綴的麻煩，也可以避免用區間來防止 z-index 被其他元素時插入的困擾。（只要直接在 List 加入值就好，不用再修改其他值）。 以上 Map 與 List 的介紹用實例讓大家了解在實際開發時的運用，當然使用場景不限於以上兩種而已。 我們之後會再優化這些 function。 其他 list 函數 nth index join append zip length 內建函數在 Sass 當中有一些函數可以幫助簡化 CSS 檔案。 darken lighten這兩個函數在操作 hover 狀態時非常好用，有時候我們收到的需求是：「hover 後的顏色變暗 10%」，通常設計師會直接給你顏色，不過透過 darken, lighten 這兩個函式操作的話能夠讓我們在實際開發上更有彈性。 1234.btn &#123; background-color: #000; &amp;:hover &#123; background-color: #333; &#125;&#125; 搭配 darken, lighten 1234.btn &#123; background-color: #000; &amp;:hover &#123; background-color: lighten(#000, 30%); &#125;&#125; rgba rgbSass 支援 rgba 與 hex 混合的語法，你可以直接這樣寫： 12345body &#123; background-color: rgba(#000, 0.3); // compiled background-color: rgba(0, 0, 0, 0.3);&#125; 比起原生的語法要額外寫 RGB 這三個參數，直接用 16 進位的表示法相對簡潔許多。Sass 會自動偵測是否要幫你轉換。 invert將輸入的顏色反轉。 @at-root在開發時，如果想要 access 到外層的 class，又希望保持模組化所以將 class 寫在 nested 內時，@at-root 就相當好用。 12345678910111213141516.tooltip &#123; //... font-size: 20px; @at-root body.active .tooltip-backdrop &#123; position: fixed; &#125;&#125;// compiled.tooltip &#123; font-size: 20px;&#125;body.active .tooltip-backdrop &#123; position: fixed;&#125; 加入 @at-root 之後，編譯後會將 class 搬移到最外層，而不是在 tooltip 裏面。這在保持模組化時、不想將 class 寫在外層、不想導致太深層的巢狀 class 時相當有用。 mixinmixin 在 autoprefixer 還沒有發佈之前，一直都被用來當作加入前綴使用。不過除了前綴之外，我們還能夠利用 mixin 做到許多事。像是： 管理字體大小 設定常見的 media query 簡化 class mixin 的撰寫方式是以 @mixin 作為開頭，呼叫時用 @include。 管理字體大小在 desktop 以及 mobile 上我們可能有不同的字體大小或字級想要管理，首先我們能夠用 map 宣告字體大小，再搭配 mixin 簡化流程。 123456789101112131415161718192021222324252627282930313233343536373839$fontSizes: ( desktop: ( 'x-large': 32px, 'large': 30px, 'medium': 26px, 'normal': 18px, 'small': 14px, 'x-small': 12px ), mobile: ( 'x-large': 28px, 'large': 24px, 'medium': 20px, 'normal': 16px, 'small': 12px, 'x-small': 10px ));@mixin font-size(size: \"normal\") &#123; @media screen and (min-width: 768px) &#123; $desktop: map-get($fontSizes, desktop); font-size: map-get($desktop, size); &#125; @media screen and (max-width: 767px) &#123; $mobile: map-get($fontSizes, mobile); font-size: map-get($mobile, size); &#125;&#125;.article &#123; @include font-size(normal); &amp;.large &#123; @include font-size(large); &#125;&#125; 這樣一來可以很容易地在手機、桌面中切換不同的字級設定。 管理 @media在 class 寫一大堆 @media 是一件很頭痛的事，我們可以設定好 $breakpoint 的變數後，再利用 mixin 封裝。 12345678910111213141516$breakpoints: ( desktop: 960px mobile: 568px,);@mixin for-mobile &#123; @media screen and (max-width: map-get($breakpoints, \"mobile\")) &#123; @content; &#125;&#125;@mixin for-desktop &#123; @media screen and (min-width: map-get($breakpoints, \"desktop\")) &#123; @content; &#125;&#125; 你也可以將所有的 breakpoint 統一封裝為一個 mixin，並且透過傳入參數的方式來決定，不過分開的寫法比較直覺一些。 Function在 Sass 當中寫 function 非常簡單。宣告 function 時用 @function 表示： 123@function return123 &#123; @return \"123\";&#125; 或者加入參數： 12345@function returnString($string) &#123; @return $string;&#125;returnString(\"123\"); // \"123\" Sass 裡頭有迴圈、for-loop、while 等等的功能，所以你可以客製化自己想要的函數，幫助開發。 Logging在 sass 當中，我們可以利用 @warn 、@error、@debug 這兩個函數做更好的開發體驗。 123456789@function getMessage($message, $type: \"error\") &#123; @if $type == \"error\" &#123; @error $message; &#125; @elseif $type == \"warn\" &#123; @warn $message; &#125; @else &#123; @debug $meesage; &#125;&#125; 如果你是使用原生的 Sass 編譯，則 error 會直接打斷編譯流程，並且印出錯誤在 stdout，使用 warn 的話不會打斷編譯，但會印出訊息在 stdout 上，而 debug 則是單純印出在 stdout 上。 搭配以上的功能，我們來實作一些在開發上常見的函數吧！ BEM utils為了讓 CSS 保持命名空間，我們常常使用 BEM 來組織 CSS 代碼。不過卻常常出現 __、-之類不太好看的符號，一不小心就可能打錯，我們可以使用 mixin 封裝這個功能。 12345678910111213141516171819202122232425262728293031@mixin block($block_name) &#123; .#&#123;$block_name&#125; &#123; @content; &#125;&#125;@mixin element($element_name) &#123; @at-root &amp;__#&#123;$element_name&#125; &#123; @content; &#125;&#125;@mixin modifier($modifier_name) &#123; @at-root &amp;--#&#123;$modifier_name&#125; &#123; @content; &#125; &#125;@include block(article-entry) &#123; padding: 20px; @include element(content) &#123; font-size: 20px; &#125; @include element(footer) &#123; background-color: #fff; @include modifier(larger) &#123; height: 500px; &#125; &#125;&#125;//.article-entry &#123; padding: 20px; &#125;.article-entry__content &#123; font-size: 20px; &#125;.article-entry__footer &#123; background-size: #fff; &#125;.article-entry__footer--larger &#123; height: 500px; &#125; 注意到我們在 mixin 當中使用了 @at-root，所以編譯的 CSS 會一律放到最頂層，這可以解決 BEM 層數太深的問題，也可以在開發時保持良好的模組性。你也可以在 mixin 加上一些參數決定是否要套用 @at-root 來保持開發上的彈性。 z-index 管理在上面的例子當中，我們利用 map-get 來取值，在實際開發上我們可能會想要再簡化一些，現在搭配 @function 做改善。 123456789101112131415161718192021222324252627282930313233$zIndexs: ( 'dropdown-backdrop', 'navbar', 'normal', 'dropdown', 'fixed', 'sticky', 'modal-backdrop', 'modal', 'popover', 'tooltip');@function zindex($name: normal) &#123; $index: index($zIndexs, $name); if (!$index) &#123; @error \"#&#123;$name&#125; doesn't exist! please checkout your `$zIndexs` variable.\"; &#125; @return $index;&#125;.dropdown &#123; z-index: zindex('dropdown') // 類似 indexOf&#125;.dropdown-backdrop &#123; z-index: zindex('dropdown-backdrop');&#125;// ....tooltip &#123; z-index: zindex('tooltip');&#125; 我們將 $zIndexs 包裝起來，並且如果傳入的參數並不存在於 $zIndexs 當中就會直接打斷編譯過程，並且顯示錯誤，也提供了相關的錯誤訊息給開發者參考。 引入 css variable目前比較新的瀏覽器都已經支援 css variable 了。我們可以將顏色等變數使用 css variable 重新撰寫，並且使用優雅降級來確保在其他瀏覽器也能正常工作。 123456789101112131415161718192021222324252627282930313233343536373839$colors: ( main: #aaa, font: #333, danger: red);:root &#123; @each $key, $color in $colors &#123; --#&#123;key&#125;: $color; &#125;&#125;@mixin css($prop, $key) &#123; #&#123;$prop&#125;: map-get($colors, $key); @if (map-has-key($colors, $key) == false) &#123; @error \"Unknown key `#&#123;$key&#125;`. checkout your `$colors` variable\"; &#125; @supports (--foo: \"bar\") &#123; #&#123;$prop&#125;: var(--#&#123;$key&#125;); &#125;&#125;.container &#123; @include css('background-color', \"main\");&#125;// compiled:root &#123; --main: #aaa; --font: #333; --danger: red;&#125;.container &#123; background-color: #aaa; @supports (--foo: \"bar\") &#123; background-color: var(--main); &#125;&#125; 這個 @mixin 寫得比較陽春一些，你可以加入更多參數或修改讓這個 mixin 能夠配合其他屬性。 結論PostCSS, CSS in Javascript, styled-component，都是為了解決問題而發展出來的工具，不過 Sass 也有許多功能值得大家參考，這篇文章提出一些常見的開發問題，並使用 Sass 來解決。Sass 的函數並沒有想像中那麼複雜，而且功能強大，你甚至可以利用 Sass 的內建函數來建置 sin, cos 等三角函數幫助運算，撰寫排序演算法、使用遞迴（如果你想的話…）。 使用 Sass 並不代表你需要拋棄 PostCSS 或其他工具帶來的便利性，像是 autoprefixer 以及 cssnano 等等，都是相當好用的插件。你甚至可以搭配使用帶來更快速及穩固的開發體驗。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"sass","slug":"sass","permalink":"http://kjj6198.github.io/tags/sass/"}]},{"title":"飛機能飛嗎 — 天氣造成的空難","slug":"aircrash-extreme-weather","date":"2017-08-05T12:00:07.000Z","updated":"2017-08-05T12:17:34.000Z","comments":true,"path":"2017/08/05/aircrash-extreme-weather/","link":"","permalink":"http://kjj6198.github.io/2017/08/05/aircrash-extreme-weather/","excerpt":"","text":"我並不是機師或是受過訓練的專業人士，只是剛好家住在機場附近，喜歡看看飛機了解一下空難而已，以上言論難免有錯誤之處，盡請斧正。另外本篇文章可能會造成閱讀者的情緒不安或焦躁，在閱讀前請三思 最近這幾天長榮員工因尼莎颱風集體請天災假，除了引起廣大迴響跟在 PTT 上實況飛機降落情形外，好像也就這樣了。剛好天時地利，寫篇關於天氣造成的空難，希望能夠讓各位（以及自己）更了解天氣對飛機產生的影響。 剛搬完新家兩個月，大約在行天宮靠近飛機巷的位置，從窗外的陽台就能聽見、看見 20 幾架飛機降落，當天的颱風夜也是。 我對飛機跟機師一直以來都是抱持著景仰的心態，跟軟體開發不同，那是一個無法容忍 bug 的世界，任何一個失誤都會造成無法挽回的結果。同時，撰寫一個穩定的飛機內部程式，代碼數應該就超過 100 萬了吧？已經遠超出我目前寫過的代碼了。 前言 — 你有勇氣嗎？在閱讀本篇文章之前，請先確認自己對空難的接受度。 如果你是那種會在颱風夜的機場大呼小叫的乘客，希望你看完這篇文章後能夠學會閉嘴；如果你上飛機第一件事是睡覺而不是看一下逃生門在哪，希望你以後會記得。 天氣對飛機造成的影響風現代的飛機設計通常都可以應付天氣惡劣的狀況。即使如此，在起飛、降落這兩個程序當中，仍然會有許多突發狀況。 起飛時，因為飛機在滿載燃油、乘客的狀況下起飛，又因為剛開始的速度不足，需要靠襟翼、縫翼這兩個機翼的幫忙來提昇受風面積、增加昇力，飛機才能夠順利起飛。 如果這時風向突然改變，從逆風變為順風，就有可能因為空速不足而導致升力降低。通常會提高機鼻以及增加動力來獲得升力。 但是在颱風這種極端天氣下，如果風速的變化相當劇烈，飛機很容易受到影響，如果來不及在風速改變時作出反應（飛機加速、減速都需要時間），很有可能來不及控制飛機就出事了。 下降時也是一樣，如果突然由逆風變順風，導致降落速度增加，甚至是風切變等狀況，在颱風的影響下所有的風速都會對飛機產生巨大的影響。 風切變簡單來說就是風速、風向在兩點之間的急劇變化。飛機這種龐然大物很容易受到風的影響，如果風速急劇變化，會導致飛機在短時間內有劇烈的速度、高度變化，這也是為什麼在颱風降落時會有大怒神的感覺。（相信我，你不會想要體驗的） 降落速度太快，飛機就會衝出跑道；速度太慢，飛機有可能失速而垂直落地。 我搭飛機那麼多次遇到颱風也沒事啊 當然，機長們受過專業的訓練，會盡量地往天氣最好的地方飛行，降落時也會無所不用其極地找出最佳的進場時機。但中華航空642班機就沒有那麼幸運了。 這台飛往香港的班機中，因為當天的天氣不佳，側風在下降時甚至超出標準，但機長仍然選擇降落，最後因為被起降架無法承受負荷而斷裂，右機翼斷裂往右翻滾，最後再跑道的草皮上停止。 看完你一定會想，WTF 都已經降落了還空難，怎麼那麼雖小？是的。 除了天氣本身會直接影響飛行之外，這場空難的最主要原因是機長與副機長並未按照標準程序操作。 蛤？不按照標準程序操作，機長跟副機長也太不專業了吧？在責怪機師不專業之前，我們先想想他們要承擔的責任有哪些。 把乘客平安送到目的地 聽命公司的要求起飛（而非出自專業判斷） 若決定停飛，可能被公司檢討，可能會上明日報紙頭條，可能會被其他航空公司嘲笑 若決定不降落，可能會被公司檢討，受到乘客指責，明日上頭條 有沒有發現什麼不對勁了？機師的判斷竟不全然來自專業，而是受到多方面的影響，這是多麽不合理的一件事情。 機師也是人，難免會夾雜情緒在裡頭。所以儘管天氣不允許，機師們還是得咬牙放手一搏。儘管現在現代飛機的設計已經相當進步，但我們真的能夠全身而退嗎？ 霧、雨霧跟雨是相當常見的天氣因素。霧最直接的影響就是能見度。飛機目前可以靠儀器降落系統（ILS）完成降落。這個精密的儀器能夠告訴飛機跑道的中線，以及下滑的軌道，至於更詳細的原理可以參考維基百科。 但是飛行員通常還是需要目視跑道，確認飛機飛在正確的路線上。關於目視跑道有一套規定，飛行員如果找不到跑道，最低能夠下降到某個標準高度。 如果在這個標準高度內仍然沒有找到跑道就要執行迷失進場（missing approach）程序並且重飛（Go around），但有時候因為機師過於自信、受外力影響、天氣影響等等原因，可能就會不遵守此程序。 像是波蘭空軍圖-154墜機事件就是一個相當經典的例子。 這架載著波蘭總統列赫·卡辛斯基以及多個高層長官的飛機，企圖在俄羅斯斯摩棱斯克降落時墜毀。當時因為機場起大霧，能見度只有 500 公尺左右，因此塔台建議飛行員直接飛往備降機場。 但此建議被機長拒絕，並且嘗試到 100 公尺高度時若不能降落在使用自動駕駛儀重飛。 結果導致機翼撞上樹梢墜落至地面解體，起火燃燒。機上乘客與機組人員 97 名全部遇難。 當時調查人員的結果認為，當時飛行員承受了間接壓力。有波蘭外交部禮賓司長、波蘭空軍司令官在後頭盯著你，硬著頭皮也要開下去。結果就釀成悲劇了。 前幾年發生的復興航空222號班機空難也是因為能見度影響、飛行員未遵守盲降標準而讓飛機在高度過低的情況下撞上樹林。（當然除了未遵守標準降落還有其他因素綜合在一起才導致這場悲劇）。 其他因能見度導致的空難 新加坡航空006號班機空難 冰雹冰雹對飛機來說是個相當可怕的夢魘，因為時速高達 800 ~ 900 公里的飛機，撞到冰雹可不是鬧著玩的。如果撞到擋風玻璃有可能會導致碎裂，被引擎吸入也可能導致引擎故障。南方航空242號班機空難就是因為在暴風雨區被冰雹侵襲，導致兩具引擎熄火故障，最後因迫降失敗而墜毀在公路上。 其他因天氣因素而觸發的空難如果你對因天氣引起的空難有興趣，可以參考維基百科的連結，或許可以給你更多的啟發。 事實上儘管是天氣因素影響，但仍然有 80% 的空難是因為人為錯誤而發生的。關於空難，很常見的心態是：「這次不一樣」 因為科技進步，所以這次不會墜機； 因為有XXX輔助，所以這次不會墜機； 因為已經建立了標準程序，所以這次不會墜機； 因為已經…，所以這次不會…。 這次不一樣實在是個可怕的心態。 如果不幸發生空難人生總是充滿著意外，僅管搭飛機的意外次數已經遠小於車禍（兩位受過正規訓練的機師、精密儀器輔助的飛機），要讓飛機墜毀是一件不容易的事。但我們還是要以防萬一。 在每趟飛行前記得保旅行平安險及旅行不便險，確保飛機在任何狀況下延誤，或是不幸發生空難時，能夠獲得最大的保障。至於如何挑選保險就看各位的需求了。 如果在飛機上發生空難，請先保護自己再去想辦法救別人。確定氧氣罩戴好能夠吸到氧氣，再來幫助別人。 在起飛前靜下心來聽空服員解釋逃生設備以及使用方式，他們很有可能救你一命。 採取防撞姿勢，雙手抱頭向前彎曲，頭貼在前方的座椅上，將撞擊力道降到最低。（以上描述僅為示意，詳細的防撞姿勢以空服員指導為準） 平時就當一位合格的旅客，不吵鬧、不喧嘩、不對空服員、地勤大呼小叫、多積點陰德。讓服務你的人心情舒適是確保整趟旅程品質的不二法門。 接下來可以怎麼做？ 僅靠政府、民航局來監督航空公司已經不太可靠。但人民團結起來的力量不容忽視，為了自己的生命著想，希望你能多關注這方面的議題，適時發聲與撻伐（記得理性溝通），讓航空公司想要說幹話的時候先三思。 嚴格遵守飛安標準。關於起飛與降落有一套標準規範（根據飛機與航空公司各有不同），必須要求航空公司嚴格遵守。 建立配套措施，讓颱風天仍然得上班的行業有個安心工作的環境。 結論1. 尊重專業無論何時我們都應該尊重專業，不僅是機上的機師，各行各業皆如此。不過尊重專業的前提是對方要是位專業人士。 2. 讓錯誤被大家看見空難不應該是大家說聲 R.I.P 就了事了，如果幾十人甚至幾百人的生命只能換來 R.I.P 的話是很令人扼腕的結局。每場空難都是相當珍貴的經驗。 3. 創造讓機組人員能夠安心的環境這在現在的台灣或許還是天方夜譚。但對於不合理的工時、環境、要求的公司，我們應該要能夠抵制或是拒乘，讓雙方的談判籌碼對等，才有扭轉的空間。而機師能夠心無旁騖地，依照自己的專業而非高層壓力做判斷。做得好就鼓勵，不按照程序飛行的機師我們也要幹到爆，讓他們知道背後都是有雙眼睛在監督著的。 4.不要讓天氣控制了情緒大家都想搭飛機，前往目的地。但無論如何，安全仍然是最重要的事，我們能做的是緩和自己的情緒。 停飛不是兒戲，不管對機長、航空公司、乘客來講都是個耗時、花費金錢的決定。 如果機師不需要再背負上層壓力；如果對於惡劣天氣的應對不是先試試看再說；如果公司講幹話、做蠢事能夠受到制裁，或許大家都可以過得輕鬆一點。 好吧講太遠了。 最後如果你對飛機、空難有興趣的話，可以搜尋看看 Discovery 的空中浩劫，你會發現空難的原因五花八門，遠超乎你的想像。有把飛機給小孩開結果墜機的；有兩台飛機在跑道上互撞直接罹難的；有在天空上沒有燃油最後滑翔到機場的；有起飛時踩著煞車硬要飛結果墜機的；有自動駕駛跟駕駛操作衝突而墜機的；有飛機不聽話結果墜機的；有因為貨艙放太多酒精結果燒起來而墜機的……，或許這些看似與我們無關的空難，能夠對你有些幫助。 本篇文章無意對任何機師、機組人員提出批評，只是分享個人觀點以及整理因天氣因素發生的空難事件。 最後，祝福每位機師跟乘客旅途愉快。 Bon Vayage!","categories":[{"name":"雜談","slug":"雜談","permalink":"http://kjj6198.github.io/categories/雜談/"}],"tags":[{"name":"飛機","slug":"飛機","permalink":"http://kjj6198.github.io/tags/飛機/"},{"name":"空難","slug":"空難","permalink":"http://kjj6198.github.io/tags/空難/"},{"name":"天氣","slug":"天氣","permalink":"http://kjj6198.github.io/tags/天氣/"}]},{"title":"淺談降維方法中的 PCA 與 t-SNE","slug":"PCA-and-t-SNE","date":"2017-07-17T16:00:00.000Z","updated":"2017-07-19T14:29:06.000Z","comments":true,"path":"2017/07/18/PCA-and-t-SNE/","link":"","permalink":"http://kjj6198.github.io/2017/07/18/PCA-and-t-SNE/","excerpt":"","text":"在機器學習當中，如果特徵數過多時，有可能會造成一些問題，像是： 過擬合 (overfitting) 處理速度較慢 如果超過三個特徵以上不好視覺化 所以這時候就需要對特徵做降維，在實務上，一個幾百幾千個的特徵當中，手動挑選特徵顯然不是一個明智的方法，所以以下來介紹兩個在機器學習中常常使用的兩種降維方法。 PCA（principal component analysis）主成份分析在介紹 PCA 之前，我們先來定義一下我們的目標是什麼： 將一個具有 n 個特徵空間的樣本，轉換為具有 k 個特徵空間的樣本，其中 k &lt; n 以下是 PCA 的主要步驟： 將數據標準化 建立共變異數矩陣（covariance matrix） 利用奇異值分解（SVD）求得特徵向量（eigenvector）跟特徵值（eigenvalue） 通常特徵值會由大到小排列，選取 k 個特徵值與特徵向量 將原本的數據投影（映射）到特徵向量上，得到新的特徵數 PCA 最重要的部分就是奇異值分解，因此接下來的章節讓我們來談談奇異值分解 直觀理解奇異值分解在矩陣分解當中，奇異值分解是個相當有名的方法。矩陣分解在高中數學當中最常見的用途就是解方程式（如 LU 分解），從奇異值分解的公式當中我們可以直觀地了解： 其中 A 為一個 m x n 的矩陣，𝑈 跟 V 都為正交矩陣，𝛴 為奇異值矩陣。奇異值矩陣為矩陣 A 對應的特徵值，在 PCA 當中又叫做主成份，代表對保存訊息的重要程度，通常由大到小遞減排列在對角中，是個對稱矩陣。 那麼這邊的 A 對應什麼呢？當然就是我們的特徵，只是特別要注意的是這邊的 A 我們通常使用共變異數矩陣（covariance martix）來求算，記得資料一定要先正規化後在進行奇異值分解 共變異數矩陣（covariance matrix） 因為共變異數矩陣常用 Sigma 表示，不要跟上面的 𝛴 搞混囉。因此如果要降維，我們可以用 U 的前 k 列乘上對應 𝛴 當中的特徵向量，就可以得出新的特徵了，而從幾何的角度來看 這樣子的運算在幾何當中，其實是將 X 投影到 U 的前 k 個向量 當中的黑線為特徵向量，長度為特徵值。 當中的藍點為數據原本的位置，紅點則是投影到特徵向量的位置。以上，我們成功將 2 維的數據降至一維了。 當然也可以從 3 維降到 2 維： PCA 的應用在降維的時候，我們希望留下最重要的特徵，剩下的比較不重要的特徵我們直接捨棄掉。 像是判斷一個人時，最重要的判別方式可能就是眼睛、鼻子、嘴巴等等，所以膚色、頭髮等等的特徵我們就可以捨棄，事實上在人臉辨識當中也常利用 PCA 做降維。 這是對奇異值分解相當直觀的了解，篇幅關係無法深入細談，若對奇異值分解有興趣可自行到維基百科 t-SNEPCA 是個相當直觀且有效的降維方式，不過在三維轉換為二維時我們可以看到，有些數據的集群完全被搗成一團。 PCA 是一種線性降維的方式，但如果特徵與特徵間的關聯是非線性關係的話，用 PCA 可能會導致欠擬合（underfitting） t-SNE 也是一種降維方式，不過他用了更複雜的公式來表達高維與低維之間的關係。t-SNE 主要是將高維的數據用高斯分佈的機率密度函數近似，而低維數據的部分使用 t 分佈的方式來近似，在使用 KL 距離計算相似度，最後再以梯度下降（或隨機梯度下降）求最佳解 。 高斯分佈的機率密度函數 其中，X 為隨機變量，𝝈 為變異數，𝜇 為平均。 因此原本高維的數據可以這樣表示： 而低維的數據用 t 分布的機率密度函數可以這樣表示（自由度為 1） 其中，x 為高維當中的數據，y 為低維當中的數據。P, Q 分別代表機率分佈。 為什麼會使用 t 分佈來近似低維的數據呢？主要是因為轉換成低維之後一定會丟失許多訊息，所以為了不被異常值影響可以使用 t 分佈。 t 分佈在樣本數較少時，可以比較好模擬母體分布的情形，不容易被異常值所影響。 T 分佈與高斯分佈的機率密度函數 兩個分佈之間的相似度求算兩個分佈之間的相似度，經常用 KL 距離（Kullback-Leibler Divergence）來表示，也叫做相對熵（Relative Entropy）。 在 t-SNE 中使用了困惑度（Perp）來當作超參數。 論文中提出通常困惑度在 5 ~ 50 之間。 Cost function用 KL 距離計算 Cost 求梯度可以寫成 最後再利用梯度下降法（或隨機梯度下降法）就可以找到最小值了。 實測：使用 MNIST 測試測試集可以到這裡下載，首先我們先用 PCA 降到二維看看。 PCA PCA 降維 可以發現降到二維之後，資料幾乎被搗成一團，完全看不出集群，這是因為 PCA 的線性降維在過程中損失太多訊息。 t-SNE 接下來使用 t-SNE 測試 使用 t-SNE 降維 這是使用 t-SNE 後的降維結果，可以發現降維過後，資料仍然分群地相當明確。從這兩張圖可以非常明顯看出這兩者（PCA, t-SNE）的差別。 小結後來又有人提出一連串改善 t-SNE 效能的演算法，詳情可以參考Accelerating t-sne using tree-based algorithms，大部分熱門的資料分析程式語言也都有實作，像是 sklearn, R, matlab 等等。 不過畢竟 t-SNE 不是線性降維，在執行時間上會比 PCA 來得久許多。 當特徵數量過多時，使用 PCA 可能會造成降維後的特徵欠擬合（underfitting），這時可以考慮使用 t-SNE 來降維 t-SNE 的需要比較多的時間執行 論文當中還有一些優化技巧（如何選擇困惑度等等），因為還沒有閱讀完畢，之後會再逐漸補上 參考資料 Van der Maaten L, Hinton G. Visualizing data using t-SNE Accelerating t-sne using tree-based algorithms 利用各種樹的演算法來加速 t-SNE 的運算 線代啟示錄 - 奇異值分解 文章同步發表於 medium","categories":[{"name":"機器學習","slug":"機器學習","permalink":"http://kjj6198.github.io/categories/機器學習/"}],"tags":[{"name":"降維","slug":"降維","permalink":"http://kjj6198.github.io/tags/降維/"},{"name":"PCA","slug":"PCA","permalink":"http://kjj6198.github.io/tags/PCA/"},{"name":"t-SNE","slug":"t-SNE","permalink":"http://kjj6198.github.io/tags/t-SNE/"}]},{"title":"做了一份週刊 - 日語八百屋","slug":"what-is-yaoya","date":"2017-07-13T16:00:00.000Z","updated":"2017-07-19T14:52:32.000Z","comments":true,"path":"2017/07/14/what-is-yaoya/","link":"","permalink":"http://kjj6198.github.io/2017/07/14/what-is-yaoya/","excerpt":"","text":"自學日文也已經三年多了，做了一份周刊，叫做日語八百屋。 粉絲專頁 Medium 什麼是日語八百屋？八百屋的由來源自於日語的八百屋（やおや），除了大家熟知的「蔬菜店」之外，也有「很多」的意思在裡頭。 我的目標很簡單：「滿足日文、日本、日劇愛好者們的求知慾以及資訊焦慮症。幫助減少學習阻礙、資訊不對稱、增加日本文化知識，內容涵蓋了日語學習、日本旅行、日本文化、動漫、語言學習技巧等等。」 學語言，多的是從微不足道的小事開始，50 音、文法、單字、敬語，最後內化成自己的事物，積跬步，成千里，最後逐漸變成「八百」。 學英文的線上資源很多，平台也相對完整，voicetube、希平方、tutorABC 都是不錯的學習管道，有大量的影片可以學習，在網路上用心搜尋，也能夠找到不錯的資源。 不過在學習日文的資源相對較少，多數都是從部落格上、FB 社團上而來的片段資訊。像是音速學習日語、王可樂的日語教室等等，仍然是以傳統的線下教學或是買書自學居多。 訂閱了週刊之後，每個禮拜一早上，我們都會寄送 5 ~ 10 篇不等的文章給讀者們閱讀。 為什麼不用經營粉絲專頁的方式就好？這答案其實蠻主觀的，因為日語相關的粉絲專頁幾乎是多到噴出來，在 facebook 順手搜尋日語、日文、日劇就會出現數不清的專頁。 然而，這些片段的資訊散佈在網路的各個角落，不僅統整困難之外，初學者在茫茫大海中也不知道該從哪裡開始。 分享特定領域的資訊不是我們的目的，而是想要不侷限在文法、單字、日文學習的範圍上，盡量由多面向的方式更深入日文這個語言。 出書跟開課，我們沒有那麼多的資源這樣做，而且坊間已經有很多人在這樣做了。 粉絲專頁，也夠多人在經營了，不缺我這一個興趣使然的日語學習者。所以對我來說目前最簡單也最純粹的方式就是寄送 email。 開設的粉絲專頁只是用來做推廣而已，基本上不會有太多貼文。 跟一般的粉絲專頁有什麼不一樣？不過，如果只搜集文法、單字相關的資訊，似乎有些枯燥乏味，而且網路上、各大書店、部落格上的內容豐富，絕對有許多優秀的教材。 要說不一樣的話，我們主要是用 email 來推送內容的。 email 雖然不像 facebook 那樣即時，但這反而是個優點，可以讓你只專注在目前的內容中。再來 email 不會被其他外在因素干擾，而且大家檢查 email 的頻率大概只比 facebook 少一點點吧！ 利用 email 渾然天成的特性，我們一週會推送 5 ~ 10 篇不等的文章，絕對是在一週（甚至是一天）看得完的份量。 雖然不一定能對學習有顯著的幫助，但希望能夠藉由這樣的方式，不僅擴展自身對日文的理解之外，也順便了解日本文化。因此，涵蓋的範圍很廣，有關於日本文化的，都可以是本週刊的素材之一。 未來希望能夠讓大家都能夠輕易地分享自己的筆記或連結，讓這份週刊的廣度更活躍，所以如果有人也願意分享文章或是學習筆記的話那就太好了。 畢竟一個人對日本所知有限，有人每天追劇、有人追動漫、有人對歷史瞭若指掌、有人可能懂得分析經濟等等。但如果能夠把這些內容結合起來，這份週刊就會變得非常有料：）。 最後，不妨到網站訂閱一下 https://www.shurado.com 吧！ 技術線因為想要專注在寫文章上，花了兩天左右建好網站，並且逐漸擴充功能，反正最基本的功能只要達到： 寄信 製作電子報 寄送電子報 存放歷期週刊的頁面 首頁 基本上就差不多了。整個 app 是用 Ruby On Rails 寫的，用 Redis 管後台任務，比較麻煩的頁面互動就用 react + redux + redux-observable 解決。 寄信的功能主要串接了 mailgun 跟 mailchimp 這兩個第三方套件。mailgun 是負責寄送單一信件，例如訂閱確認信等等；而 mailchimp 則是負責寄送電子報。兩個的 API 都還蠻好串接的，文件也寫得很不錯。 之後還會陸續加上一些功能，例如： 在後台發布文章時，能夠同步發表到 medium 跟粉絲專頁 日文文章可以依照需求加入平假名讀音 可以用搜尋的方式找到想要的週刊或 issue 後記想說在畢業前好好做點事情，所以趁著熱情還沒消失前，也在 hahow 上開了一門課叫做從 0 到 1 - 為初學者而設計的日文課，整理了基本的日文文法。 後來想想，訂價實在太便宜，$1500 裡頭涵蓋的文法幾乎是一堂 $10000 出頭的補習班課程。 不過結果還挺出乎意料的。原本想說能夠成功開課就不錯了，沒想到現在募資率竟然已經破 900% 了。現在想想，如果知道準備一門課那麼累的話，或許我就不會開課了，尤其是在雙語之間上字幕，實在有夠累人。 心得不知不覺這份週刊已經要到 20期了，最大的體會是技術已經不是最大的瓶頸，而是如何產生這些內容。雖然之後或許可以靠著機器學習的幫忙省下一些功夫，不過內容的生產永遠是有需求的，不過光有內容，卻沒有良好的體驗來吸引讀者們的話，再怎麼努力產出也是白搭。 希望能夠繼續堅持下去。","categories":[{"name":"日語學習","slug":"日語學習","permalink":"http://kjj6198.github.io/categories/日語學習/"}],"tags":[{"name":"日語學習","slug":"日語學習","permalink":"http://kjj6198.github.io/tags/日語學習/"},{"name":"日語八百屋","slug":"日語八百屋","permalink":"http://kjj6198.github.io/tags/日語八百屋/"}]},{"title":"redux-saga 與 redux-observable(待整理)","slug":"redux-saga-and-redux-observable","date":"2017-05-04T16:00:00.000Z","updated":"2017-08-12T04:20:21.000Z","comments":true,"path":"2017/05/05/redux-saga-and-redux-observable/","link":"","permalink":"http://kjj6198.github.io/2017/05/05/redux-saga-and-redux-observable/","excerpt":"","text":"前陣子有幾個很突出的函式庫，專門處理 redux 當中非同步的 action。最簡單暴力有效的方法是 redux-thunk，的確，一般的 ajax call 或是簡單的發送非同步請求時，thunk 能夠很直覺也很方便地完成我們要的需求。 但，如果是更複雜的應用呢？比如說： 為了減少伺服器的負擔，我們只想要對使用者最後的操作做處理 如果發送請求之後，在還沒取得回應之前，我們想要取消請求 如果我們要在 action 裡頭對這些請求做判斷，很快這些 action 就會變得肥大臃腫，逐漸難以維護。而且，thunk 並沒有辦法取消請求。 這篇文章會透過範例，介紹 redux-saga 跟 redux-observable，並且分析兩者的不同之處，最後再來做比較。 要解決什麼問題？這兩個函式庫雖然風格非常不同，但是要解決的問題是相同的，有效管理 side effect。而最大的不同點在於，redux-observable 使用 RxJS 實作，而 redux-thunk 使用 es6 的 generator。 所有解決非同步的方式都有一種目的，讓非同步的操作看起來像是同步的。 callback最剛開始的解決方案是 callback，但缺點顯然易見，很快就會因為多層牽套的關係導致越深層的程式碼越來越難維護。 Event後來，採用監聽 event 的方式，我們可以很快地對事件變化做特定的行為，這在簡單的非同步狀況下可以有效解決問題，但如果是事件同時併發，或是監聽多個事件的話，一樣會出現 callback 的問題。 Promisepromise 把之前的 callback 做扁平化，任何的操作可以用 then(resolve, reject) 的方式達成，同時 Promise 也有提供all 之類的操作對多事件統一處理。 ReactiveX什麼是 functional reactive programming 簡稱為 RxJS 在去年七月份左右逐漸竄紅，主要的概念在於提供一連串的 functional API 操作 Observable Stream。 Your mouse is database 這篇文章的將 UI 上的事件操作都當作無止盡的 stream wiki observer pattern 和一般的 observer 的不同點在於，如果一個 Observable 物件沒有接收到 subscribe 方法時，並不會開始流動。 reactive，對資料的變動做出反應。 將所有的資料都視為 observable stream，統一用 Observable 處理。 reactive programming redux-observableobservable 是什麼？其實這個名詞並不是新玩意，在 UI 上我們也常常使用 observer 的概念。例如 addEventListener(eventType, handler)。 監聽畫面上的某個事件，並且對此事件做相對應的處理，這就是 observer。 當然，這樣的概念很廣泛，事實上我們也不需要過度的解釋名詞。 在 Rx 當中，我們將所有事件的組合當作一個資料流 結論這邊我沒辦法很明確地說這兩個函式庫適合的場景，因為這兩個函式庫要解決的問題其實非常類似，只是手法不同而已。 如果你先前就已經具備了足夠的 RxJS 的知識，比較習慣 functional reactive programming 的話，那麼 redux-observable 很適合勝任這個工作。 又或許，在團隊裡頭技術的迭代較快，可能今年 react，明年變成 Angular(哪家公司會這樣做XD)，那麼選擇 redux-observable 會在之後技術線改變時較容易修改，因為 Angular2 本身配備了 RxJS，搬移的成本較低。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"redux","slug":"redux","permalink":"http://kjj6198.github.io/tags/redux/"},{"name":"saga pattern","slug":"saga-pattern","permalink":"http://kjj6198.github.io/tags/saga-pattern/"},{"name":"observable","slug":"observable","permalink":"http://kjj6198.github.io/tags/observable/"},{"name":"RxJS","slug":"RxJS","permalink":"http://kjj6198.github.io/tags/RxJS/"}]},{"title":"5/1 勞工大代誌","slug":"labor-project","date":"2017-04-30T16:00:00.000Z","updated":"2017-07-19T14:02:30.000Z","comments":true,"path":"2017/05/01/labor-project/","link":"","permalink":"http://kjj6198.github.io/2017/05/01/labor-project/","excerpt":"","text":"先來看成品吧！ 記錄一下這個專案的始末。 規劃從四月中旬開始規劃、搜集資料到實作，都是一個人慢慢整理而成的，除了想要練習更好的視覺化技巧之外，主要還是想透過這樣的方式來了解台灣的勞動問題，以及曾經經歷過的勞工運動。 因為平時還有課業跟工作要顧，所以實際上花的時間不多，最後兩天甚至是熬夜在趕工。有更多的原因是因為，寫到一半發現又有更多資料想要搜集，不知不覺就變得非常龐大了。 不過這個專題仍然有太多議題沒有涵蓋到，像是年金制度、職災統計等等。因為時間上的關係，無法深入介紹。 為什麼想要做這份專案國中跟高中的時候，或許是職科出身的關係，平時除了從報紙跟電視看看一些新聞外，很少汲取社會的議題和發生的事。 這樣半懺悔、半好奇的心態，開始搜集了一些台灣過去的勞工運動以及相關數據。像是薪資漲幅、平均工時、出生率等等，這些都是當我看到數據的當下才發現，原來事情那麼大條。 工時高居全球、薪資漲幅凍漲將近十年、出生率最後一名、即將邁入超高齡社會，這些都是現在台灣正在面臨，且有可能會日漸嚴重的議題。 如果說現在這個渺小的我能夠做些什麼，大概就是勞動節時上街遊行，聽聽勞工的聲音，畢竟身為一位準勞工，再過不久大概就會遇到同樣的情境。 更何況是在我還沒出社會之前，就已經是那麼慘的現況了。 台灣的勞動環境仍然有許多待改進的地方，後人能夠享受到的果實絕不是理所當然。 這些前輩們用血汗、用人生、甚至賠上性命來爭取更好的勞工環境。 身為一位工程師能做的事情不多，這個社會上還有更多用科技無法觸及的事。但能夠拋磚引玉地讓人了解到「啊！原來還有這樣子的事啊」，就好了。 其實在查資料的時候，有很多讓人鼻酸的故事。 像是關廠工人臥軌時，民眾大喊輾過去；像是看到台電大樓的紀念碑連名字都沒有，藏在樹叢裡頭；像是看見 101 樹立的國殤紀念碑，卻過了那麼久才知道那是為何而來。 我們所處的社會當中有太多的理所當然，捷運順利地運作、高鐵能夠平安無事地從高雄開到台北、101 能夠安穩座落在臺北城、垃圾桶的垃圾有人收、廁所有人清、24 小時的便利商店，導致我們常常會忘記那背後隱藏的事情是由多少人的汗水（或是鮮血）堆積起來的，更何況是以前沒有任何勞基法保護的勞工們。 最後，特別感謝小公主陪我度過忙碌的一個月，幫我找資料跟拍照，這一個月陪我一起奮鬥；還有 潘敬昇 （Sheng Pan） 義無反顧地幫我設計了很有質感的 LOGO 跟 Title，還有設計上的建議。 最後，如果你們也有什麼勞工議題或心得想要分享的話，可以在 facebook 或是 twiiter 加入 #勞工大代誌 這個 hashtag。如果你喜歡這份專案，也可以順手把他分享出去。 另外，除了在網站裡頭所提到的議題跟事件，還有太多是我不知道、不清楚的事情存在在這個社會上。 我整理了一份勞工大代誌總表：https://goo.gl/nPxeg2 任何人都可以編輯。 敬，所有勞工們。 後記 之後這個專題被分享到求職天眼通上，也算是讓更多人知道了。 暑假選修了一門叫做職場災害與防治","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"勞動節","slug":"勞動節","permalink":"http://kjj6198.github.io/tags/勞動節/"},{"name":"視覺化","slug":"視覺化","permalink":"http://kjj6198.github.io/tags/視覺化/"},{"name":"d3js","slug":"d3js","permalink":"http://kjj6198.github.io/tags/d3js/"},{"name":"勞工大代誌","slug":"勞工大代誌","permalink":"http://kjj6198.github.io/tags/勞工大代誌/"}]},{"title":"Rails app 自動化部屬 - hubot 與 heaven","slug":"chatops","date":"2017-03-01T15:12:42.000Z","updated":"2017-03-02T12:55:43.000Z","comments":true,"path":"2017/03/01/chatops/","link":"","permalink":"http://kjj6198.github.io/2017/03/01/chatops/","excerpt":"","text":"前言目前所在的公司裡頭是直接在本地端的 terminal 跑 cap staging deploy 指令。 capistrano 作為自動部署化的工具非常方便，但難免會遇到幾個問題： 不是團隊中的每個人都有相同的環境 大家都在部署，結果 staging 上現在到底是哪個 branch，完全一頭霧水。 deploy 這件事情卡在本地端。 對一家新創來說，越穩定的開發效率和流程，就越能夠專注在產品當中。所以我們希望做到幾件事： 開發團隊都可以輕鬆的部署 不用在本地端下指令部署，還要多設定 ssh。 就算沒有開著電腦，也可以輕鬆地部署 能夠記錄部署的狀況 如果出問題了，可以快速 rollback 回上一個版本 逐漸厭倦了在 terminal 打指令，ssh key 手動加的日子。於是打算自己研究有沒有更流暢的部署流程。 之前在 Sudo 裡頭，幸好有 @ocowchun 跟 @henry 兩位懶工，devops 做得非常完整，才能夠專注在開發功能，而不是一堆繁複的設定當中。（雖然才剛開發完就關閉服務了…） 目前覺得最合適的解決方案是搭配 hubot-deploy 以及 heaven 來幫助部署。 但 heaven 的文件實在寫的有夠爛。 看了老半天，甚至看了一下 source code 才知道到底該怎麼設定。於是決定將整個設定流程分享給大家，希望能夠減少其他 devops 們走歪路的時間。 主要流程 hubot 接收到部署指令後，會發送 github deployment，同時會觸發 deployment 這個事件，這時 github 就會發送 POST 給在 webhook 設置的 url（這邊接收者為 heaven），heaven 接收到請求之後，就會開始部署，再一一回傳我們想要知道的部數狀況。 hubot-deployhubot-deploy 能夠用 slack 對 slack-bot 下指令的方式建立 github 的 deployment event。 heaven是一個 Rails 的 application。主要有一個 /events 負責接收從 github deployment 傳來的 deployment 與 payload。 設定步驟heaven 的文件寫得不明所以hubot-deploy 也是草草帶過。幾乎只能靠著他們提供的流程圖，不斷的試錯與通靈。 設定 hubot-deploy getting started with hubot 利用 yeoman 產生 hubot，並且選擇 adapter 為 slack。 在 package.json 中加入 hubot-deploy，或者 run npm install hubot-deploy --save-dev 在 external-scripts.json 裡頭加入 hubot-deploy。 到 apps.json 中設定想要部署的 repos 有哪些： 12345678&#123; &quot;repo_name&quot;: &#123; &quot;provider&quot;: &quot;capistrano&quot;, &quot;auto_merge&quot;: false, &quot;repository&quot;: &quot;kjj6198/deploy101&quot;, &quot;environments&quot;: [&quot;production&quot;, &quot;staging&quot;] &#125;&#125; 這些資料在 hubot 送出 deployment 時會一併塞入 payload 當中。像是這樣： 1234567891011121314151617181920payload: &#123; &quot;name&quot;: &quot;repo_name&quot;, &quot;robotName&quot;: &quot;yourrobot&quot;, &quot;hosts&quot;: &quot;&quot;, &quot;notify&quot;: &#123; &quot;adapter&quot;: &quot;slack&quot;, &quot;room&quot;: &quot;123456789&quot;, &quot;user&quot;: &quot;123456789&quot;, &quot;user_name&quot;: &quot;kjj6198&quot; &#125;, &quot;config&quot;: &#123; &quot;provider&quot;: &quot;capistrano&quot;, &quot;auto_merge&quot;: false, &quot;repository&quot;: &quot;kjj6198/deploy101&quot;, &quot;environments&quot;: [ &quot;production&quot;, &quot;staging&quot; ] &#125;&#125; 特別要注意的是，provider 的欄位之後會送給 heaven，所以 provider 的值必須是 heaven 有的（之後會提到），或是自己實作 Provider。 這樣子我們的 hubot 就算設定完成了。先部署到 heroku 上測試看看，部署到 heroku 很簡單： 123456heroku logingit initgit add .git commit &quot;init&quot;heroku creategit push heroku master 部署成功後，比較重要的變數有幾個： 變數名稱 用途 HUBOT_GITHUB_TOKEN GITHUB_TOKEN，到個人帳號 &gt; settings &gt; personal access tokens 設定。設定好權限，因為 hubot 只是用來建立 repo 的 deployment，勾選 repo 即可。 HUBOT_SLACK_TOKEN 你的 slack-bot token。可以到這裡設定 全域變數可以到 heroku 的 dashboard 或是直接用 command line 設定： 12heroku config:set HUBOT_GITHUB_TOKEN=abccccheroku config:set HUBOT_SLACK_TOKEN=abcccc 測試一下是否成功。在你設定的頻道中輸入 hubot deploy:version 其中的 hubot 要跟你的機器人名稱相同，例如機器人的名稱為 tripmomo，那麼我就要輸入 tripmomo deploy:version。 成功的話 hubot 會回應你目前的版本訊息。 確認 hubot 有送出 deployment 事件。輸入 hubot deploy app to statging 輸入 curl -H &quot;Authorization: token YOUR_GITHUB_TOKEN&quot; https://api.github.com/repos/my-github/my-repo/deployments 看看 deployment 是否建立成功。如果成功會回傳： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; \"url\": \"https://api.github.com/repos/my-github/my-repo/deployments/28301325\", \"id\": 123456, \"sha\": \"2e3xxxxxxxaaaaaaabbbbbbb\", \"ref\": \"develop\", \"task\": \"deploy\", \"payload\": &#123; // from apps.json \"name\": \"my-app\", \"robotName\": \"tripmomo\", \"hosts\": \"\", \"notify\": &#123; \"adapter\": \"slack\", \"room\": \"aabbccdd\", \"user\": \"aabbccdd\", \"user_name\": \"kalan.chen\" &#125;, \"config\": &#123; \"provider\": \"capistrano\", \"auto_merge\": false, \"repository\": \"my-github/my-repo\", \"environments\": [ \"production\", \"staging\" ] &#125; &#125;, \"environment\": \"staging\", \"description\": \"deploy on staging from hubot-deploy-v0.13.27\", \"creator\": &#123; \"login\": \"kjj6198\", \"id\": 123456, \"avatar_url\": \"https://avatars2.githubusercontent.com/u/123456?v=3\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/kjj6198\", \"html_url\": \"https://github.com/kjj6198\", \"followers_url\": \"https://api.github.com/users/kjj6198/followers\", \"following_url\": \"https://api.github.com/users/kjj6198/following&#123;/other_user&#125;\", \"gists_url\": \"https://api.github.com/users/kjj6198/gists&#123;/gist_id&#125;\", \"starred_url\": \"https://api.github.com/users/kjj6198/starred&#123;/owner&#125;&#123;/repo&#125;\", \"subscriptions_url\": \"https://api.github.com/users/kjj6198/subscriptions\", \"organizations_url\": \"https://api.github.com/users/kjj6198/orgs\", \"repos_url\": \"https://api.github.com/users/kalanchen/repos\", \"events_url\": \"https://api.github.com/users/kjj6198/events&#123;/privacy&#125;\", \"received_events_url\":\"https://api.github.com/users/kjj6198/received_events\", \"type\": \"User\", \"site_admin\": false &#125;, \"created_at\": \"2017-03-01T12:24:20Z\", \"updated_at\": \"2017-03-01T12:24:20Z\", \"statuses_url\": \"https://api.github.com/repos/my-github/my-repo/deployments/12345667/statuses\", \"repository_url\": \"https://api.github.com/repos/my-github/my-repo\" &#125; 更多 deployment API 可以到 github deployment API 看看。 設定 heaven 到 heaven 將 repo clone 下來。 設定全域變數 變數名稱 用途 DEPLOYMENT_PRIVATE_KEY 因為 heaven 是用 ssh 登入，需要 private key。如果 server 在 ec2 上，也可以用 pem 的方式來設定。 GITHUB_CLIENT_ID 到個人設定頁面 &gt; OAuth application 產生 GITHUB_CLIENT_SECRET 到個人設定頁面 &gt; OAuth application 產生 DATABASE_URL heaven 會建立資料庫紀錄 deployment GITHUB_TOKEN heaven 會使用 gist 來當作 stdout stderr。所以在設定 token 時記得把 gist 打勾勾。 其他的變數可以到 這裡 查看。 補充說明 DEPLOYMENT_PRIVATE_KEY：原始檔案長這樣 123456789101112131415161718192021222324252627-----BEGIN RSA PRIVATE KEY-----MJVGa/WNT9aFs63ykxLCdGzav8CfQ5vKXrLrllHXUYFaB2yaN72L+fSsXAy9zMs2vy6wV2fB6j3YrVNCnBwUUNGTX9Ka6eeK98dCvHVyyE9Iz3CJAWZxaI03Px/xX9psM4kDWe7IA6+mnuCVSzwQVWMdOoAXbQbhGdfeixbqljNhJrKW/jA9w4BNarwGYv4E0MwdU9x7zpk826ytza87yXHSdNuTKcsGQk4XHMYxJECj4EM8vTlVlEyEXZtCeh2zP4bjYkTcBom4nC/q7Ea7Pmy1iDJqs0qc1L/xtNMypMhx4iIaeDVawkvBaL6t9IPTKVuC9Y1uw5nJP1gwxXa5qoazhcikzqRYmaeWIzsZrcVShZBrJO9/a/APxXY7qJpJ0r1YYTykw7THYj2QYiv8cfF64/vh9cB0NELEp5hIuS82Mf6CjqRR7QYR+By3uIdDhQ77NMpQlmIC+TCJsLoADqwmEEZCiQSejtkXXtN/mNl581jP8+ViNkWZfPYWe7g6yUeXVN1cBPo6AIu+lStE+SlR8lbu7sdpn6lid1pJf50zeythabze81y/nrAdx+JnscACBJBrERkhm2wdULkqwMV2g0U53YpYVAs2fFU1hGzRcE5zF1sdy9RLLX45MzrmlRErTbSUcnoQJhhCso5uNY6MMnr/rQF920KA0Ufr40IBcQ8bOSX7lJucST5bZLDgH7g16rimHgK4I9rrvKy4plvbolfpuKGMYJDS3Q7IW5cL5lWLU3HaVSn+VyZe8p3AprVx0XmSCwpmUzbDI6FoqniVPVdgis2tV1uKdnJPVn0DoK0ersosGXmALytbYLeEarH/cIlGGCoGbIX+Iv3u8aICBEG2eR8eXmQSlGI5rp9hGK/JrlkL3PywVmPw4EfiatiS6Y12Tuu8bdpPxBTzXK3PoZ23Pc+1l7NXXIzBeGnj56bALOIbAY5kg+lIRdtPNSTAW8IVgFJUl4uzy/NXn/ewiE093ZVs59I2x4OoS14S20mkM/ldWbvlVm4Z3JxCxIWsIV8aLznttic5MJUGjGoqH1Brg0o1HyWdkoEcC1N0G57oO4pN4UTD5co5xY9jAi2NIcFCYzqrdTfSlPWJBZLhjZ5hOXIwuTeJfRxDAVphaUqfpXb3o3URGRWiGENAkIYKiq4XeNguwrFBzg5CB7NEKvjbjJ31GI26yAPa7yrKpuNFAjPpO6JKdL8slvx8GXCOSbhGPFxzmtYzEeMxmnHqOa0Z953XeheKfJoipqRAyENxPBvclDonqVfxuTvwcZzqFD+XjDJCJ5INwuwk2WupVzQjzV6TagcIX63Kq1Z9HSoFIBiCrdLzTMDG4Ro32wpN1tFQFz6alvwKtifGwhvG3qqmsfcQqw56gGY0DWIqG5x/thdG7UzZT7iMVDJVLAO5wNnBK6L+feov9LqP7ONAonBVawmTv0ArjVhhkYZEi6d+ymvPpL1ORFAymLnedpk4VmmmQvkUu0KudRqulavTIrnXFkuv2va+5X9mHGoNNMo1TXk2XX1eM4Rc7nAY6IwPyAuFEtT5ocWBklB/qUZtdu4fG876o0X87GklR9ZfPG+tWpH2F+1j1mMHKuiP-----END RSA PRIVATE KEY----- 要修改成： 1-----BEGIN RSA PRIVATE KEY-----\\nMJVGa/WNT9aFs63ykxLCdGzav8CfQ5vKXrLrllHXUYFaB2yaN72L+fSsXAy9zMs2\\nvy6wV2fB6j3YrVNCnBwUUNGTX9Ka6eeK98dCvHVyyE9Iz3CJAWZxaI03Px/xX9ps\\nM4kDWe7IA6+mnuCVSzwQVWMdOoAXbQbhGdfeixbqljNhJrKW/jA9w4BNarwGYv4E\\n0MwdU9x7zpk826ytza87yXHSdNuTKcsGQk4XHMYxJECj4EM8vTlVlEyEXZtCeh2z\\nP4bjYkTcBom4nC/q7Ea7Pmy1iDJqs0qc1L/xtNMypMhx4iIaeDVawkvBaL6t9IPT\\nKVuC9Y1uw5nJP1gwxXa5qoazhcikzqRYmaeWIzsZrcVShZBrJO9/a/APxXY7qJpJ\\n0r1YYTykw7THYj2QYiv8cfF64/vh9cB0NELEp5hIuS82Mf6CjqRR7QYR+By3uIdD\\nhQ77NMpQlmIC+TCJsLohtJEmEEZCiQSejtkXXtN/mNl581jP8+ViNkWZfPYWe7g6\\nyUeXVN1cBPo6AIu+lStE+SlR8lbu7sdpn6lid1pJf50zeythabze81y/nrAdx+Jn\\nscACBJBrERkhm2wdULkqwMV2g0U53YpYVAs2fFU1hGzRcE5zF1sdy9RLLX45Mzrm\\nlRErTbSUcnoQJhhCso5uNY6MMnr/rQF920KA0Ufr40IBcQ8bOSX7lJucST5bZLDg\\nH7g16rimHgK4I9rrvKy4plvbolfpuKGMYJDS3Q7IW5cL5lWLU3HaVSn+VyZe8p3A\\nprVx0XmSCwpmUzbDI6FoqniVPVdgis2tV1uKdnJPVn0DoK0ersosGXmALytbYLeE\\narH/cIlGGCoGbIX+Iv3u8aICBEG2eR8eXmQSlGI5rp9hGK/JrlkL3PywVmPw4Efi\\natiS6Y12Tuu8bdpPxBTzXK3PoZ23Pc+1l7NXXIzBeGnj56bALOIbAY5kg+lIRdtP\\nNSTAW8IVgFJUl4uzy/NXn/ewiE093ZVs59I2x4OoS14S20mkM/ldWbvlVm4Z3JxC\\nxIWsIV8aLznttic5MJUGjGoqH1Brg0o1HyWdkoEcC1N0G57oO4pN4UTD5co5xY9j\\nAi2NIcFCYzqrdTfSlPWJBZLhjZ5hOXIwuTeJfRxDAVphaUqfpXb3o3URGRWiGENA\\nkIYKiq4XeNguwrFBzg5CB7NEKvjbjJ31GI26yAPa7yrKpuNFAjPpO6JKdL8slvx8\\nGXCOSbhGPFxzmtYzEeMxmnHqOa0Z953XeheKfJoipqRAyENxPBvclDonqVfxuTvw\\ncZzqFD+XjDJCJ5INwuwk2WupVzQjzV6TagcIX63Kq1Z9HSoFIBiCrdLzTMDG4Ro3\\n2wpN1tFQFz6alvwKtifGwhvG3qqmsfcQqw56gGY0DWIqG5x/thdG7UzZT7iMVDJV\\nLAO5wNnBK6L+feov9LqP7ONAonBVawmTv0ArjVhhkYZEi6d+ymvPpL1ORFAymLne\\ndpk4VmmmQvkUu0KudRqulavTIrnXFkuv2va+5X9mHGoNNMo1TXk2XX1eM4Rc7nAY\\n6IwPyAuFEtT5ocWBklB/qUZtdu4fG876o0X87GklR9ZfPG+tWpH2F+1j1mMHKuiP\\n-----END RSA PRIVATE KEY----- 既然公開，這組 private key 當然報廢了 設定 Gemfile因為 heaven 的動作會是拉下最新的 repo 後，執行 cap ... deploy 的指令，所以capistrano 的版本必須跟要部署的那個版本相同。同時，也要注意任何 asset 相關的 gem 也要一併放入 heaven。舉例來說，如果我的 Capfile 有用到 12345gem 'capistrano', '3.4.0'gem 'capistrano3-unicorn'gem 'capistrano-rails'gem 'sitemap_generator'gem 'capistrano-rvm' 那麼就要將這些 gem 加入 heaven 的 Gemfile 當中。因為 heaven 會將要部署的 repo 抓下來之後，進去資料夾輸入 cap staging ... deploy 的指令，所以如果沒有安裝相對應的 gem，heaven 就沒辦法部署了。 串接 github deployment 先到 repo 的 settings &gt; deploy key 加入 ssh-key。 到 repo 的 settings &gt; webhooks &gt; add webhook Payload URL 填入你的 heaven 部署 host 的網址，例如：https://yourapp.com.tw/events。如果想要修改，可以到 heaven repo 的 routes.rb 中修改 Content Type 選擇 application/json Secret 依需求選填 下面問你這個 webhook 要監聽哪些事件，我們是用 deployment 來做部署的，所以選擇 deployment 以及 deployment status。 部署如果是部署到 heroku 的話，因為 heaven 要開 redis 跟 resque。記得加入相對應的 add-on 以及 REDIS_URL 。 同時別忘記了要建立資料庫 heroku run rake db:migrate。 hubot-deploy 常用指令 hubot deploy:version 目前版本 hubot deploy repo： 根據 apps.json deploy 指定的 repo name。 hubot deploy repo/branch：將指定 repo 的某一個 branch 部署到預設的 environment 中。可設定 HUBOT_DEPLOY_DEFAULT_ENVIRONMENT 來決定 hubot deploy repo/branch to staging：將指定 repo 中的 branch 部署到 staging 筆記 heaven 的文件雖然不明所以，但是程式碼跟測試寫得蠻完整的，熟悉 ruby 的開發者甚至可以將整個 heaven 架設好，修改一下程式碼，加上 routes，直接建立 UI 一鍵部署。 OptionParser::AmbiguousOption: ambiguous option: -s：不確定是不是 Capistrano 更新之後指令有變動。解決方法是到 lib/heaven/provider/capistrano.rb 修改 deploy_command 1234567891011121314151617181920212223242526module Heaven # Top-level module for providers. module Provider # The capistrano provider. class Capistrano &lt; DefaultProvider ..... def execute return execute_and_log([\"/usr/bin/true\"]) if Rails.env.test? unless File.exist?(checkout_directory) log \"Cloning #&#123;repository_url&#125; into #&#123;checkout_directory&#125;\" execute_and_log([\"git\", \"clone\", clone_url, checkout_directory]) end Dir.chdir(checkout_directory) do log \"Fetching the latest code\" execute_and_log(%w&#123;git fetch&#125;) execute_and_log([\"git\", \"reset\", \"--hard\", sha]) deploy_command = [cap_path, environment, \"部署的 cap 指令\"] log \"Executing capistrano: #&#123;deploy_command.join(\" \")&#125;\" execute_and_log(deploy_command) end end end endend 因為 heaven 在部署時會使用 gist 當作 stdout 跟 stderr，在設定 GITHUB_TOKEN 的時候一定要記得把 gist 的 scope 打勾 Net::SSH::AuthenticationFailed: Authentication failed for user apps@staging.tripmoment.com ：SSH private_key 設定有誤。先確定這組 ssh key 是否已經加入 github，再來確定將 passphrase 拿掉，並且將 ssh private key 變成一行加上 \\n。 ArgumentError: Could not parse PKey: no start line 沒有將 SSH private key 的 passphrase 移除 後記通常在公司裡頭，開發團隊人數不多的話，devops 都是由後端兼任的，前端比較少接觸。不過用「我是前端，我不需要管 devops」這種藉口搪塞自己不去學習好像也說不太過去，畢竟開發一個健全的系統絕對不可能只有前端而已。 這篇文章試著將文件中沒有提到或是省略的步驟整合起來，heaven 跟 hubot-deploy 的文件中有太多沒有提到的細節，導致整合起來時需要花不少時間試錯。希望能夠節省大家踩雷跟翻原始碼的時間。 這篇文章還有許多 devops 的細節沒有詳述，畢竟建立一套完整的 devops pipeline 需要時間，自己對於 CI/CD 的設定也還不夠熟悉。 參考資源： 顆顆 devops 筆記 chatops","categories":[{"name":"rails","slug":"rails","permalink":"http://kjj6198.github.io/categories/rails/"}],"tags":[{"name":"devops","slug":"devops","permalink":"http://kjj6198.github.io/tags/devops/"},{"name":"chatops","slug":"chatops","permalink":"http://kjj6198.github.io/tags/chatops/"},{"name":"capistrano","slug":"capistrano","permalink":"http://kjj6198.github.io/tags/capistrano/"}]},{"title":"IT 鐵人幫完賽心得","slug":"webgl-it","date":"2017-02-28T15:44:42.000Z","updated":"2017-02-28T16:28:51.000Z","comments":true,"path":"2017/02/28/webgl-it/","link":"","permalink":"http://kjj6198.github.io/2017/02/28/webgl-it/","excerpt":"","text":"連結 今天是鐵人賽的最後一天，感覺自己最後結尾的部分收得不是很好，也有很多部分都因為時間上的關係沒有很完整地介紹完。 挑戰 30 天連續發文的確是一件非常不容易的事情，自己也更了解到如果還有類似的機會，一定要事先做好準備才行，才不會突發狀況發生時，急就章地寫完文章結尾。 同時，這次挑戰的主題是以前從來沒有碰過的 webGL 及 3D 圖學。原本以為前 10 天的學習能夠掌握基本的知識，不過實際上要了解 webGL shader 的應用跟撰寫、活用 three.js API 等等，都需要相對應的圖形理論做補助，這樣框架用起來才能得心應手。 不過 10 天的學習完全不夠用，光是要了解 GSGL 的撰寫就要不少時間了，更別說應用在實際的計算上。儘管已經有框架幫我們處理掉底層的操作，但如果需要更進階、或是更強大的活用，就必須更了解背後的操作。 aframe 的部分，我會再找時間陸續補齊（如果有時間的話QQ）。未來也希望自己能夠繼續往 3D 之路邁進，讓前端畫面的展現更加豐富。 這絕對需要時間的累積跟練習，也比以往的前端開發更有挑戰性，不過這 30 天的確學習到了很多過去完全不懂的知識。過去望之生畏的 shader ，現在也能夠寫、也能夠看懂；three.js 的 API 有基本的認知和了解；同時也看了一下 webVR 的發展跟認識 aframe 這個框架。 這 30 天可以堪稱最充實的一個月了（笑）。我知道本系列文章中仍然有許多不完整的部分，但希望各位讀者或多或少都能從中獲得一些知識！ 後記得到佳作。算是自己 2016 的總結吧！有太多事情沒有好好地記錄下來。 看到報名通知時其實掙扎蠻久的，因爲前端可想而知，今年寫 react redux 的人一定很多，既然如此，何不嘗試一下自己想碰很久，卻一直沒有碰過的 webGL？ 一直以來都對畫面上的互動很有興趣，但是對一位工程師來說，處理動畫之類的邏輯是很煩人又枯燥的事。這一個月雖然學習的東西跟網站開發天差地遠，甚至很少能夠應用在實際的開發當中（壓榨時程都不夠了，誰還在管特效？）。不過能夠學習這些知識，拓寬自己的視野，又何嘗不是件好事呢？ 越來越多公司對前端的要求，都是在數據視覺化上。以前被視為無聊、枯燥，在大數據的時代下開始被重視，對這個方向的要求就是 canvas 以及 webGL 的操作能力，不過現在也已經有很多框架幫你處理底層的 API 了。但身為前端，還是要有對底層的基本認識。不然總有一天抽象化滲透還是會找上門。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"webGL","slug":"webGL","permalink":"http://kjj6198.github.io/tags/webGL/"},{"name":"IT 鐵人幫","slug":"IT-鐵人幫","permalink":"http://kjj6198.github.io/tags/IT-鐵人幫/"}]},{"title":"伊坂幸太郎 - 摩登時代","slug":"morden-time","date":"2017-02-21T16:00:00.000Z","updated":"2017-03-01T06:03:20.000Z","comments":true,"path":"2017/02/22/morden-time/","link":"","permalink":"http://kjj6198.github.io/2017/02/22/morden-time/","excerpt":"","text":"《摩登時代》原本是喜劇天王卓別林最著名的一部默劇電影。並且被認為是美國史上最偉大的電影之一。 在討論社會學以及國家、個人、家庭之間的關係時，這部電影也常常會被拿出來討論。 雖然是用戲謔而滑稽的手法詮釋的電影，卻將殘忍的事實完整的描述出來。 從卓別林的眼中看見這個國家所隱含的殘酷現實，這就是我們所知的城市，儘管醜陋，卻是我們必須賴以維生的重要場所。這樣令人哭笑不得的劇情，是卓別林突出的功力。 摩登時代這本書是伊坂幸太郎在2010發表的長篇小說，配上花澤健吾的插畫，更富有戲謔感。 伊坂幸太郎將這個故事從頭說起，主軸仍然是在討論這個國家、組織的運作，卻更有戲劇性，雖然也有不少湊篇幅而出現的情節，不過這部小說是連載之後才出版成小說的。 這次連伊坂幸太郎都跳入這個故事中，「我的小說無法改變世界」、「小說啊！只能滲進讀者的體內，然後溶解」似乎隱約道出他的無奈。但不管如何，唯一能確定的是，他深厚的寫作功力以及架構，的確讓這篇故事相當精彩。 「你有沒有勇氣？」是讀完小說後，最深刻的印象之一，男主角平凡的要命，膽小怕死又背著老婆外遇，這樣一位平凡人，就跟螺絲釘一樣。 故事從一位系統工程師發現某個交友網站的程式內部隱藏著某種驚人的事實，愈是深入了解，愈發覺事情的不對勁，因為鍵入特定的關鍵字而受害，這位工程師開始深入調查，然後開始展開了一連串的故事。 書中寫到了許多小故事，也是伊坂的特有風格之一。 每本作品都會有個人物串場，而且不限於人而已，連湯瑪士小火車也曾出現在伊坂的筆中。不僅和劇情有呼應，也似乎在傳達著這個社會下所顯現出來的殘酷。 漢娜鄂蘭 「邪惡的平庸」，強調平庸才是邪惡的源頭。 事情拉回到二次世界大戰，猶太人被納粹黨大量屠殺的喋血事件。 當時的劊子手「艾西曼」被批評為惡魔。後來發現，他並不是懷抱著對猶太人的憎恨而屠殺，而是依照著上級命令行事罷了。 然後呢？他就不需要懷有內疚感或是責任感，一切都只是遵照指示，不需要受到良心的譴責。 每個人都只是機械性地完成工作，卻對整個工作流程一無所知。只是遵守著龐大的組織運作而已。然而這樣的思想並不只存在於當時。 這是巧合嗎？ 還是一種帶有歷史性、諷刺的無奈輪迴？漢娜鄂蘭、伊坂幸太郎所要表達的觀念竟然不約而同地出現在現代。 這是伊坂幸太郎的答案「如果因此做什麼都不會覺得不痛不癢的話，這個人就完了」。 在這個資本過剩的年代，生活雖然不容易，卻已經比之前好太多了。更何況年輕時的機會成本出乎意料地低，真的要讓賺錢、找工作這件事變成放棄思考的藉口嗎？就算真的努力工作，存到不錯的存款，又能夠這樣認定這就是正確的嗎？ 邏輯上的確說得通，畢竟別人怎麼活是他們的事，能夠做自己喜歡、有回報、擅長的的事當然是個大幸運，但大部分的人都只能擇其一，並且這樣活下去。 既然有實現夢想的人，那就有不得不放棄夢想的人在。 但是，拿自己的職業做比喻好了。我是一個前端工程師，工作就是從實現設計師所產出的 mockup，儘管頭銜好聽了一點，但本質上也跟擰螺絲的卓别林沒什麼不同。 任何重複性的工作，久了就會覺得枯燥，劇中的卓别林擰啊擰著，擰出病來，甚至把女生的胸部當作螺絲擰下去，結果被抓去監牢。 從早打晚埋頭敲鍵盤，不去思考需求、不去思考這樣做對不對、功能的必要性，那麼的確就跟擰螺絲的工人差不多。 「我只是按照上級指示行動。」這句話聽起來多令人心寒。很多人為了生活跟賺錢放棄思考。捨棄思考的我們、努力（而盲目？）工作的我們，真的只是完成工作就好了嗎？在這樣下去豈不是就像被操控的小丑一樣？ 在這個百花齊放的時代，更要不斷提醒自己，我是個活生生的人，有血肉之軀，被打會痛、開心會笑，而不是他人的工具，被動地為他人所用，而是應該要有自己的價值。 人是會習慣的動物工作久了會習慣、反覆練習而純熟。面對不熟悉的領域最原始的情緒就是恐懼跟害怕，如果因為這樣而不敢接觸世界的話，未來也一定會更膽怯的吧！ 總結想說的很多，但最完整能表現的大概是這一句吧！ 「比起支配人，我更想要幫助人」卓別林 -《大獨裁者》 至少在年輕的時候，做什麼事情機會成本都還小的可以時，趕快接觸世界。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"},{"name":"卓别林","slug":"卓别林","permalink":"http://kjj6198.github.io/tags/卓别林/"},{"name":"摩登時代","slug":"摩登時代","permalink":"http://kjj6198.github.io/tags/摩登時代/"}]},{"title":"高度相同的排版解決方案","slug":"responsive-flex","date":"2017-02-01T07:33:41.000Z","updated":"2017-03-01T03:04:54.000Z","comments":true,"path":"2017/02/01/responsive-flex/","link":"","permalink":"http://kjj6198.github.io/2017/02/01/responsive-flex/","excerpt":"","text":"在前端的頁面中，我們經常會碰到需要相同高度的排版。最直覺的方法就是將容器裡的所有元素設為 float 或是 inline-block。 float 及 inline-block如果是使用 float 排版，不但要先撐開父元素容器(clearfix)，還要針對子元素設定 margin。所以一旦內容太多，或是高度不足就會跑版。 而且，這樣的排版最大的缺陷就是，必須設定高度。 那，如果不設置高度呢？就算設定了 min-height 也一樣，當內容超出高度時，就必定會面臨 overflow 的危機。 後來決定直接用 css media query 在不同的螢幕寬度下分別給予不同的高度。雖然解法比較麻煩，也比較醜一點，但的確解決了寬度過窄時會跑版的問題。 這個問題後來一直深埋在心中，直到最近發現了 flex 的奧秘。 排版遇到困難，先想想 flex人生遇到挫折的時候，想想 flex，這個彈性盒子常常會救你一命。flex 已經支援大部分的主流瀏覽器，而且真的很好用！ 將 display 設置為 flex 的時候，如果子元素沒有設定高度，則子元素的高度會是其中最高的那個。 一行屬性就解決了我朝思暮想的問題，真是優雅的 flex。 但除此之外，我們還需要對排版做一些調整。 flex 預設如果沒有設置 flex-wrap 屬性的話，就會以單行顯示的方式來撐開父容器。因此我們可以再加上一行。 1.wrap &#123; flex-wrap: wrap; &#125; 好了，高度相同的 responsive 排版，不宣告 height 就此完成。大概的 css 會長得像這樣： 1234567891011.container &#123; display: flex; flex-wrap: wrap; justify-content: space-around;&#125;.card &#123; height: auto; width: 30%; border: 1px solid #aaa;&#125; 不支援 flex 的瀏覽器怎麼辦？首先 flex 已經支援大部分的主流瀏覽器了，不要用支援度這種藉口來忽視這麼好用的 flex。但如果瀏覽器真的不支援，可以用 js 的方式來做排版。主要的原理是不設定高度，偵測 container 裡面的所有元素，並且找出高度最高的，並將此高度套用到每個元素中。 寫了一個很基本的範例代碼： 12345678910111213141516171819var cards = document.querySelectorAll('.card');function getMaxinumHeight(elements) &#123; var nums = []; elements.forEach(function(value) &#123; nums.push(value.offsetHeight); &#125;); return nums.sort(function(a,b) &#123; return a &lt; b; &#125;)[0];&#125;var maxHeight = getMaxinumHeight(cards);cards.forEach(value =&gt; &#123; value.style.height = maxHeight + 'px';&#125;); Table is new sexy雖然古老的 table 排版已經被唾棄，不過像是等高這種場景，如果不幸無法使用 flex 時，可以利用 table 的特性來達成等高排版。 要完成 table 排版，可以使用 display: table, display:table-row, display: table-cell，來完成。 display: table 等同於 &lt;table&gt;；display: table-row 等同於 &lt;tr&gt;；display: table-cell 等同於 &lt;td&gt;。 See the Pen table-height by 愷開 (@kjj6198) on CodePen. 不過，雖然能夠達到等高的效果，但 HTML 的 markup 變得更複雜了。而且 table 在使用上仍然有一些限制，像是 margin 沒辦法在 table 裡頭生效等等，這些在實作 mockup 時都是很大的阻礙。所以，如果能夠用 flex 來做的話，就盡量使用 flex 吧！ 延伸閱讀Flexbox responsive equal height","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://kjj6198.github.io/tags/flex/"}]},{"title":"code-review-101","slug":"code-review-101","date":"2016-12-31T16:00:00.000Z","updated":"2017-02-28T16:19:16.000Z","comments":true,"path":"2017/01/01/code-review-101/","link":"","permalink":"http://kjj6198.github.io/2017/01/01/code-review-101/","excerpt":"","text":"前言身為前端工程師，通常在整個團隊裡面會是最常發送 pull request 的人。為了讓自己的 PR 更容易被測試，以及讓 reviewer 更容易的 review，總結了一些注意事項。 pull request 的描述 這個 pull request 的目的。例如：修正 layout、新增 feature、某個畫面的 style 等等 記住每個公司的成員都可以看見 pull request ，所以確保 pull request 的敘述提供夠完整的資訊。 明確地說明你想要怎樣的 feedback。 使用 prefix 來說明你的 pull request 狀態 將需要看這個 code 的成員加入進來（可以使用 github 的 assign 功能） 提供 feedback 如果你不同意 pull request 內的寫法，先停下來思考一下，為什麼你不同意。想清楚了再留下 comment 用詢問代替命令。「為什麼你不採用這樣的寫法呢？」優於「不要這樣寫！」，先問問看對方的想法或是意見，說不定他們不那樣寫是有理由的，這時候就可以做適當的溝通與交流。 解釋為什麼你覺得這些 code 需要被修改（不符合 style guide？不符合公司命名規範？沒有寫 test case？） 提供更好的方法來改善目前的 code 盡量避免具有攻擊性的評論。（ex:這樣寫很白痴。） 保持謙虛。 盡量避免斷定。（別這樣子寫 code！） 在線上溝通的時候，難免會有某些誤解產生。這個時候可以考慮面對面溝通。 用個 emoji 來加強你的語氣，例如：good job 👋 👍。 需要修正哦👻（這好像有點嘲諷？ 回應 feedback 感謝那些願意幫你 code review 的人。 對於任何不清楚的地方，發問就對了。 如果這個 feedback 有被實作或是在某個 commit 裡面，提供連結給他。 如果討論越來越複雜而且一直得不到結論，試著當面跟他溝通。 每個人 必須理解大家都有不同的 coding 風格，而且寫程式總會有許多解法跟選擇，所以在討論的時候應該適當做權衡，並且充分解釋為什麼你覺得這樣比較好。 用問的，不要用命令的。 不要劃分責任（這是你寫的不關我的事、這部分是你要處理的） 試著去理解一下作者的觀點和想法。 如果有一個 pull request 被 merge 了，記得留言並且感謝發送 pull request 的人。（optional） 結論雖然以上總結了那麼多點，不過我覺得圍繞的點還是在於是否為對方著想吧！身為一位 deployer，或是 code reviewer，你會希望看到怎樣的 pull request，從這個角度切入，或許會更有感觸也說不定。畢竟如果出錯了，甚至是因為自己的疏忽，把 code 部署到 production 上了，還要再浪費整個團隊的時間重新找 bug，再重新部署一次。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[]},{"title":"weekly-thought-5/30","slug":"weekly-thought-5-30","date":"2016-11-14T11:51:39.000Z","updated":"2016-11-14T11:51:39.000Z","comments":true,"path":"2016/11/14/weekly-thought-5-30/","link":"","permalink":"http://kjj6198.github.io/2016/11/14/weekly-thought-5-30/","excerpt":"","text":"這個禮拜不談「新」東西，多數會是關於網頁開發的重新思考。算是回過頭來漸漸補齊自己的技術債吧！比起前幾個禮拜所談的新東西，這一篇文章可能相對枯燥一點，當然篇幅也會比較長，但我認為這是必要的。 這些東西在前端變化快速的時代下或許顯得不那麼重要，不過思考總是件好事。 語義化標籤重新思考語義化這件事會有這個想法，是看到 instant article 的 html 架構，他們規範 instant article 的架構必須符合他們的規範，而且結構的表達也很清楚。我在裡頭看到了好多我以前沒有注意過的 html tag。像是 address figure caption summary 。好奇之下查了一下文件等等。發現其實有很多語義化的標籤都已經支持目前主流的瀏覽器，spec 也寫得很清楚，但是目前主站多還是以 div + class 的方式做表達，雖然有些地方會套用 header，但我認為有更多適合的語義化標籤可以加入使用。除了減少不必要的 class 命名，也能夠提高 html 的易讀性跟 SEO，重點是，我們寫的是符合標準的 html。 而且 w3c 在 html5 致力推廣語義化的標籤，諸如 nav header dd dt 等等，並且將一些沒有意義的 tag 刪除或是不推薦使用如 b font center 等等。 對於 class 的思考語義化 css 用了那麼久的 class，我回去找了找 spec，發現了 w3c 對 class 的描述。 There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content. -w3c 雖然 class 並沒有使用上的規定，但是鼓勵盡量將 class 用於表達元素內容而非描述元素的展現。也就是說那些 col-md-* 等表現性的 class 名稱其實在 w3c 的 spec 裡面是不符合規範的。但是會出現 unit class 的原因卻是因為我們沒有按照標準來而孵化出來的產物。雖然很多人擁護 unit class 的便利性跟節省開發的速度，但我認為比起開發上的時間節省，身為網頁開發人員，我們要注重的更應該是頁面的表達跟使用者的互動。 當然不得不承認的是，在理想上跟實際上總是會有差異。因為嚴格說起來，facebook 也沒有符合規範，他們是用css module的方式進行開發。 不過這裡想提出這樣子的想法跟大家討論。雖然標準的定案到瀏覽器的實作，總是要花不少時間。 為什麼要符合標準？ 標準規範是由一大堆科學家研究過後、大量的討論過後所制定出來的規範，給大家遵守以便達到統一性。 通常這些規範是 best practice。 為什麼我們要為了節省開發時間而寫出不符標準的網頁本末倒置？ 我們有更好的解決方案 &gt; SASStake id rethink我不會反對用挖掘機清理災難現場，但我不會拿來整理自己的家。給後代選擇器一個平反的機會，搭配 id 使用效果佳 123456789&lt;!-- 元素展現 --&gt;&lt;div class=\"margin-b-10\"&gt;&lt;/div&gt;&lt;!-- 內容 --&gt;&lt;div class=\"user_info\"&gt;&lt;/div&gt; 自己的理解是這樣。 至於為什麼會造成這樣的原因，或許是因為在網頁發展初期，CSS 的支持性並不好，在語義化跟表現之間很難得到平衡，才會有當時純 style 的 center width 出現。但現在已經不是那個綁手綁腳的年代了。我們應該朝向語義化的年代前進，而且這也是w3c在推廣的事情，身為一個站在網路業尖端的優質網路招聘公司，就由我們來引領風騷吧！ 對 unit class 難道沒有其他辦法解決嗎？我自己非常喜歡語義化的 class，而且很討厭 row col text-center，每次寫起來都會有罪惡感…。 至於用 unit class 的人，通常是因為不想花太多時間重寫 style 架構、節省開發時間、或是他根本不會 css，所以找個 bootstrap 直接套。但我們是前端工程師，我們有能力去組織 css。現在這個語義化年代，正是我們前端平反的好時機。 推行標準的目的是為技術交流構建一個統一的上下文語境平台，提高溝通效率，避免雞同鴨講。 同時標準跟規範的製定是經過一群資深開發者／科學家經過仔細研究及社區討論的，一套完整的一致的基礎架構系統是推進生態發展的必要條件。 就Web語義化這件事情而言，如果你的HTML是基於標準來編寫的，意味著你的頁面具備更多的可能性。比如搜索引擎友好，多終端適配(不是響應式。。是指兼容各種閱讀設備、讀屏軟件等。參見microformats )，更智能的風格查錯能力。 在前端開發體系裡，能體系專業性的地方不多。。拿程序複雜度而言，它跟大型後端系統差不止一個量級(前端的難度在於工程上)。。好不容易有一個能體現專業素養的領域(語義化Web)，為什麼我們不抓住機會為自己正名呢。。 我覺得這並不會增加維護成本，反而會在長期內減少冗餘樣式、不可預知的樣式覆蓋等維護問題。唯一的成本可能就是你在開始一個頁面之前，需要去抽像一下可複用的單元，然後用sass表達出來。不過我感覺如果你採用的是正確的工作流(面向語義)，這些事情都是比較順理成章的。 對於團隊開發如何確保面向語義，這確實是一個比較難解決的問題。除了需要提供一個清晰的團隊sass庫說明之外，貌似只能通過一些工程化手段解決了(加強code review流程、制定規範等等)。 grid system 是個很棒的東西耶！我承認 grid system 的確是個非常好用的模式，在實際場景也會遇到 layout 無法用語義化來表示的問題，但根據語義化的定義，為了寫出更好看的 HTML 跟易讀性，我們或許總有一天還是要把 grid system 拔掉。這會是個大工程，但在目前主站說大不大，說小不小的架構上，還是越早開始越好吧！ 使用 susy @include @extend Page Visibility API能夠知道目前 user 是否 focus 在這個 page 上。在很多情境下，我們希望當使用者沒有聚焦在這個網頁上（可能跳去別的應用程式、切換分頁時），可以盡量減少不必的請求或操作。facebook 好像也是當你回到網頁時才會有訊息的提示聲音。比較常見的情景是播放影片時，如果使用者跳出頁面，我們可以先自動讓影片停止，等使用者回來之後，影片在繼續播放。 回頭看看 js 的事件傳播最近把犀牛書拿回來翻了翻，主要是為了釐清以前不是那麼明白的觀念。太多 js library 充斥在網路，我們是否已經忘記原生的 js 了？雖然高度的抽象化是科技趨於發達後一定會有的現象，但是了解一下內部的運作也是好的，對於之後寫 code 也會比較有概念！ js 事件傳播js 的事件傳播主要分為兩大類型，bubble 跟 capture，大部分的傳播方式是用 bubble。什麼是 bubble 呢？在註冊對象元素的事件處理器被調用之後，事件就會開始往上漂浮（不包含某些元素的特定事件），然後再調用註冊於祖父元素上的處理器。這種現象會上升到 document 最後到達 window。 在實際應用上，我們時常看到：1234567891011$(\".abc\").on('click', e =&gt; &#123; &#125;);$(\".ass\").on('click', e =&gt; &#123; &#125;);$(\".asass\").on('click', e =&gt; &#123; &#125;); 散亂的事件註冊在角落，不僅維護上困難，在尋找 code 的時候也沒有統一入口，非常難以除錯。於是我們可以利用 js 事件的冒泡特性，為 document 統一註冊事件。jQuery 的 on 第二個函數便提供了事件委託的功能，如下： 123$('document').on('click','.sass', e =&gt; &#123; &#125;); 這樣的好處不僅減少了散亂的事件註冊，還統一了入口。如果要新增事件，只要在 document 統一做擴充即可。我們還可以在 html 這樣寫： 12&lt;a class=\"js_action\" data-action=\"foo\"&gt;&lt;a class=\"js_action\" data-action=\"bar\"&gt; 123456789 var actionList = &#123; foo: function(), bar: function()&#125;$('document').on('click','.js_action', e =&gt; &#123; if(typeof e.target.dataset.action === 'function')&#123; actionList[e.target.dataset.action] &#125;&#125;) 像這樣，以後如果要增加新的 event handlder 只要在 acionList 新增就好，甚至搭配 extend 的方式，可以不用寫在 actionList 也沒關係。充分提高了擴充性 那麼，為什麼那麼少人使用 capture 呢？最大的原因在於因為可愛的 IE 無法使用。再來事件捕捉只適用於 addEventListener 的方式。事件捕捉有點像是反過來，會先從祖父開始，依序向下船，直到事件父元素的事件處理被被調用為止，註冊於事件元素的事件處理器永遠不會被調用。 事件取消我們也常常看到類似 e.preventDefault() 的方法。其實像是舊版的瀏覽器並不支援，我們可以用一些比較 tricky 的方式來做取消。 1234567function cancelDefault(event) &#123; var event = event || window.event; if(event.preventDefault) event.preventDefault() if(event.returnValue) event.returnValue = false return false&#125;","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kjj6198.github.io/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://kjj6198.github.io/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://kjj6198.github.io/tags/html/"}]},{"title":"frontend collection - 5/23","slug":"frontend-weekly","date":"2016-11-14T11:45:21.000Z","updated":"2017-02-19T11:16:55.000Z","comments":true,"path":"2016/11/14/frontend-weekly/","link":"","permalink":"http://kjj6198.github.io/2016/11/14/frontend-weekly/","excerpt":"","text":"這禮拜發現的新東西這個禮拜在思考關於重構的東西，在前端還可以怎麼實踐。css 的部分已經有大致的雛形出來了，把相關的註解跟文件寫完之後再和大家分享心得。 Get your ../../ outreference css 部分重構完之後，再來就是要對 js 下手了。目前比較困擾的幾個點有： component 初期的部分比較亂 有些 flux、有些 redux 再來是我認為最麻煩的，就是路徑管理的問題了，因為檔案裡面有太多類似的 ../.. 出現，導致之後要對檔案做搬遷的時候還要全部重改一次，感覺非常的費工費時，也是讓人不敢輕易重構一大原因。 那時候第一個想法是，「不然我把全部的檔案存成一張路由表好了。」，不是 import 檔案本身，而是每次要 import 時，都到這個路由表去拿路徑，不但方便，而且每次對檔案做搬遷時，我只要維護好這張路由表就了。不過這個想法還沒有實作過，所以可能不是好方法也說不定…。 再來發現的第二個工具是modulesDirectories，主要是幫你把 root 定義好，每次呼叫 component 時都是以 root 當作起點而非檔案本身。 以 sudo 的檔案為例 1234567891011121314require('../ui/comment_reply.js');import h from '../utils/sudo_helper/dom.js';const actionList = &#123; reply: 'reply', edit: 'edit'&#125;;import jobsIndex from '../reducers/pages/JobsIndex.js';import App from '../containers/jobs_index.js';import configureStore from '../stores/JobSearchStore.js';var Checkbox = require('../components/checkbox');var Slider = require('../components/slider.js');var TextInput = require('../components/text_input.js'); 加入 modulesDirectories 之後，我們可以這樣寫： 123456require('ui/comment_reply.js');import h from 'utils/sudo_helper/dom.js'import jobIndex from 'reducers/pages/JobIndex';import App from 'containers/jobs_index';import configureStore from 'stores/JobSearchStore'; 這樣 component 搬遷的時候，不會因為相對路徑改變的關係，而還要全部重寫一次，重構的意願也相對提高了。 idiomatic-css最近一直在研究如何讓 css 的易讀性更高，並且更好做維護，目前如果搭配 webpack 的話，常見的方法有： css-module postCss radium 這些工具搭配 react 一起使用，其實可以很有效地解決 namespace 的問題。 不過主站目前想要先解決的是變數的統一命名，及 css 的規範。這部分規範好了之後，css 的管理相對也會變得簡單許多。 code smell in css這篇文章介紹了很多關於 css 的 smell code。幾個比較重要的大概念： 避免 magic number 盡量讓 class 是 immutable 利用權重的技巧，而不是過度使用 important selector 盡量簡單 順便來複習一下 selector 的語法吧！除了用 class 來當做 selector 之外還有很多其他實用的 selector 可以使用！像是 input 就是一個非常好使用 attribute selector 的例子： 12345678910111213.sudo-input &#123; input[type=\"text\"] &#123; // text style &#125; input[type=\"submit\"] &#123; // submit style &#125; input[type=\"number\"] &#123; // ... &#125;&#125; 這樣不僅語意清楚，也可以省下不必要的 class。","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kjj6198.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://kjj6198.github.io/tags/webpack/"}]},{"title":"css variable + sass variable = 😍","slug":"css-variable","date":"2016-11-14T11:44:20.000Z","updated":"2016-11-14T12:07:16.000Z","comments":true,"path":"2016/11/14/css-variable/","link":"","permalink":"http://kjj6198.github.io/2016/11/14/css-variable/","excerpt":"","text":"之前寫過了一篇關於自己對 css variable 的想法，原本對這個屬性沒有抱持著太大的期待，自己用習慣了 SASS 變數也覺得這個 css variable 反而像個彆腳的 system，不過如果你也是這樣想的人，可以參考這篇文章 Why should you care Css variables css 的變數已經出來有一段期間了，瀏覽器的支援程度還不算太糟。或許各位都曾經想過，這些變數的功能在 SASS 上幾乎都做得到，而且搭配 SASS 的 function 以及 SASS 的型別（list map）變數的使用彈性更為強大。 不過這邊想要跟大家分享的是，css variable 真正亮眼的地方在哪裡。 這篇文章會假設大家已經有一些 css variable 的基礎。 附帶一提，這篇文章沒有很全面性的寫出如何使用 CSS variable，所以有任何建議都歡迎提出來，之後也會找時間來重新寫一篇比較全面性的文章。 支援度 Browser Version Chrome 49 Firefox 42 Safari 9.1 custom property 只有在你讓他表現得像個 property 的時候，他才會比一般的預處理器強大 首先要澄清的一點是，在 CSS 的 spec 當中，variable 其實叫做 custom property。這是什麼意思？變數跟 property 搞得我好混亂！ 不要著急，意思就是在使用 css variable 的時候，我們應該把他們想成一般的 css 屬性使用，而非一般的變數而已。以下就會來介紹一些有關 css variable 的使用。 為什麼你要用 CSS Variable 你用這些屬性不需要一個預處理器。 可以用 initial inherit 的方式建立階層 瀏覽器會在需要的時候重新 render 你可以訪問並且用JavaScript操縱它們（等等會講到） property 特性既然是 css property 就一定會有以下幾個特性： 有所謂的 initial inherit 的值可以使用 呼叫的方式是 var(--variable-name) 能夠放在 inline-style 裡面 可以用 js 取值、設值 其中，最大的亮點在於 inline-style 跟能夠與 js 搭配取值與設值。這是跟原本 SASS, LESS 等 CSS 預處理器最大的不同之處，也讓 CSS 具備了新的可能性，就讓我們來看一些範例吧！ 12345678:root &#123; --mainColor: #abc; --subColor: #ccc;&#125;h1 &#123; color: var(--mainColor);&#125; 在這邊 :root 所宣告的元素會繼承到所有的元素當中，這就是 custom property 的特性。 inline-style因為是 property，所以當然可以像這樣寫。 123&lt;h1 style=\"color: var(--mainColor);\"&gt; Hello, world&lt;/h1&gt; 這看起來的確不怎麼稀奇，因為同樣的事情也可以用 class 跟 SCSS 變數的方式來達成，不過這讓我們在寫 inline style 的時候又多了一份可能性。 react inline style例如在 react 當中，我們可能會需要寫一些 inline style，但是顏色的制定因為跳脫了 SCSS 的控制，常常顯得很彆扭，要嘛就是直接打上顏色碼，之後要修改的時候再捲起袖子慢慢改；或者用 js 另外保存一份顏色的變數表；最好的方法可能是幫每一個顏色變數賦予一個 class。 現在有了 css variable 我們可以很方便的使用。 1234567891011const styles = &#123; heading: &#123; fontSize: '14px', color: 'var(--mainColor)', &#125;, warn: &#123; color: 'var(--warnColor)' &#125;&#125;;const heading = (&#123;title&#125;) =&gt; &lt;h1 style=&#123;styles.heading&#125;&gt;&#123;title&#125;&lt;/h1&gt; 本篇文章只聚焦在介紹 css variable，事實上也有其他優秀的 react style 管理方式 grid設定 gutter，我們現在可以用 css variable 的方式來做到，也就是說，我們可以用 @media query 的方式來幫變數設值，這是一般預處理器做不到的事情， js 的控制透過 javascript 的操作，我們可以很輕鬆的幫 css 變數設值或取值，來達到 view 跟 js 分離的效果。例如我們有一些效果想要透過 js 來取值，並傳給 css。一般來說，我們可能會透過 javascript 做計算之後，再把計算後的值，用 inline style 呈現。 但這樣子有可能發生一些情形： 這個值可能不是我想要的，或是我也想要自己對值做一些操作。這樣一來就要重新修改 javascript 的程式碼，非常麻煩。 因為是用 inline style 設值，所以 CSS 無能為力。 有了 css variable 之後，設值、取值非常的方便。 取值1HTMLElement.style.getPropertyValue('--mainColor'); 設值1HTMLElement.style.setProperty('--mainColor', '#abc'); 所以，我們當然也可以套用事件註冊器，讓有興趣的數值注入到我們的變數之中。 12345const element = // some HTMLElement;document.addEventListener('mousedown', e =&gt; &#123; element.style.setProperty('--pageX', e.pageX); element.style.setProperty('--pageY', e.pageY);&#125;); 支援度如果要看看當前的瀏覽器是否有支援 CSS variable 的話，可以用 CSS.supports 的語法來檢測。 CSS.supports(&#39;(--css: variables)&#39;) CSS.supports(&#39;not (--css: variables)&#39;) 之後的挑戰因為管理變數的方式越來越多了，也有可能在 javascript 對變數進行設值的動作，所以在控制這些變數時我們應該要更小心一點。 變數的宣告統一處理：全域變數統一放在一個檔案或資料夾當中，之後會比較方便處理，如果是宣告 css variable 也一樣。 如果變數是為了讓 js 設值，可以試著加上前綴當作標記，例如：--js-pageX 等等。 結論這篇文章介紹了 CSS variable 使用方式與場景，之前我也覺得 css variable 很彆扭，不但寫起來醜不拉機，而且也沒有相對應的函數操作。 不過一旦理解 CSS variable 就是 custom property 的概念的時候，就會發現一些 CSS 以往無法突破的可能性。我們沒有必要一定要對 SASS 或是 CSS variable 做取捨，我們甚至可以將兩者搭配使用，做出一些以往無法達到的強大效果。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kjj6198.github.io/tags/css/"}]},{"title":"用 Canvas 實作 low-poly art 心得","slug":"low-poly-art","date":"2016-11-01T03:40:41.000Z","updated":"2017-02-28T15:41:53.000Z","comments":true,"path":"2016/11/01/low-poly-art/","link":"","permalink":"http://kjj6198.github.io/2016/11/01/low-poly-art/","excerpt":"","text":"文章待補，圖片。 前言說到 low poly，最讓我驚豔的是 species in pieces 這個網站，他使用 low-poly 的方式畫出 30 種現在地球上瀕臨絕種的動物，是用 CSS 的 clip-path 做出來的，為了兼容瀏覽器，甚至還有做 fallback 的圖片，非常的用心。 之前有在知乎上有看見 low poly 的實作方式，但看了一下原始碼，回答是用 THREE.js 做的。一來我對 three 的掌握程度還太低，再來是 2D 的圖形用 WebGL 加速實在有點奢侈啊。這邊記錄一下思路跟實現過程。 其實要做到 low poly 的效果並不難，最直覺的方式就是在畫面上取點，然後把點連接成三角形。再把三角形著色就完成了。不過隨機取點的方式會造成圖片很大的失真。 有以下四大步驟： 轉為灰階 使用 sobel 做邊緣偵測 選擇 vertices 使用 Delaunay 三角化 幫三角形上色 圖片轉灰階有了 canvas 之後，我們可以使用 getImageData 這個 API 對圖片中的任何 pixel 做操作，這給 canvas 更大的彈性跟靈活度，代表圖片的操作有更多的可能性了。 而灰階的實現並不難，將圖片中的 r g b 相加取平均即可。示意的程式碼大概像這樣： 1234567var resultArr = [];for (var row = 0; row &lt; height; y++) &#123; var i = row * width * 4 + 4; for(var col = 1; col &lt; width; col++, i+=4) &#123; &#125;&#125; 其實在實際應用中，要取得邊緣的方式並不是那麼簡單，有可能會影響的因素有： 陰影 聚焦模糊 Sobel 取邊緣通常檢測邊界的算法原理在於，將此像素的資料與其他像素比較，如果比較起來發現差距很大（顏色），那麼即可判斷這一點是邊緣。取邊界的算法有很多種，一般最暴力也最直接的方法就是 Sobel。 這邊就不解釋 Sobel 的原理了，維基百科上面寫得蠻清楚的。$$Gx = \\begin{vmatrix} \\mathbf{-1} &amp; \\mathbf{0} &amp; \\mathbf{1} \\\\ \\mathbf{-2} &amp; \\mathbf{0} &amp; \\mathbf{2} \\\\ \\mathbf{-1} &amp; \\mathbf{0} &amp; \\mathbf{1} \\end{vmatrix} Gy = \\begin{vmatrix} \\mathbf{-1} &amp; \\mathbf{-2} &amp; \\mathbf{-1} \\\\ \\mathbf{0} &amp; \\mathbf{0} &amp; \\mathbf{0} \\\\ \\mathbf{1} &amp; \\mathbf{2} &amp; \\mathbf{1} \\end{vmatrix}$$將矩陣做乘法之後就可以得到梯度大小了。 取完邊界之後，重頭戲就是如何將它三角化了！ 取點如果是隨機取點，很快就會發現一些盲點，邊緣常常沒有辦法很完整的保存下來，因為取點的方式隨機，三角形就會破壞邊緣的形狀，所以這邊的思路是三角形盡量不要出現在邊緣上，而是用邊緣當做三角形的點，這樣才能將邊緣比較完整的保存下來。 但取邊緣的點也不能全部都取，不然這張圖就根本沒有任何藝術效果了，像這個樣子。 醜不拉機，而且裡頭還有很多過小的三角形造成瑣碎的效果，這顯然不是我們想的樣子。那麼，如果都用邊緣的點當作組成三角形的點呢？ 我們來看看效果，因為都是用邊緣取點，很容易造成三角形過於尖銳的效果，為了避免這樣的情形發生，我們必須有限制地取邊緣的點。所以，除了邊緣上的點會被選中之外，我們也加入一些邊緣外的點，避免銳角三角形的情況發生。 此外，為了更有效的避免銳角三角形發生，我們可以使用 Delaunay 三角化的算法更有效率的取點。這樣子的效果就更完美了，但顯然我的實作上還有一些小問題： 在一些細節當中，如何保存比較完整的圖片訊息 失真太大，有些圖片被三角化之後會完全走樣 結論關於圖學領域真的是一門很深奧的學問啊…，不但要有一定的數學基礎與背景，還需要跟 openCV 或是 webGL、canvas 打交道，而最重要的是創意。 光是圖形的轉換跟變化，就足以寫一本厚厚的教科書了，更何況是用程式語言實作。不過第一次接觸這個領域，挺好玩的。 這個演算法最重要的部分在於選取點的方式，如果更有技巧地取點，那麼三角化後的圖形失真會越少。許多論文跟網路上的實現都比我胡亂湊出來的算法屌多了。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://kjj6198.github.io/tags/canvas/"},{"name":"low poly","slug":"low-poly","permalink":"http://kjj6198.github.io/tags/low-poly/"}]},{"title":"人類也是 context switch 的動物 - 違反直覺的做事方式","slug":"context-switch","date":"2016-10-27T09:52:51.000Z","updated":"2017-02-28T14:58:32.000Z","comments":true,"path":"2016/10/27/context-switch/","link":"","permalink":"http://kjj6198.github.io/2016/10/27/context-switch/","excerpt":"","text":"今天看了這個影片，主要是想要指出其實在多工切換中，可以得到比較好的效率。 聽起來很 trick，對吧？其實剛看完影片我也不太相信，不過這似乎可以用作業系統的角度來解釋。 Context Switch如果學過作業系統，對這個名詞不陌生。當時的疑問是，既然轉換要成本，為什麼不直接一個 process 到底就好？ 這個乍聽起來很蠢，但其實 context switch 並不會讓 process 的完成時間變短，只是將平均等待時間縮短了而已。 不過，這是建立在轉換成本為零的情況下。 儘管如此，這部影片給我的震撼也還蠻大的，如果今天這個數量提升到了某種量級，那麼彼此的差距將會非常驚人。如果我沒看過這部影片，之後遇到類似的作業大概也是也會這樣做吧…？ 結論 如果 context switch 的成本不高，甚至幾乎不需要切換成本，那麼 context swtich 將會提高效率，他減少了每項作業的平均等待時間。但如果今天 switch 的成本高於 mass production 多出來步驟的成本，那麼結果就會反過來了。 之所以 mass production 會比較慢的原因，是因為他多出了拿起跟放下的動作，而這個動作是在 one piece 當中沒有多出來的。如果今天 mass production 不會多出多餘的步驟（目前是還想不到例子啦…），那麼彼此的差距就不會那麼大，或者幾乎相同也說不定。（如果 context switch 成本不高的話） 這兩點都很違反直覺，直覺來想，重複做某件事，大腦會習慣並且逐漸擅長；但是在影片當中，卻要逼你違反大腦的直覺，不斷的在四個步驟之間切換。","categories":[],"tags":[]},{"title":"【讀書心得】伊坂幸太郎 - 汽油生活","slug":"gasline","date":"2016-10-16T07:17:01.000Z","updated":"2017-02-19T11:26:08.000Z","comments":true,"path":"2016/10/16/gasline/","link":"","permalink":"http://kjj6198.github.io/2016/10/16/gasline/","excerpt":"","text":"前言自從實習生活開始之後已經很久沒有看小說了，不過仔細想想，如果把滑 FB 的時間拿來看書，應該可以偷到不少時間，於是假日心一狠，把之前很想看的小說全部搜刮起來…。但事實告訴我，這種衝動還是得小心啊！噴了 2200 多…，我得好好省吃儉用了。 汽油生活 🚗🚕🚙這次的作品是從一輛汽車的角度出發，這已經不是伊坂第一次嘗試了，《死神系列作》、《夜之國的庫帕》，都是以非人類的角度來作描寫，觀察人類。 這一次的主角是望月一家，有一次的旅程中望月一家載到一位大名鼎鼎的女藝人荒木翠，之後開啟一連串奇怪的事件中。汽車這次的作品中，由於故事中的敘事者都是以第一人稱出發，所以裡頭也有許多關於汽車的品牌跟故事，裡頭中出現的有關於汽車的心聲，也是讓人莞爾一笑的插曲之一。 新手駕駛反而是安全的，因為一旦開始鬆懈，就是危險的開始。這是我很喜歡伊坂幸太郎風格的原因之一，他很擅長把這些東西拿進作品裡當作比喻，不管是讓我們思考也好；或是劇情的走向也好，我看得挺過癮的。** 喇叭的存在目的 🎺喇叭似乎只是為了發洩憤怒而存在的。 那為什麼喇叭發出的聲音那麼低俗且刺耳呢？如果汽車出廠時可以對喇叭多用點心，想必也可以增加賣點吧！ 而且喇叭聲通常是爭端的來源之一，人類會對這種如突其來的噪音感到煩躁。試著想想喇叭製造的目的，應該是為了提醒行人、前方車輛：「唷，我在這裡哦！唷，前方已經綠燈了哦！」而存在的吧？ 雖然喇叭的音量可以由按下的力道調整，但是那種音量還是會嚇到別人，也有可能引起別人不滿。更不用說有時會在路上看見橫行的汽車，喇叭按著不放，似乎只是想用這種方式宣洩自己的不滿而已，根本沒有任何提醒的作用。 為什麼人類那麼喜歡這種原始而粗暴的方式呢？只因為這樣子很爽，發洩情緒的感覺讓自己產生優越感。備而不用是人類最愚蠢的地方。他們覺得也許會用到，所以就把什麼都保留下來。如果這樣一想，喇叭的聲音就應該被調整才對。 如果想要達到「提醒」的作用，應該不需要那麼尖銳的音量才對。 既然車子可以搭配喇叭，那麼行人也應該配戴喇叭，看到三寶開車或是貪污的政治人物，就應該到他面前吧吧兩下，表達自己微不足道的憤怒。 霸凌二人組關於霸凌這個觀點巧妙地和伊坂筆下出現的霸凌『野菜組』結合。亨因為跟一般的小孩不同，所以在學校時常常被『野菜組』霸凌。但他並不以為意，因為他知道這是人性下的醜陋，這群人只是因為無聊所以只好用這種方式來欺負別人。亨也習慣這樣的事情，「因為我不討人喜歡，所以大家都霸凌我」。當然伊坂幸太郎是不會讓這種人好過的，故事結尾也巧妙地讓亨返回一擊。（讓我感動的是，當圭一說他下定決心要站出來時，亨說的那句：「加油」） 只要有人跟一般人不同，就會有霸凌的存在，因為暴力讓人感覺很爽。 而且在學校時不用負太多責任不是嗎？有哪個學校會希望自己的學生霸凌？有哪個老師希望自己的班級霸凌？有哪個家長希望自己的小孩霸凌？ 所以當霸凌這件事發生，大家採取的動作不是遏止、而是隱瞞，所以他們更加為所欲為，因為不用負責任，而且還有那麼多人在幫你。 關於媒體媒體也常常出現在伊坂的筆下。之前才看過《64》、《虛線的惡意》，都是在說媒體、新聞業下的黑暗面。 但是，這次角度從另外一邊來看。因為這件事更有趣不是嗎？大家都想看，所以就會有人去寫這種報導。然後民眾又可以把罪過全部推給記者，好像自己完全沒有責任似的。那為什麼壹週刊一樣那麼暢銷、為什麼八卦點擊率還是那麼高，民眾對這種報導還不是一樣樂見其成。 所以到底是把媒體搞成這個樣子的？ 但是正如人類中有好人跟壞人，記者也有分好記者跟壞記者，這次是介紹好的記者。裡頭的阿玉因為對自己的報導害死了一位棒球選手感到愧疚，所以決定在這次車禍事件讓翠和丹羽遠走高飛，隱居他處。 故事的橋段還有一句，「咦？你怎麼變得那麼乖，這樣怎麼當記者？」當亨純真地問著這句話時不禁笑了出來。 「鏡頭具有抑制對方行為的力量」，所以在拍攝的時候都有種優越感，彷彿自己可以掌握全世界一樣。隱含在生活中的小道理我喜歡伊坂在敘事的過程中，將生活的小道理信手拈來，巧妙無痕地放入小說中的那種氣氛。就好像有人可以自私地害得整條高速公路都塞車一樣、就好像有人會把全世界的號誌燈都當作綠燈一樣。不管怎麼樣，還是有那些對道德無動於衷的人對吧？ 伊坂不會把這些道理赤裸裸地說清楚講明白，而是用巧妙的比喻帶過，卻又在故事結束後令人深思。 「就好像媽媽說吃青椒才可以吃甜點那樣嗎？」明明只是一個等價交換的道理，伊坂卻可以依照角色上面的不同，描述出不同的說法。想像這樣的話語從一般的小孩口中說出來，真的在適切不過了！ 尾聲（お終い）在小說進入尾聲階段時，亨曾經鼓勵圭一，希望他可以走出被霸凌的陰影，勇敢起身對抗。「那種影片不好玩，所以大家都不會在意的」，然後拿出法蘭克‧札帕的名言出來，說：「人類所嘗試的事情中，有百分之九十九都是失敗，所以失敗是正常的事情」。這句話可以說是老生常談，但是搭配劇情之後，竟然亂熱血一把的。伊坂小說的尾聲，總會讓人意想不到，包括安田太太的帽子、開頭良夫買的青蛙擺飾、殺人埋藏的屍體、牙醫事件、車子最後的下落，都做了一個完美的交代。這次的結局讓人看得十分過癮，還特別將那四台車的第一個字連接變成『お。し。ま。い』 伊坂的小說通常會用一個人物當作代表，引用他說過的名言來貫穿整個故事。 這次的主角是「法蘭克．札帕」是一位歌手，他的生涯我不是很清楚，上了維基百科查了一下，也沒有很明確的資料，所以我就不多做介紹，直接把連結貼給大家看看好了。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"【讀書心得】夜之國的庫帕","slug":"isaka-kupa","date":"2016-10-16T06:59:53.000Z","updated":"2016-10-16T06:59:53.000Z","comments":true,"path":"2016/10/16/isaka-kupa/","link":"","permalink":"http://kjj6198.github.io/2016/10/16/isaka-kupa/","excerpt":"","text":"為了不要讓這裡的技術成分太濃厚，我打算直接將之前整理的閱讀筆記也一併 PO 在這裡統一管理比較方便。 從 2013 年以來陸陸續續看了很多本書，也做了厚厚的筆記。趁著部落格還空空的，動力還在，決定把那些擱置已久的筆記一併搬出來曬曬太陽見見世面。 夜之國的庫帕前言「來個慵懶而即興的小革命吧！」這本小說很適合在午後咖啡店，一邊啜飲著咖啡，一邊聽著輕音樂，一邊享受著小說中可愛而有趣的視角和劇情。 有一種慵懶卻又身在其中的感覺，跟著貓的想法一起思考、行動，雖然好像事不關己，但是到後面竟然連自己都開始緊張了起來，「拜託！劇情一定要這樣才對！」，還好，愛好和平的伊坂少年讓結局看起來如此的溫馨。不過，我還是好捨不得就這樣把小說給看完了嗚嗚嗚。 這本小說的筆調是很輕鬆的，但是在這種輕鬆的氛圍中，卻把人類社會中的現實和殘酷丟出來，拋出一個完美的質問。你會在故事的結尾中思考，對呀！我們不也是這樣？ 故事裡，獨眼兵長給了讀者答案：「懷疑。」 故事的內容是在描寫夜之國的人民被鐵國擊敗後，剛開始先假裝和平停戰，卻在一夕之間發生國王被殺（冠人）的事件，搞得整個夜之國人心惶惶、不知所措。 每個登場的角色都有一個小小故事，而這些小小故事結合起來，卻又和主軸互相連結，不會顯得太過凸出，伊坂揉合了不同支線的故事發展，最後將事實完整交代出來。這必須有非常深厚的寫作功力還有架構才有辦法做到。 安穩＝和平？夜之國的人民們深深相信著自己是處於一種和鐵國對立、領土相當的狀態下。他們並沒有產生懷疑，也沒有人想要求證。反正，只要日子過得安穩，就沒有這個必要管那麼多的事情吧！ 人民們依賴城牆內的安穩，卻沒有人願意思考、懷疑現狀的可能性。甚至他們放棄了探究真相，因為只要冠人說出包裝後的故事，他們就會無條件地全盤相信。不需要動腦筋、不需要奔波勞碌就有安穩的生活，何必大費周章確認事實呢？ 庫帕的傳說我好喜歡這個傳說。 「比起公佈真相，維持威嚴更加重要」那麼，要如何維持自己的威嚴呢？冠人的方法是，在外部安排一個又恐怖又強大的敵人（就算是假的也沒關係），然後再對人民說：「別怕，我會保護你們。」並且拿出實際作為（每年派出庫帕士兵）。這樣包裝下來，人民就自然而然地會將領導人視為英雄。冠人確保地位的方式是：欺騙、隱瞞、扭曲這個世界的價值觀 「什麼是對的，什麼事錯的，自己去判斷吧！」獨眼兵長丟出了結論。 「對任何意見都要有同等的懷疑，不然一定會吃虧。」 無知「無知」是一種恐懼，人們會因為不知道而害怕。所以如果領導者將事情處理好了，人民就無所憂慮，無所憂慮後，人民就會感到幸福，感到幸福之後，人民就會依賴領導者了。冠人成功創造了這樣的優勢，所以儘管獨眼兵長將事實說出，他們仍然是半信半疑。 「會不會我們所深信不疑的，都有改變的可能呢？」 貓吃老鼠貓吃老鼠就是天經地義嗎？誰規定的？來自上古的命令告訴多姆，「貓就是要吃老鼠」。但，為什麼呢？ 有人思考過這個問題嗎？故事中有蠻多篇幅是在描寫貓與老鼠間的對立關係及談判。 比自己弱小的東西，誰也不會放在心上。「只要心血來潮，我們就捉弄老鼠」，但弱者就一定要被欺負嗎？貓似乎都沒有想過，直到老鼠長老冒出來要求談判後，多姆才開始思考這個問題。 「我們獵捕老鼠，所以老鼠是低等的」，這是正確的看法嗎？同樣的觀點挪用到人類身上，弱者就應該順應天命的安排嗎？ 「出了門就該好好回家，不都是這樣嗎？」「既然你都能跟貓交談，跟老婆交談也是輕而易舉吧！」如果不改變彼此的關係，就永遠是兩條平行線。光是這樣，就可以有很大的改變了。 後記大約是在兩年多前寫的文章，現在看起來格外稚嫩。不過很慶幸自己當時真的記錄下來了，寫一篇文章真的很累，大概要花一小時構思、兩小時寫文章。 看完心得之後，又能馬上回味當時看小說時的情景，劇情也馬上映入眼簾，感覺真棒。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"},{"name":"推理","slug":"推理","permalink":"http://kjj6198.github.io/tags/推理/"}]},{"title":"smooth animation - （下）easing 的使用","slug":"scroll-animation-2","date":"2016-10-13T09:06:19.000Z","updated":"2016-10-19T06:20:45.000Z","comments":true,"path":"2016/10/13/scroll-animation-2/","link":"","permalink":"http://kjj6198.github.io/2016/10/13/scroll-animation-2/","excerpt":"","text":"但是，為什麼感覺動畫那麼不自然呢？ 有沒有發現，時間與距離是完全呈現線性變化的，這代表我們假設這個物體在所有的時間點，速度都是相同的。真實生活中通常不會有這樣的事情發生，物體一定都是從靜止狀態逐漸加速，再從移動的狀態中逐漸停止。而上一篇的範例當中，動畫是突然開始，突然停止。在現實生活中，物體的移動速度並非成線性變化，這是造成我們動畫看起來不自然的主要原因。 知道了原理之後，就可以馬上來實作了： 計算距離 重新計算每一次的位移 = 距離 * 比例係數（easing） 把我們原本的 function 改寫成這樣： 1234567891011121314151617181920function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) let currentTime = 0; function move() &#123; currentTime += 1 / 60; var p = currentTime / t; var d = Math.cos(Math.PI * pos) - 1); // 利用 cos 函數，重新計算移動的位置。 if (p &lt; 1) &#123; scrollTo(0, scrollY + (targetY - scrollY) * d); requestAnimationFrame(move); // 採用 requestAnimationFrame &#125; else &#123; scrollTo(0, targetY); alert('done'); &#125; &#125; move();&#125; 這邊我們加上了一個簡單的 cos 函數，重新計算位移的位置，達到 easing 的效果。詳細 easing 效果，可以到 easing.js 看看，這裡蒐藏了很多 ease 效果。 小結原本以為篇幅很長，不過基本的動畫原理的確只有這樣而已，加上了 easing 之後，動畫的效果看起來自然很多，當然，你也可以依照自己的經驗調整參數，達到更完美的使用者體驗。 不過，如果可以，盡量不要綁架使用者預設的滾動效果，一來可能會造成效能的問題，二來你綁定的滾動效果如果沒有依照使用者預期反應的話，很容易造成非常差的體驗。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"smooth scoll","slug":"smooth-scoll","permalink":"http://kjj6198.github.io/tags/smooth-scoll/"},{"name":"animation","slug":"animation","permalink":"http://kjj6198.github.io/tags/animation/"},{"name":"easing","slug":"easing","permalink":"http://kjj6198.github.io/tags/easing/"}]},{"title":"smooth scroll","slug":"scroll-animation","date":"2016-10-12T09:06:19.000Z","updated":"2016-10-19T06:21:04.000Z","comments":true,"path":"2016/10/12/scroll-animation/","link":"","permalink":"http://kjj6198.github.io/2016/10/12/scroll-animation/","excerpt":"","text":"在 window 物件當中，提供了 scrollTo(x, y) 的方法，我們可以透過 scrollTo 來操作滾動。但， scrollTo 方法是直接讓滾動軸移到指定的位置，並沒有動畫的效果，如果要藉由動畫的幫助達到良好的使用者體驗，我們必須自己設計。 基本動畫知識在開始之前先來讓我們了解一下動畫的基礎吧！ 動畫最基本的要素有這些： 時間 = 距離（位移）/ 速度 位移 = 速度 * 時間 速度 = 距離 / 時間 有了這些基礎知識就可以來製作簡單的動畫效果了。 第一次嘗試我們要做的事是要讓 scroll 能夠用動畫的方式滑到自己想要的地方。所以，在本例當中，scrollTo(x, y) 將會是我們的位移。速度的話，我們先暫定是 200ms 吧！ 123456/* */function moveScrollY(targetY, speed) &#123; const speed = 200; const scrollY = window.scrollY || window.pageYOffset; scrollTo(0, scrollY + (targetY - scrollY) * t);&#125; 咦？這個 t 是 undefined 吧？ 在定義 t(time) 之前，我們先來思考 t 應該要是什麼。根據剛剛的公式，時間 = 距離 / 速度，所以在本例當中，t 為 targetY - scrollY / speed。這樣寫的話如果 scrollY 大於 targetY 的話時間就會為負了，所以這邊我們要取絕對值。 1234567891011121314/* */function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.abs((targetY - scrollY) / speed); let currentTime = 0; function move() &#123; currentTime += 1 / 60; p = currentTime / t; scrollTo(0, scrollY + (targetY - scrollY) * p); setTimeout(move, 1000/60); &#125; move();&#125; 到目前為止，我們的 scroll 動畫雛形已經出來，不過存在一些問題： 距離太遠的時候，動畫的時間顯得有點長 這個動畫不會停 現在我們來改善一下 scroll 的動畫。 距離太遠顯然如果距離太遠時，動畫完成的時間會變得更長，所以我們需要限制一下 t 的範圍。 1234function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) 以下&#125; 這樣子好多了，在距離太遠時，動畫不會顯得太慢。 動畫不會停在程式碼當中，因為沒有設定停止條件，所以會無止盡的延續下去。芝諾悖論 怎樣才算是完成了呢？這邊的終止條件是目前的時間（禎數）等於 t 的時候，就算終止了。 123456789101112131415161718function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) 以下 let currentTime = 0; function move() &#123; currentTime += 1 / 60; p = currentTime / t; if (p &lt; 1) &#123; scrollTo(0, scrollY + (targetY - scrollY) * p); requestAnimationFrame(move); // 採用 requestAnimationFrame &#125; else &#123; scrollTo(0, targetY); alert('done'); &#125; &#125; move();&#125; 這邊我們將 setTimeout 取代成 requestAnimationFrame，requestAnimation 跟 setTimeout 的差別在於使用 requestAnimationFrame 時，瀏覽器會幫我們做最佳化，在不必要的時候不會進行重繪，達到節省資源的效果。 目前主流瀏覽器都已經支援了（主流當然不包含 IE8 囉！） 但是，為什麼感覺動畫那麼不自然呢？ 有沒有發現，時間與距離是完全呈現線性變化的，這代表我們假設這個物體在所有的時間點，速度都是相同的。真實生活中通常不會有這樣的事情發生，物體一定都是從靜止狀態逐漸加速，再從移動的狀態中逐漸停止。而上一篇的範例當中，動畫是突然開始，突然停止。在現實生活中，物體的移動速度並非成線性變化，這是造成我們動畫看起來不自然的主要原因。 知道了原理之後，就可以馬上來實作了： 計算距離 重新計算每一次的位移 = 距離 * 比例係數（easing） 把我們原本的 function 改寫成這樣： 1234567891011121314151617181920function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) let currentTime = 0; function move() &#123; currentTime += 1 / 60; var p = currentTime / t; var d = Math.cos(Math.PI * pos) - 1); // 利用 cos 函數，重新計算移動的位置。 if (p &lt; 1) &#123; scrollTo(0, scrollY + (targetY - scrollY) * d); requestAnimationFrame(move); // 採用 requestAnimationFrame &#125; else &#123; scrollTo(0, targetY); alert('done'); &#125; &#125; move();&#125; 這邊我們加上了一個簡單的 cos 函數，重新計算位移的位置，達到 easing 的效果。詳細 easing 效果，可以到 easing.js 看看，這裡蒐藏了很多 ease 效果。 結論這邊很簡略地用 scroll 的 API 當作範例，介紹了動畫的基礎。當然還動畫的原理跟使用，又是另外一門深奧的學問了。 到目前爲止，我們的 scroll 動畫就算完成了，但因為位移是線性移動，看起來比較不自然一點，下一篇文章，再來介紹 ease 的概念，讓我們 scroller 變得更 smooth。 原本以為篇幅很長，不過基本的動畫原理的確只有這樣而已，加上了 easing 之後，動畫的效果看起來自然很多，當然，你也可以依照自己的經驗調整參數，達到更完美的使用者體驗。 不過，如果可以，盡量不要綁架使用者預設的滾動效果，一來可能會造成效能的問題，二來你綁定的滾動效果如果沒有依照使用者預期反應的話，很容易造成非常差的體驗。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"scroll","slug":"scroll","permalink":"http://kjj6198.github.io/tags/scroll/"}]},{"title":"從 legacy code 中尋找出口（中）- HTML 篇","slug":"legacy-code3","date":"2016-09-17T02:40:16.000Z","updated":"2016-10-18T11:32:18.000Z","comments":true,"path":"2016/09/17/legacy-code3/","link":"","permalink":"http://kjj6198.github.io/2016/09/17/legacy-code3/","excerpt":"","text":"講完 CSS 的重構技巧之後，接下來會專注在 HTML 的重構技巧上。本系列的文章將不會談論 js 的重構部分，因為牽扯到較多的程式撰寫技巧，而且網路上類似的文章應該是不勝枚舉。 前言其實 HTML 能夠重構的點並不多，主要就是標籤的正確使用以及顧慮 accessibility 等小細節。 所以這篇文章會著重在如何使用正確的標籤以及語義化；基本的 accessiblity 認識跟 aria 標籤的使用，不僅對 screen reader 較友善，語義化的標籤使用也能夠在之後修改 HTML 時更有效率；最後是模板語言的技巧應用，這邊會用 rails 的 views 為例，不過概念的部分應該是相通的。 語義化首先，我們先來看看 HTML5 新增的 tag 有哪些 section 用來表示網頁裡的一個段落，常見的誤解是用來表示一篇文章。 基本上跟 div 沒有太大的差別，只有語義化的表現。 article 用來表示一篇文章 datalistdl dt dd 如果資訊是以條列式來呈現，可以使用 dt, dd 來區分。 Definition lists, created using the DL element, generally consist of a series of term\\/definition pairs (although definition lists may have other applications). Thus, when advertising a product, one might use a definition list: 123456789101112&lt;dl class=\"information\"&gt; &lt;dt&gt;薪水：&lt;/dt&gt; &lt;dd&gt;100000 ~ 300000&lt;dd&gt; &lt;dt&gt;工作地點：&lt;/dt&gt; &lt;dd&gt;台北市&lt;/dd&gt;&lt;/dl&gt; 任何以成對方式呈現的資訊都可以使用 dt, dd 包裝，像是範例中的：薪水搭配 100000 ~ 300000、工作地點搭配台北市。不過要注意的一點是 dl 預設會將內容縮排（就跟 ul, ol 一樣）。可以將 padding 設置為 0 來解決。 figure figcaption 使用在和主內容相關的圖片、代碼，或其他資訊，不一定只能放圖而已 搭配 figcaption 來定義標題 legend 搭配 fieldset 使用，用來表示輸入表單的內容 預設的邊框很醜，如果要使用這樣的結構可能要重置一下 CSS See the Pen fieldset by 愷開 (@kjj6198) on CodePen. 族繁不及備載，tag 的部分就在此告一段落。我個人覺得有一大部分是因為不知道才沒有使用這些 tag 的，詳情可以到w3c 的網站看看。之後會再將其他 tag 的使用方式補上。 如果都沒辦法滿足怎麼辦？如果以上的 tag 都沒有辦法滿足你的需求，最常見的做法就是用純 div。而 HTML 為了因應這樣的需求，也提出的 ARIA 的 spec，讓開發者可以更容易製作客製化的元件。如果我們想要使用 div 來模擬按鈕的行為，除了在 class 加上 btn 之外，我們同時可以加上 role attribute，並且使用相對應的 aria-* 標籤來做對應的狀態處理（是否按下、disabled、haspopup 等等），除了更加語義化之外，這些看起來有點麻煩的細節，都會大幅地改善使用 screen reader 的體驗。 但是，盡量不要取代原本語義化的標籤的含義，例如將 button 標籤加入 role=&quot;modal&quot; 之後當作 modal 使用。 Web developers must not use the ARIA role and aria-* attributes in a manner that conflicts with the semantics described in the Document conformance requirements for use of ARIA attributes in HTMLtable. Web developers should not set the ARIA role and aria-* attributes to values that match the default implicit ARIA semantics defined in the table. - w3c spec 當然，雖然 spec 這麼說，但某些 tag 像是 input + label 的 hack 對前端開發來講真的很方便。這部分或許就看大家的取捨了。 12&lt;div class=\"btn\" role=\"button\" aria-disabled=\"false\"&gt;Click to Signup&lt;/div&gt; Accessibilityaccessibility 其實可以另外再寫一篇文章來討論，但因為不再本篇的討論範圍內，這邊只列幾點關於 accessibility 的注意要點。 文字的大小 顏色的對比 是否加入適當的 attr。（img 的 alt, link 的 title 等） 適當的 aria-* 使用 如果對 accessility 有興趣，建議大家看看： ARIA w3c 的 aria 標準。 WebAIM checklist WCAG 的 checklist WebAIM inviblecontent 關於 CSS invisible content 的介紹 模板語言（已 rails views 為例）目前市面上有很多模板引擎，像是 ejs erb handlebar jade 等等，都有一套特定的語法、partial、客製化的函數等等幫助你簡化冗長的 HTML。 就 rails views 來說 12345678&lt;%= render 'partial/buttons/primary', locals: &#123; :name =&gt; 'foo' :title =&gt; 'bar'&#125; %&gt; 將常用的元件拆成 partial，並且放在對應的資料夾（我的習慣是將所有 partial 檔統一資料夾管理，除非那個 partial 只有在某一個特定頁面使用）。這樣一來就可以很容易地引入已經撰寫好的 HTML 架構。 123456&lt;%= render 'partial/modal', locals: &#123; :name =&gt; 'foo', :title =&gt; 'bar', :image =&gt; image_path('a.png')&#125; %&gt; 結論HTML 的重構比起 CSS 跟 JS，算是簡單許多（只要 css 撰寫的時候不用 tag 做 styling），不過從頭看下來，要顧慮的事情也不少。正確的使用 tag 以及顧慮 accessibility，能夠有效地增加 UX，同時自己在修改的時候也不會看到一大堆 div 看到心癢癢。 Legacy Code 專欄 從 legacy code 中尋找出口（上） 如何從 legacy code 中尋找出口（中）- CSS 篇","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"重構","slug":"重構","permalink":"http://kjj6198.github.io/tags/重構/"},{"name":"HTML","slug":"HTML","permalink":"http://kjj6198.github.io/tags/HTML/"},{"name":"aria","slug":"aria","permalink":"http://kjj6198.github.io/tags/aria/"}]},{"title":"令人期待的 PostCSS","slug":"go-to-postcss-or-not","date":"2016-09-16T15:58:02.000Z","updated":"2017-02-28T15:04:08.000Z","comments":true,"path":"2016/09/16/go-to-postcss-or-not/","link":"","permalink":"http://kjj6198.github.io/2016/09/16/go-to-postcss-or-not/","excerpt":"","text":"從 SASS 到 PostCSS大約在一年前，PostCSS 開始竄紅在前端生態圈裡，不外乎就是所謂的 preprocessor 的特性、高度客製化自己的 plugin、搶先使用 cssnext 的功能，還能夠搭配各種建構工具（gulp, webpack），用起來非常輕鬆寫意。 變數雖然剛開始看到 PostCSS 的時候還挺興奮的，但隨即思考了一下：「真的有必要馬上把 SASS 取代掉嗎？」。 PostCSS 的優點在於你能夠選擇你想要的 plugin，需要時再使用就好。舉變數的功能為例好了，postcss-simple-vars 能夠模擬 SASS 的變數宣告及使用行為。對我來說怎麼看都彆扭，因為 SASS 除了變數本身宣告之外，還有 map, list 的型別，而且具備了相當完整的 API 操作。例如：取值、判斷式、迴圈功能等。 1234567891011$colors: ( main: #abc, sub: #bac, word: #333);.container &#123; background-color: map-get($colors, $main); color: map-get($colors, word);&#125; 就算使用 css spec 的 var 也是一樣，沒有 map 或 list 取值的功能。 12345678910:root &#123; --wordColor: #333; --bgColor: #fafafa;&#125;body &#123; background-color: var(--wordColor); color: var(--bgColor);&#125; （o.s：而且這樣子寫其實有點醜很醜） 或者，SASS 的 @function 也能夠進一步將 map-get做包裝 12345678910111213141516171819202122232425262728293031323334353637383940414243444546$colors: ( main: #abc, sub: #bac, word: #333);/* alias method for getting color from $colors map/// @param &#123;$key&#125; the key you want to choose////// eg: color: c($word); */@function c($key) &#123; @if map-has-key($colors, $key) &#123; @return map-get($colors, $key); &#125; @else &#123; @error \"Unknown key #&#123;$key&#125;\"; &#125;&#125;.container &#123; background-color: map-get($colors, $main); color: map-get($colors, word);&#125; 因為 PostCSS 生態圈廣泛的原因，不少獨立開發者的插件很可能因為沒有在維護，或是因為疏忽而導致編譯錯誤有小 bug 等等的問題，相對之下 SASS 本身具有的功能相對完整的多。 mixins 跟 function相對應的 plugin 有 postcss-mixins 跟 postcss-functions 雖然模擬的 mixin 的行為，但如果要搭配判斷式使用的話，又要花一番功夫。 123456789101112131415161718192021222324@mixin state($state,$namespace: '') &#123; @if ($namespace != '')&#123; .#&#123;$namespace&#125;-#&#123;$state&#125; &#123; text-transform: uppercase; &#125; &#125; @else &#123; .$&#123;state&#125; &#123; text-transform: uppercase; &#125; &#125;&#125; 而 function 的部分也一樣，如果使用純 CSS 搭配 PostCSS 撰寫，沒有辦法使用 SASS 原生的 function。雖然能夠用 js 自定義 function，這一點其實還蠻吸引人的，但如果要模擬 SASS 相對應 function 的話，又要在重造一次輪子，不免顯得有些麻煩。 相較於 SASS 還不成熟相對於 SASS 來說，PostCSS 其實還算蠻新的工具，雖然生態圈很廣泛，插件也多，但目前版本仍在快速變動中，也還有很多 issue 沒有解完，SASS 因為本身是使用 Ruby 撰寫，雖然速度會比 PostCSS 慢一些（好吧，應該是很多），但其穩定跟完善的 API 跟型別、語法，都是 PostCSS 還無法達到的程度。 PostCSS 的優勢來說說 PostCSS 的優勢吧！目前我最喜歡搭配使用的功能有 autoprefixer cssnano。 autoprefixer 能夠幫你處理 CSS 麻煩的前綴，以往是使用 mixins 來解決，現在完全交給 PostCSS 處理就可以了，相對起來乾淨簡潔多了；cssnano 則是幫你處理 CSS minify，搭配 gulp 使用你可以只要安裝 gulp-postcss gulp-cssnano gulp-postcss gulp-sass 就可以進行 css 編譯跟最小化的動作了。 除了上述的插件之外，我認為很棒的插件還有 postcss-sorting：根據定義的規則排序你的 css properties precss：包含許多 sass-like 的功能 stylelint：lint 你的 CSS stylefmt：根據 stylelint 的規則幫你 format css code doiuse：幫你偵測目前 CSS 的瀏覽器支援度 livereload：搭配 webpack 的淫威之下，css-loader 本身就幫你設定好了 hot reload 的配置，只要一改動 style 檔案，就可以在不用重新載入的情況下將新的 style 套入。 為什麼我不敢離開 SASS搭配 PostCSS 的確非常方便，但我不認為兩者同時套用能夠減少日常開發，畢竟一旦出錯，就得花時間去研究底下的運行機制。有可能 PostCSS 編譯完之後再給 SASS 編譯會報錯；又或者某個套件的 bug 導致檔案沒有完整編譯，某段的 CSS 代碼沒有生效等等，都是潛在的問題，目前的開發我也只有使用 autoprefixer cssnano stylelint 來幫助簡化、檢查 CSS 而已。 結論或許最後 SASS 會完全被 PostCSS 打敗也說不定，但 SASS 本身完整、成熟的架構跟語法，還是讓我不想要輕易完全使用 PostCSS 的最大主因，哪天等 PostCSS 成熟到能夠完全獨立於 SASS 的時候，我可能就會轉移過去了吧！就像當初在學 CSS 的時候，也是猶豫了很久才開始學習 SASS 那樣。不過，這兩者（sass, postCSS）是可以共存、互補的。 既然享受了 PostCSS 高度彈性化的優點，我們接下來也不得不關心抽象化滲透，因為插件有可能因為時代的變遷，或是開發者不在維護的關係而出現錯誤。這些插件分別看來功能微小，但是全部加起來之後能夠省下的時間也是很巨大的。；而 SASS 完整的語法、變數系統雖然需要花一段時間學習，卻能夠用統一的語法大幅提升 CSS 維護度。 在這個組件化盛行的年代，前端工程的開發逐漸傾向於維護模組化的檔案（react, css-modules 等），最後可能不需要那麼多繁雜的操作（此指 sass 的 function、變數等），而是回歸到最原始的純 css 也說不定。 reference PostCSS I’m excited about Postcss, but I’m scared to leaving SASS Breaking up with scss cssnext","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"sass","slug":"sass","permalink":"http://kjj6198.github.io/tags/sass/"},{"name":"postcss","slug":"postcss","permalink":"http://kjj6198.github.io/tags/postcss/"}]},{"title":"weekly-thought-7/31","slug":"weekly-thought-7-31","date":"2016-07-31T06:45:18.000Z","updated":"2016-11-14T11:51:06.000Z","comments":true,"path":"2016/07/31/weekly-thought-7-31/","link":"","permalink":"http://kjj6198.github.io/2016/07/31/weekly-thought-7-31/","excerpt":"","text":"發現的新東西瀏覽器的字體渲染前陣子發現了 font-smoothing 的屬性，雖然 w3c 已經把他從標準刪除，但在 chrome 上面還是可以使用這個屬性。 但令人好奇的是，其他瀏覽器的字體渲染方式呢？ 其實字型渲染是一個一直以來容易被忽略，卻又是極為重要的議題。因為網站的易讀性除了 layout 之外，再來就是字體了。 為了確認網站在瀏覽器的一致性，稍微研究了一下字體渲染的方式。分享在這邊給大家做參考。 每個字，在電腦當中都會被當作一個向量圖像。而當我們把字體渲染在螢幕上的時候，就會把字型用像素渲染的方式呈現在螢幕上，所以每個字其實都是由一個個小方塊組合起來的。 但問題發生了，用小方塊的壞處就是在邊緣會出現無可避免的鋸齒狀，造成閱讀體驗不佳。 基本解法 grayscale這個解法是讓邊緣的像素補上一些灰階的像素，讓字型遠遠看起來比較圓滑，用這些灰階的像素來補償字體本來應該有的面積。這個方法很聰明又優雅，讓人不禁佩服。 進階解法 subpixel顏色信息，如果我們把屏幕截圖不斷放大，可以看到字體邊緣有紅藍兩色出現，這就是亞像素渲染了。 在LCD屏中，一個像素是由紅綠藍三個緊密排列的亞像素構成的，它們決定了這一像素的顏色和亮度。由於它們是如此之小，以至於肉眼不會把它們看作是一個個獨立的色點。如果我們仔細看看上圖中被白點標記的「紅色」像素，就可以發現它所採用的渲染策略：所有的亞像素都可以單獨控制開或關的；若「空白」像素最右側的亞像素是紅色的話，則此像素都將填滿紅色。 問題點：百家爭鳴的瀏覽器每個瀏覽器實作字型渲染的方式都不盡相同，甚至不同的 OS 下也是。更蛋疼的是，在Windows下還可能採用兩種技術來渲染—— GDI或者DirectWrite。 Windows在Windows系統下，字體格式對其渲染效果有很顯著的影響，比如PostScript字體和TrueType字體之間就存在著巨大的差別。但這種差別並不是由瀏覽器所引起的，只要底層的字體一樣，我們就可以看到完全相同的渲染效果。 儘管這種方法並不十分可靠，但從字體的命名中我們可以大致推斷該字體所採用的渲染技術，比如，EOT和.ttf格式一定是TrueType技術，反之.otf通常是PostScript技術。但是還有一中封裝的字體格式WOFF，它可以包含其中任意一種字體格式。因此光看文件名 ​​是不可能清楚它所採用的渲染技術的。除了EOT​​和.ttf格式文件可以斷定是TrueType渲染技術外，其他文件格式所包含的是哪種字體都無法確定。因此在你購買字體時，你最好對想要購買的字體做一番了解。（@Ryekee :我覺得這一句根本不用翻譯，中國還有人會買字體麼？） TrueType和PostScript的區別在於描繪曲線時所採用的數學方法不同，但這一差異對柵格器並不會造成太大的影響，只有字型設計人員才需要考慮著兩者的差別。另一個重要的區別就是所採用的字體微調的方法。PostScript只包含了組成字體的各種元素的抽象位置信息，而TrueType則包含了非常詳細的底層命令，直接接管了渲染的進程。然而造成兩種渲染技術的差異並不是它們的設計理念上的差別，而是源於Micro$oft採對TrueType採用了新的渲染引擎。 操作系统OS提供了支持不同的字体渲染方法的API。在windows下是GDI(Graphics Device Interface)和DirectWrite，OS X下是Quartz。 GDI分为GDI Grayscale和GDI ClearType。前者为灰阶渲染API，后者是亚像素渲染API。由于GDI ClearType并未对字体进行垂直方向的平滑，因此当字体较大时会出现边缘不平滑的情况。为了弥补GDI ClearType的不足，MS实现了DirectWrite API，它在GDI ClearType的基础上增加了垂直方向的平滑。但是！字体渲染的API都是由浏览器厂商自己选择的！ 使用同一颜色，感官上的颜色深浅为：黑白渲染&gt;grayscale&gt;sub-pixel。 Chrome35/36采用的是GDI ClearType，因此在字体较大时边缘会出现毛刺，而FF30采用的DirectWrite则没有此类问题。如下图所示： 不過最近看了一下 windows 的字型渲染，不得不說微軟在這方面還真是下了不少功夫。 越來越多的字體設計師都開始注意到Web字體所帶來的技術問題，尤其是TrueType字體的微調。隨著Web字體產業的崛起，他們願意付出精力為屏幕顯示而優化字體。在不遠的將來，我們將看到大量精心設計的字體問世（或者至少是對現有字體的更新）。 隨著屏幕分辨率的增加（以及對柵格器的重大改進），我們慢慢地不再擔心字體渲染的技術細節。採用GDI渲染模式的瀏覽器必將拖後腿，正因為此，未來數年內，我們都還無法放心的使用無微調的TrueType字體。只有當這一類瀏覽器用戶比例降到足夠低的程度的時候，TrueType字體微調（耗時又需要高超的技巧）才可以被扔到一邊。儘管目前市面上幾乎所有Web字體都是TrueType格式的，我仍希望字體行業能夠大規模轉向PostScript格式，因為這種字體能為設計師減少絕大部分的工作。 不過好處是，科技日新月異。希望之後不用再擔心字型渲染的東西。 MAC 使用他們自己的引擎來渲染字體，不管 truetype 跟 posttype 渲染方式都一樣。這個渲染引擎只有一個字，屌。 truetype 跟 posttype 的差別。 結論如果想直接看結果，在網頁的時候，可以使用反鋸齒的技術來增加易讀性。但如果在手機上建議關閉，因為反鋸齒的演算需要比較多的 GPU 來做計算。通常直接採用灰階的渲染方式就夠用了！ 事件控制如果可以，希望在每個檔案都能夠新增一個 EventManager 的方式，統一管理事件。我很喜歡事件委託的方式。 善用 data attribute 的方式來給標籤一些好用的屬性。 microdataRails view最近希望把一些常用的 tag 跟撰寫方式拆成 helper，於是開始去研究 rails 裡面的 view helper method。發現裡面的 helper 撰寫大有學問，這邊跟大家分享： 1234567891011def link_to(name = nil, options = nil, html_options = nil, &amp;block) html_options, options, name = options, name, block if block_given? options ||= &#123;&#125; html_options = convert_options_to_data_attributes(options, html_options) url = url_for(options) html_options['href'] ||= url content_tag(:a, name || url, html_options, &amp;block)end 這邊用 link_to 方法舉例，可以看到這邊分成了兩種方式，如果有給定 block 的話，會將傳入的參數作轉換，如果沒有的話，則是將 option 做處理之後，傳給 content_tag 這個方法。注意到這邊的 block_given? 方法，有這個方法我們就可以很容易的判斷是否有傳入 block。 所以在設計 helper 的時候，可以適時包裝這些方法，簡化 helper 的複雜度： 12345678910def link_to_with_noopener(name = nil, options = &#123;&#125;, html_options = nil, &amp;block) html_options.merge!(&#123; :ref =&gt; \"noopener\" &#125;)if block_given? link_to(name, options, html_options, &amp;block)else link_to(name, options, html_options)endend 請參考：About rel=noopener 再來就是 viewhelper 裡面有很多還蠻好用的方法，我們不用再花很大的功夫重造輪子，像是： link_to_if link_to_unless link_to_unless_current 不過每次只要一動到 helper 就很容易出包…，但直接用原生的 HTML 不但很醜，又不好維護，所以在撰寫 helper 的時候，為了保險還是寫一下 test 吧！ 最近的有個想法是將常用的片段程式碼拆成 partial，並且用比較統一的方式管理！，每次接到新的頁面就要先思考哪些會是局部代碼，哪些會是共用代碼。 partial 設計的幾個要點：經過這次標籤消失的事件，首先先跟顆顆說聲道歉之外，更應該檢討的是以下幾點： 預設值很重要！ if else 判斷式要思考更全面 如果害怕沒有預設狀況，就乾脆讓他噴例外 第三點的實作方法如下： 123456789101112131415161718# in component_helper.rb# ui_component 方法是對 render 的進一步包裝。def ui_component(url, props = &#123;&#125;) render \"components/#&#123;url&#125;\", locals: propsend# in error_helper.rbdef check_required_options!(locals, *options) options.each do |option| raise MissingOptionError, %Q&#123;option \"#&#123;option.to_s&#125;\" is required.&#125; if locals[option].nil? end end private class MissingOptionError &lt; StandardError end 然後在 partial 的程式碼裡面： 12// in _tags.html.erb&lt;% check_required_options locals, :propA, :propsB, :propsC %&gt; 這樣如果 locals 裡面的 option 不夠完整，就會在使用的時候噴出例外，不知道這樣的設計夠不夠完整。而且 partial 設計的時候很容易因為時間久的關係，忘記了 locals 裡面的選項，在 partial 裡面養成檢查 locals 的習慣，可以幫助我們補上遺落的 option。不知道這樣的設計夠不夠恰當跟完整？還請顆顆提出意見。 component 化這邊的 component 化並不是指全部使用 react 改寫，畢竟我們的頁面也還沒有到這種需求。但是既然 rails 有強大的 partial 機制跟 view heleper 方法，我們可以在撰寫的時候做更進一步的拆分： 1234567891011121314151617&lt;div id=\"page_id\"&gt; &lt;header&gt; &lt;%= load_component(\"company_header\") %&gt; &lt;/header&gt; &lt;main&gt; &lt;aside&gt; &lt;%= load_component(\"company_sidebar__header\") %&gt; &lt;%= load_component(\"company_sidebar__content\") %&gt; &lt;/aside&gt; &lt;%= load_component(\"company_summary\") %&gt; &lt;%= load_component(\"company_introduction\") %&gt; &lt;%= load_component(\"company_section\") %&gt; &lt;/main&gt; &lt;footer&gt; &lt;%= load_component(\"company_footer\") %&gt; &lt;/footer&gt;&lt;/div&gt; 但其實目前主站的頁面都仍時常變動，所以過早的抽象化反而會浪費更多成本吧！不過未來如果能用這樣的方式來撰寫程式碼，相信應該是非常好維護的！ Webstrom其實以前也是那種很瞧不起 IDE 的那一派，開起來要花我好幾秒，重點是又吃記憶體，然後又要常常使用滑鼠操作…。但使用 IDE 來幫助我們 debug、重構是一件非常省力又輕鬆的事情，只要右鍵 =&gt; refacter 即可。 所以如果是一般的功能開發，如果牽扯到比較多檔案的 CSS 或是 JS 檔案的話，我會使用 Webstorm 來開發，搭配 react 跟 jsx 的 plugin，不用每次都會忘記 action 的名字在不同檔案跳來跳去，或是突然忘記長長的 API 又跑去找文件，要整理 code 也只要按下 refactor 就好，出錯的機率自然會降低、也節省了不必要的時間。 但如果是剛入門的人還是建議從文字編輯器開始，門檻比較低。不然設定 IDE 的時間，都可以吃好幾碗肉骨茶麵了。 CSS @supports這個屬性","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/tags/前端/"}]},{"title":"weekly thought-7/17","slug":"weekly-thought-7-17","date":"2016-07-17T01:48:34.000Z","updated":"2016-11-14T11:54:51.000Z","comments":true,"path":"2016/07/17/weekly-thought-7-17/","link":"","permalink":"http://kjj6198.github.io/2016/07/17/weekly-thought-7-17/","excerpt":"","text":"發現的新東西別跟我說你懂 margin拿捏 margin 跟 padding 可以很容易地看出前端工程師對 CSS 的掌握程度。說真的超多眉眉角角的，不過看完文章發現原來 margin 的妙用這麼多。以後的實踐或許有比較容易的方法也說不定！ MutationObserver這個鮮為人知的 API，被喜歡翻 MSDN 的我挖掘到了，基本上已經支持目前主流的瀏覽器（IE11+)。 看完介紹會發現他很像事件，專門給 DOM 的變化使用的，不過不同的是，一般的事件是同步的，而 MutationObserver 是非同步的。 這可以幫助我們在 DOM 有變化的時候，做出相對應的反應。 利用這個特性，我們可以達到以下幾個應用： lazy loading initialize 因為在 HTML 實際被 render 之前，DOM 就已經先下載下來了，所以我們可以在 rendering 之前就改變 DOM 的內容。 123456789101112var observer = new MutationObserver ( function ( mutations )&#123; for ( var i = 0 ; i &lt; mutations . length ; i ++)&#123; for ( var j = 0 ; j &lt; mutations [ i ]. addedNodes . length ; j ++ )&#123; lazyLoad ( mutations [ i ]. addedNodes [ j ]); &#125; &#125; &#125;);observer . observe ( document . documentElement , &#123; childList : true , subtree : true &#125;); astrum這是一個很炫砲的 style guide library。做得非常精緻。最近像這些 styleguide 的 library 一直推陳出新，其實就像潘大所說的。寫文件是好的，但是一定要評估成本、其他人的熟悉成本、要建構的時間等等，不能只是因為又潮又炫就自己跳下去自幹。而是要讓寫文件這件事情逐漸被引入。 不過當作 side project 或是自己想玩玩看就另當別論了。 新的問題每個框架都是為了解決某個問題而出現的。但使用了某個框架之後，好像逐漸又會萌生新的問題。我把一些自己在開發上常會碰到的問題整理了一下： 文件切換 我覺得很麻煩的一點就是要一直在 component 之間跳來跳去，有時候還要切過去看看 action, reducer 之類的，久了很容易阻礙思考。 Webpack 打包過慢 要 bundle 的檔案越來越多，webpack 逐漸變得沒有那麼快了。每次寫完 code 還要等他 bundle，而且每次更新都會 reload 一次，說真的還挺麻煩的。 SudoDashboard其實只是想練習 dashboard 的 UI 跟 Websocket 的實作。不過感覺做起來還蠻實用的，最近空閒的時候應該會開始組織一下。還請潘大多多擔任設計指導。","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"sudo週刊","slug":"sudo週刊","permalink":"http://kjj6198.github.io/tags/sudo週刊/"}]},{"title":"如何從 legacy code 中尋找出口（中）- CSS 篇","slug":"legacy-code2","date":"2016-06-14T04:01:52.000Z","updated":"2016-10-18T11:32:00.000Z","comments":true,"path":"2016/06/14/legacy-code2/","link":"","permalink":"http://kjj6198.github.io/2016/06/14/legacy-code2/","excerpt":"","text":"前言我們的第一步是先從 CSS 下手，因為 css 是相對於其他前端部分來說比較容易重構的部分。很容易髒亂的 code 也是 CSS。 上一篇描述了在大型專案中引入新框架及技術的困難點，這一篇主要會專注在如何透過現有的工具及框架來重構現有的代碼。 本次的重構技巧會以 SCSS 為主，所以在閱讀本文之前，我先假設你已經有基本的 SCSS 以及 CSS 的基礎。其他預處理器的概念應該是相通的。 引入 style linter 及 editorconfig我們採取的第一步是先引入審查代碼工具。目前比較流行的 css linter 是 stylelinter，他能夠針對 scss sass 語法做 lint。也可以搭配其他 IDE、文字編輯器 plugin。這邊的範例是使用 sublime，其他的 IDE 應該也有類似的功能。 1. 加入 stylelintstylelint 除了可以針對 scss 語法做 lint 之外。由於其本身是用 js 撰寫的，可以客製化自己的 rule 跟加入其他開源的 plugin。 因為 stylelint 是以 AST 的方式解析，所以可以很容易的對文件中的節點做操作。 關於 stylelint 的深入使用，已經超過本文篇幅，有興趣的人可以參考 css trick 的教學 首先，先來安裝 stylelint，run npm install -g stylelint。 再來設置 .stylelintrc 檔，詳細的 rules 可以到這裡 查看。如果你不想要那麼麻煩自己手動一個一個設定的話。可以考慮使用 stylelint-config-standard 這個插件，再根據自己的需求做調整。 npm install --save-dev stylelint-config-standard 這邊還是建議花時間瞭解一下專案的需求來制定 rule，不然有時候太嚴格的 rule，滿江紅看到也懶得改了。 2. 加入 .editorconfigEditorConfig 是一個為了統一代碼風格的解決方案。每個人文字編輯器的環境可能不盡相同，為了統一彼此之間的環境，這邊我們採用的 editorconfig 設定非常簡單，只要新增一個檔案就好。editorconfig。 目前幾乎主流的文字編輯器都有支援 editorconfig。 常見的 code smell 以及 refactor 方式在開始捲起袖子做事之前，還是先來確認一下目前的專案是否需要 refactor： 許多元件（如 button input）等放在同一個檔案內，查找非常不易。 覆寫了許多 class 造成預期之外的行為發生 早期沒有統一的代碼規範，tab、空白夾雜在一起，閱讀性大幅降低 !important 四散各處 變數的命名跟管理不夠統一 團隊開始擴增 相關的文件不足 接下來介紹一些比較常見的 code smell Orderclass 變多之後，如果 rule 裡面沒有一定的排列順序的話，其實查找很不方便。而且易讀性並不高，像是下列的 code 123456789101112131415161718.class &#123; position: absolute; display: none; padding: 30px; cursor: pointer; list-style: none; font-size: 20px; background: white; margin:0; top:0; left:0; width: 250px; padding-left: 15px; overflow-y: scroll; overflow-x: hidden; border: 1px solid $hr-gray; z-index: 9999999;&#125; 那麼要怎樣排序會比較好呢？這邊提供幾個大原則： display、position box-model font、typography layout(包含 color、border-radius 等) 其他屬性(如animation) 原因：對一個 class 來說，最重要的就是 display 與 position ，所以應該擺在最上面。而其次重要的內容是文字，所以擺第二，最後才是 layout 與其他屬性。至於屬於同屬性的話不限制順序，例如 padding margin 順序調換沒有關係，因為找起來都很方便。只要維持一定的邏輯即可。 123456789101112131415161718192021222324.class &#123; display: none; position: absolute; top:0; left:0; z-index: 9999999; width: 250px; padding: 30px; padding-left: 15px; margin:0; font-size: 20px; background: white; border: 1px solid #aaa; list-style: none; cursor: pointer; overflow-y: scroll; overflow-x: hidden; &#125; 善用 sass map 管理變數style 檔案變多了之後，相對的要管理的變數也會變得越來越多。除了在命名時加上前綴之外，我們也可以利用 sass map 的方式來統一管理。而且 sass map 提供了一些很方便的 function 來操作，像是 map-get map-has-key等等，可以很有效地把變數 group 起來。很像 js 的 object。 以 z-index 來說，我們可以改寫下面的 code 123456789101112131415161718192021/* before */$zindex-navbar: 100;$zindex-dropdown: 200;$zindex-tooltip: 300;$zindex-modal: 400;.navbar &#123; z-index: $zindex-navbar;&#125;/* after */$zindex: ( navbar: 100, dropdown: 200, tooltip: 300, modal: 400);.navbar &#123; z-index: map-get($zindex, 'navbar');&#125; 用 map 的方式取值，看起來好像比較厚工一點，我們可以用 sass 的 function 包裝起來： 1234567891011121314/** * z alias for z-index * get zindex map value */@function z($key) &#123; @if(map-has-key($zindex, $key))&#123; @return map-get($zindex, $key); &#125; @else &#123; @error \"unknown key #&#123;$key&#125;\"; &#125;&#125;.navbar &#123; z-index: z($zindex, 'navbar');&#125; 當然還有其他的應用像是 color typography 等等，都可以搭配 sass map 的方式來操作。 如果你認為上述的方式跟用前綴的方式分類變數沒有什麼不同的話，不套用也沒關係，重構是為了讓之後的開發更舒服。 大量的巢狀 class我的建議是不要超過三層，第一是易讀性非常低，再來很容易覆蓋到權重。可以採用一些目前比較熱門的 css 命名規範如 OOCSS 或是 BEM，或者搭配兩者一起使用。 但最重要的一點是自己寫起來的感覺，不要讓規範箝制你了。 如果想要使用 scss 的巢狀功能方便閱讀，又不想要讓巢狀 class 覆蓋權重的話，可以使用 @at-root，@at-root 在編譯的時候會幫你把巢狀拆出來到 root。 另外可以使用 &gt; 子元素選擇器來取代後代選擇器。 1234567891011121314.classA &#123; @at-root .classB &#123; // bla &#125;&#125;// compiled.classA &#123; &#125; .classB &#123; // bla &#125; 實際的 use case 如下： 12345678910111213.alert-modal &#123; @at-root &amp;__header &#123; &#125; @at-root &amp;__body &#123; &#125; @at-root &amp;__footer &#123; &#125;&#125; 以上的代碼好像沒有想像中的好看，等下可以搭配 mixin 把它進一步做簡化。 善用 Mixin 簡化程式除了一般使用 mixin 來加入 prefixer 之外，mixin 能夠做的事情還有很多，這邊提出幾個方法給大家參考。 BEM mixinBEM 的命名方式，如果一直手動 key 的話，感覺也挺麻煩的，而且 key 錯的機率也蠻高的，我們可以利用 mixin 來簡化他。 順便一提，如果你的專案已經套用了 postCSS，可以使用 postcss-bem 來幫助命名。 如果你不喜歡他的命名方式，或是當前還無法套用 postCSS 的話也沒關係，我們可以自己做一個。 上面的 code 可以改成下面的形式： 123456789101112131415161718192021222324252627282930313233343536373839@mixin block($block_name) &#123; .#&#123;$block_name&#125; &#123; @content; &#125;&#125;@mixin element($element_name) &#123; @at-root &amp;__#&#123;$element_name&#125; &#123; @content; &#125;&#125;@mixin modifier($modifier_name) &#123; @at-root &amp;-#&#123;$modifier_name&#125; &#123; @content; &#125; &#125;@mixin state($state_name) &#123; &amp;.is-$&#123;#state_name&#125; &#123;@content;&#125;&#125;// modal.scss// before.alert-modal &#123; @at-root &amp;__header &#123; &#125; @at-root &amp;__body &#123; &#125; @at-root &amp;__footer &#123; &#125;&#125;// after@include block(\"alert-modal\") &#123; @include element(\"header\") &#123;&#125; @include element(\"body\") &#123;&#125; @include element(\"footer\") &#123;&#125;&#125; 這樣一來簡單的 BEM mixins 就製作完成了。注意到這邊我們使用 at-root 的方式來避免巢狀 class。 可以按照自己的喜好來調整命名方式，或者嚴謹一點對參數做一些處理（轉為小寫等等）、加入判斷式等等，或者今天你想要使用巢狀 class 的話可以加入額外的判斷參數。 123456789@mixin element($element_name, $at-root: true) &#123; @if($at-root) &#123; @at-root &amp;__#&#123;$element_name&#125; &#123; @content; &#125; &#125; @else &#123; &amp;__#&#123;$element_name&#125; &#123; @content; &#125; &#125; &#125; util mixin舉例來說，在設置 padding margin 的時候，我們常常會將上下或是左右的值設為一樣。寫久了難免會嫌麻煩，這時候就可以拜託 mixin 了。 123456789101112131415161718// before.classA &#123; margin-right: 10px; margin-left: 10px;&#125;// after/* * lr Alias for left right */@mixin lr($box_model, $value) &#123; #&#123;$box_model&#125;-left: $value; #&#123;$box_model&#125;-right: $value;&#125;;.classA &#123; @include lr(\"margin\", 10px);&#125; 這邊沒有寫得很嚴謹，你可以另外加入判斷式來保證輸入的值是合法的，類似的概念也能套用到 top left 設值上。 或是常常遇到的 clearfix。 1234567891011@mixin clearfix() &#123; &amp;:before, &amp;:after &#123; display: table; content: \"\"; clear: both; &#125;&#125;.column &#123; @include clearfix;&#125; child selector mixin常常會遇到使用 child selector 的情境。我們可以用 mixin 進一步包裝起來。 1234567891011121314151617// before.list &#123; &amp;:first-child &#123; //bla &#125; &amp;:nth-child(2n) &#123; //bla &#125;&#125;// after @mixin first() &#123; &amp;:first-child &#123; @content; &#125;&#125;.list &#123; @include first() &#123;&#125;;&#125; 這邊推薦 Family.scss，搜集了許多好用 child selector mixin。 p.s：我認為剛入門 CSS 的人還是從純 CSS 開始學習比較好，以免被 SCSS 的語法糖給寵壞了 善用 Comment在缺乏 function 的 css 下，使用 comment 來解釋 class 更為重要。這邊提供一些，comment 的技巧。 註解不但方便自己閱讀，之後別人接手也會比較快理解這個 class 該如何使用、在哪個場景使用。 目錄如果文件包含的 class 較多，可以考慮在文件最前面加入目錄，方便之後查找。 123456789/** * INPUT * text * select * number * BUTTON * primary * warn */ 魔術數字、HACK、使用方式12345678910111213/* * for input[type=\"text\"] * e.g: &lt;input type=\"text\" /&gt; */ .text-input[type=\"text\"] &#123; padding: 20px; /* page offset */ top: 27px; /* IE 8+ hack */ // ...&#125; CSS 結構基本上分成幾個大方向：module base config helper modulemodule 資料夾裡存放所有模組化的元件，像是 button input modal 等等。如果元件拆得更細的話，可以再另外開資料夾，像是 button 有可能樣式比較多，這時候我們可以另外開一個 button 資料夾，裡頭存放所有 button 的樣式。 basebase 裡頭放置了像是 grid normalize reset typography 等比較基本的架構。 config存放變數跟 color 的地方，設定的內容統一存放在這個資料夾統一管理。 helper存放客製化的 function 跟 mixin。 寫在最後如果你有額外的時間，建議你還是可以去看看像是 postCSS、css-modules、webpack 等優秀的開源工具。不然整天跟 CSS 打架總有一天會精神耗弱的XD。 做了一個DEMO，非常陽春。 如果你也想分享自己在前端跟 legacy code 奮鬥的過程，或是有更好的解決方案，歡迎在下面留言。 持續關注前端趨勢這裡分享幾個覺得蠻優質的資源。 掘金網 碼天狗（但最近前端的分享不多） TechBrige CSS wizard referenceCSS guideline Why Stylelint CSS coding techniques why you should refactor your css rsscss.io Legacy Code 專欄 從 legacy code 中尋找出口（上） 從 legacy code 中尋找出口（中）- HTML 篇","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"重構","slug":"重構","permalink":"http://kjj6198.github.io/tags/重構/"},{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/tags/前端/"}]},{"title":"從 legacy code 中尋找出口（上）","slug":"legacy-code","date":"2016-06-11T00:56:15.000Z","updated":"2016-10-18T11:31:38.000Z","comments":true,"path":"2016/06/11/legacy-code/","link":"","permalink":"http://kjj6198.github.io/2016/06/11/legacy-code/","excerpt":"","text":"在我第一次進入主產品開發後，把代碼從 Github 上面 pull 下來。 「這是什麼鬼東西？」 結構混亂，大量覆寫的 class 各處都是，以及很可怕的巢狀 ID。view 的部分也有些地方非常雜亂……。看來 legacy code 跟 refactor 永遠都在進行式。 對於日新月異的前端來說，要接觸一個新技術、框架並不是太困難的事。但困難點在於如何在現有的大型專案中做取捨，我們常常會有其他考量。例如團隊的接受度、team leader、其他政治因素等等而無法輕易地將新框架套用在目前的專案上。 這個系列的文章主要會分享如何在既有的專案中小心地進行重構。希望對各位有些幫助。 目前遇到的問題HTML 的架構混亂肥大，許多 util class 四散各處，在 CSS 中更可以看到大量的覆寫 class。雖然聽說之前已經有整理過了，但顯然這個房間還充滿許多灰塵。 我認為前端常常遇到的 smell 問題有： 復用性不足：儘管已經採用 React，但仍有許多高耦合的 component。而且其中還夾雜著 flux 與 redux 兩種不同的 library 大量混雜業務邏輯的代碼（如 API ability 的判斷等），不僅要實際去了解業務流程外，還要知道檔案放在哪，必要時可能還要去看後端的程式碼 HTML 的撰寫不夠語義化，充斥太多 util class 及 atomic class，後面接手的人比較難搞懂這行 view 裡頭所要表達的東西。 CSS 檔案的撰寫不夠模組化。有太多混雜的模組都放在同一隻檔案中，查找非常不方便。 大量的覆寫 class 造成上版時有很多意外的狀況發生。 沒有統一的規範跟撰寫方式，很快代碼就會往指數性的肥大邁進。 身為一個前端工程師，經驗還稍嫌不足的我來說，雖然目前正在孤軍奮戰中，但其實還能做一些事。有問題對我來說是一件非常值得興奮的事，至少對我來說，那是一個可以捲起袖子來做事的大好機會。 解法那麼，到底該怎麼做呢？我認為可以從以下幾點開始下手 著手撰寫 styleguide，讓自己與之後的前端團隊快速上手，並且有一定的準則可以遵守 技術選型：自動化工具、code quality 工具、選擇與淘汰 test 框架：前端代碼大部分都還沒寫 test，未來等架構穩定的時候希望可以趕快補上。 讓重構變得簡單 讓 comment 及 doc 變成習慣： comment 的 doc 永遠是工程師的好朋友！ 提交代碼的規範 本系列的文章主要會著重在重構的部分，最後一篇會再跟大家分享文件應該寫些什麼，以及前端如何提交代碼及發送 pull request 給 code reviewer。 目前已經大致撰寫了 styguide 的架構，下一步是逐漸重整 CSS 的架構以及拆分 HTML 組件。 這不是一朝一夕就能完成的東西，甚至就某種角度來看會拖延到專案的進度。有點像是默默付出的工作吧…！畢竟在原有的專案中做改變本來就有較大的阻力。 何時應該重構隨時重構，不要為了重構而重構。再來可以參考三次法則) 上版的時候對現有的 HTML 及 CSS 重構，或者對應的 component 寫新的 js 模組時重構，順便撰寫 Comment 及文件 送 pull request 的時候：不過要確定自己有寫上詳細的 comment 及 doc，才能提高 code reviewer 的 review 意願，而 senior 總是能更快看出代碼裡面的問題。 我們常常對一些既有代碼的架構感到心癢，或者很想要趕快重構。但在 workaround 的情況下，有時重構的成本是非常大的。 何時不應該重構其實比起重構來說，更重要的應該是拿捏不應該重構的程度。身為工程師或多或少都會對別人的代碼嗤之以鼻，恨不得趕快把 code 清掉。但，既然 code 有某種程度的肥大，代表他或多或少解決了問題。而且重構是需要成本的。就算是以目前的開發來說，通常也是先著重於將功能實作後，在有限度地作小幅度的調整以及逐漸補齊文件及註解。對於重構來說，最重要的是 consistency。s 目前的解法雖然不漂亮，但確實解決問題的時候。 目前的代碼重複率還不高的時候 重構的成本太大，甚至影響到系統本身的時候。 保持心平氣和重構的時候記得控制自己的情緒。我們很可能一不小心就在咒罵代碼或前任，然後在情緒上頭反而過度重構，造成更多的問題也說不定。 代碼的存在是有歷史的 有可能是進度太趕、有可能是政治因素、又或者當時的技術還沒到位。但可以確定的是，情緒化完全無法解決問題。 don’t let anger contol you Talk is cheap. Show me the code. 下一篇，我會開始分享一些重構的技巧。 Final Word最後還是要聲明一下，這篇文章雖然會著重在一些重構的技巧上，但其實從 legacy code 中尋找出口的方法不只是重構而已。希望大家不要過往矯正，一看到髒 code 就急著捲起袖子重構。退一步評估一下成本跟重構的價值再做決定。 Legacy Code 專欄 如何從 legacy code 中尋找出口（中）- CSS 篇 從 legacy code 中尋找出口（中）- HTML 篇","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"重構","slug":"重構","permalink":"http://kjj6198.github.io/tags/重構/"},{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/tags/前端/"}]},{"title":"2016 g0v summit 心得","slug":"2016-g0v-summit","date":"2016-06-10T16:00:00.000Z","updated":"2017-07-20T07:19:51.000Z","comments":true,"path":"2016/06/11/2016-g0v-summit/","link":"","permalink":"http://kjj6198.github.io/2016/06/11/2016-g0v-summit/","excerpt":"","text":"因為一則廣告而創立的 g0vg0v 的由來其實是因為經濟動能推升方案（就是那個史上最腦殘的廣告) 這群熱血的工程師決定組成 g0v。致力於推動政府開放，並且以網路的方式推廣給大眾。 g0v 能夠紅，是從 318 學運開始。因為 hackfold 的共筆資料夾引入、直播工具…，讓大眾更了解…。 然後在場的 700 多位參與者中，大約有一成左右是來自政府的事務員，甚至連即將卸任的張善政也到了 g0v 分享推動政府開放資料的過程。 「把夢做大，然後相信總有一天會被別人看見，屬於自己的故事。」這大概是參加 g0v 最大的感觸。 只能說，方心沒辦法參與實在是很可惜的一件事，不過 g0v 有直播以及大會的共筆，能夠看看筆記、影片過過乾癮也好。 TL;DR沒人想得到，目前遍佈三大洲、超過500名公民黑客的零時政府，當初是因為台灣政府的無效廣告而催生。這群黑客村裡的工程師除了會寫程式，普遍英語能力好，他們關注世界各國公民科技對政府的影響。高嘉良在2014年就曾花兩個月的時間到各國城市，與開放組織、社群交流，吸取當地經驗，回台分享給社群。就這樣，本來應該平淡度日的程式工程師們，因為改造社會的熱情，一腳踏入公民科技。 第一次參加 g0v summit，聽說（和與會者聊天）這次的主題「拆後重建」有把主題拉廣。以前的議題技術性比較濃厚，吸引到的與會者也大多為工程師。這次不但有來自各國的與會者、講者，還有將近一成的與會者是政府機構的事務員。 你會發現 g0v 不會抱有特定立場，而是用一種中介者的角度幫你把事情記錄下來。直播也好、他們開源的小工具也好，都是如此。如果你有時間，可以看看這次的直播或是大會共筆，如果真的抽不出時間來，就來看看我的筆記吧！ 大會共筆 筆記.org 到 .ngo分享者是 ngo 的工程師，所以在講述自己在 NGO 的同時，也分享蠻多在開發時遇到的問題的。 分享者提到，環境資訊協會目前遇到的挑戰有： 2000 年到 2016 年：關於環境的議題根本沒有報社要報，頂多出現在生活版。=&gt;當時代開始逐漸變遷時，工具勢必要做改變 程式翻修：產品從剛上線開始就是 legacy system，通常要做好準備，在早期的沒有時間讓你 refactor，而是穩定之後才會開始重構，而且當時還導入了外部工程師幫忙 當 nobody 變成 somebody：面對的問題越來越多 人：有了組織、人、主管、薪水，管理變得困難 世代變遷：新人不斷輪替、老人沒時間談理想 =&gt; 溝通出現問題 既得利益者：當 nobody 變成既得利益者之後，我們還記得自己的初衷嗎 最後他將 NGO 扮演的角色做了總結： 匯聚資訊與力量的平台 Proxy：代理政府，快速回應議題 Agent：公民代理人 結論： 公司是除了國家以外，最重要、影響大家最多的組織。 民主與公民參與之開放媒體講者是 VOXE 的創辦人。VOXE 的概念跟台灣的(立委投票指南)[http://vote.ly.g0v.tw/]很像，46% US 的選民在總統大選時根本沒有出來投票。70%年輕人在2014的歐洲議會選舉都沒有出來投，很多人認為沒差。很多人認為選出來的人不在意民意，所以就乾脆不投。所以希望能夠透過工具來改善，而創立了這個平台。 其中有個問題讓我印象比較深刻，「怎麼讓大家付諸行動？這是最困難的一部份」，講者的回答是，透過工具的使用。畢竟一般人不可能整天抗議、整天看政見，有小孩老婆工作等等要顧，所以工具一定要夠簡單，才會刺激別人去用。 原本還有人問到，阿你們要怎麼募資，他的回答是 google 給了他們 20 萬歐元XD。完全不用擔心了啊！ 結論：工具是用來解決問題的。 強震即時警報系統這幾天大家應該都有收到地震的預報簡訊。講者開頭先敘述了 921 的實際經驗，提醒大家防震的重要性。先提一些地震小知識。wiki P 波的傳播速度最快，每小時兩萬八千里。地震預報就是用這樣的原理。當 P 波到達之後就是 S 波，S 波之後就是最可怕的表面波。 也就說在 P 波抵達時，接下來在表面波到達時所採取的動作是關鍵 今天，假設我們收到了這樣的簡訊，該怎麼辦才好？ 確認是否能在 30 秒內跑到屋外。 30 秒無法跑走，就需要知道房屋裡最安全的地方。 不要打卡，有可能 30 秒之後你就消失在這個世界上了 有些地震盲區，可能在震完之後才收到簡訊。日本大阪神地震，根據統計有七成受難者是自救，兩成是靠親友，剩下一成才是官方。這代表日本人真的把防災當作一回事。 額外加碼 精美東京防災手冊 我們的心態、以及相對應的防範措施，我們準備好了嗎？講者認為基金會會是一個解法。 結論： 防災，要從自己做起 我在新聞界臥底的日子講者是 Kirby。是 零傳媒 的創辦人 奇怪欸！女師二度爬山後來調查發現，這個女老師根本沒有男朋友。新聞的資料錯誤百出，媒體報導普遍素質低落。於是決定創辦零傳媒、以及提供資料視覺化的工具幫助記者在報導時有資料可以引述。而且可以提供給非技術人好上手的工具。 目前好用的資料搜集工具： open refine spreadsheet p5.js kimono 同時講者也分享了幾個真實案例： 冰桶挑戰：發現冰桶盛行的那幾週，佔了總捐款金額的 70% 急診人生 發現了以下情況： 資料記者要會寫程式嗎？進入成本會不會太高 找得到會設計、會寫文章、會採訪、又會技術的工程師非常難 新聞網站的文章表現沒有精練 開源的工具有可能沒有再維護了 服務有可能會終止 於是希望透過 piotDB 幫助到記者，也能夠幫助工程師在以後資料收集、視覺化中有更好的選擇。 秒退頂新地圖聽完講者分享之後，其實會發現這場看似臨時起意的秒買秒退，背後其實是有經過縝密計算的。到最後竟然還出現發起人上台分享心得。 因為秒退發起人已經先研究過好市多的商業結構，100% 滿意是買賣雙方的保證行為，對好市多來說這個活動達到需宣傳的效果，對於使用者來講則是滿足了購買滿意的條件。雙方利害一致、提高曝光度，好市多沒有理由拒絕。 先講結論 2015 營收少 15 億，淨虧損 19 億。（總資產 2.5 兆，佔全台灣的六分之一） 直接擊垮頂新大魔王是比較困難的一件事，所以先從小頭目開始。人民的力量是分散的，秒退地圖縮短長期抗戰的時間，秒退的挑戰第一個是爭議性的問題，第二個是行動本身的問題（需要親自到目的地去，忍受民眾和店員的目光）。秒退地圖可以把秒退狀況視覺化，把數據視覺化之後，比較可以組織與策劃下一步的目標。需要有人維持系統、推廣、蒐集登入資料等（系統本身的）挑戰。 不過身為一位正常公民，要做的事情實在太多了。誰跟你每天秒買秒退，今天林鳳營特價還是跑去小確幸一下。 長大是什麼感覺 來看看日本當初是怎麼讓雪印倒閉的連結。 從社群的角度來看： ptt 大部分是贊成，偶爾會有噓出現 Dcard 罵聲連連。一大堆反秒買秒對的文出現 Facebook 偶爾出現反秒買秒退的動態 先不論這個活動本身的道德辯證（講者說他只 focus 在解法）。 不管這個活動本身正不正確，他也已經有效地引起關注及思考，而大家一起討論、尋求解答，其實就是一種開放協作(open collcation)。 秒買秒退地圖 結論： 頂新或許什麼都可以買，但他買不到公民行動的良心跟憤慨 從 g0v 到 gov – 潛入衛福部 400 天讓我噴淚的一場分享，潛入衛福部第 400 天。也是我今天聽下來覺得最棒的演講 直播影片 公共政策網路參與平台 這個平台仿效美國、英國的機制，只要超過 5000 人連署，政府就要在 2 個月內作出回應。 講者從原本的 g0v 進入 gov，在引入協作工具中，也開始反思。政府要面對民間訴求很難嗎？詳細介紹一個公民提案到法案修正經過的過程與遭遇到的問題，點出社群參與者與政府觀點的落差。可以發現到，政府裡頭的公務員其實還是很願意做事情的。而這個案例最後政府回覆並且承諾修法，可惜提案人在法令公告前已經過世，而這項法案修正很可惜的沒有在他在世時協助到提案人。 我還記得聽完演講之後，掌聲大概持續了三十秒有吧！雖然最後真的很可惜沒有幫助到提案人，但我相信他的分享已經間接影響很多人對政府的觀點了。 政府要面對民間訴求，還真的挺難的 開放，是有成本的。 工程師要避免 single point of failure，公務員要避免 single point of success 不開放、不透明的黨產在選前常常看到國民黨黨產的相關圖表。 講者還開玩笑說具有所謂的地址，做成了地圖，可以看到國民黨在台北的土地，在台南白河有很大的地方都是國民黨的！一看街景種滿了檳榔香蕉。以後搞不好會做出國民黨黨產觀光app。 國民黨黨產尋訪車遊 在台灣因為沒有政黨法的關係，所以沒有特別限制黨產的來源。這造成了國民黨無私地接收了當時國家徵收的土地和營收。 國民黨： 225 億 民進黨： 4 億 其他： 1900 萬 可以看到這樣懸殊的落差，造成小黨生存不易，光是打廣告就先輸一半了。 開放的問題 歷史檔案的保存與修復 資訊的完整性 黨產解密 gitbook 結論：國民黨不倒，台灣不會好 unconference在 unconference 裡主要是讓與會者發起自己的想法，第二天早上在交誼廳互相討論自己的想法。 時間有限，我只聽一些自己有興趣的主題： 轉型正義如何降低討論的門檻，吸引一般人關注是討論重點。通常除了 228 受害的家屬、親友會去關注之外，一般社會大眾比較不會關心。一來是台灣歷史教育對 228 的輕描淡寫，再來是因為大部分人沒有經歷過 228。 歷史學家的instagram 二二八事件地圖 轉型正義遊戲 建構大眾對議題的興趣 對抗資本主義的共享經濟談大家對共享經濟的想像 維納斯計畫 日本共生住宅 Uber AirBnB又是共享主義，但又是資本主義的代表。沒有辦法自己對抗自己。另外一本書「零邊際成本的社會」，才能夠更去了解。屬於中產階級的共享，並非理想中的共享 只能從內部被摧毀，不能從外部去征服。當邊際成本走到零的時候，資本主義就不會繼續做那件事了，所以就會變成共享經濟了。 寫在最後花了 1200 參加 conference，感覺不做點什麼也不太好。所以就把自己的心得跟筆記一起寫下來了。除了給方心過過乾癮，也順便給公司一個交代（？）。 是真的看到、也學到挺多東西的啦！而且便當好吃又環保，但是他們賣的那雙環保筷一組要 300 塊耶！跟漁夫一樣完全下不了手啊！ 這次也有 unconference 的 session 跟與會者互動的小遊戲（搜集杯子）換獎品。感覺之後聚會的主角會越來越偏向與會者本身。","categories":[],"tags":[{"name":"g0v","slug":"g0v","permalink":"http://kjj6198.github.io/tags/g0v/"}]},{"title":"weekly-6/6","slug":"weekly-6-6","date":"2016-06-06T13:52:39.000Z","updated":"2016-11-14T11:45:10.000Z","comments":true,"path":"2016/06/06/weekly-6-6/","link":"","permalink":"http://kjj6198.github.io/2016/06/06/weekly-6-6/","excerpt":"","text":"這次介紹一下我建置 style guide 的過程以及心得。 工作內容 styleguide 建置 新的 ws_job_index search bar Styleguide 真的很重要在建置的過程中，我們常常會忽略，「如果是別人，該如何快速懂得文件的內容」。所以在上以前的 view 當中，我其實都不太清楚。「啊！原來這個已經寫成 helper 了」「啊！這個已經寫成 class」的情況屢見不鮮，所以我在上新的版面過程中，都會盡量地以「之後的自己或別人也能看得懂」為原則。同時也會順手把以前的 code 跟文件統一整理。 最陽春的 styleguide 只花了兩天就有了雛形了，這證明文件的建置並不是那麼困難。但是更重要的是 consistency，也就是持續更新這件事。 而且透過寫文件的方式，其實 code 的概念很容易就讓別人懂，雖然無可避免地要花一些時間，但我認為這是蠻值得的投資。所以讓我們一起來 document driven 吧！ 接下來會介紹我在建置時發現的一些不錯的概念。 Helper 真的很好用使用 helper 的方式，我們不僅可以快速套用 rails ruby 內建的方法，還可以讓 view 裡面的 HTML 碼大量減少，增加易讀性跟擴展性。 123&lt;%= ui_component(\"sudo_tags\", &#123; :tags =&gt; \"blabla\"&#125;) %&gt; 這個 ui_component 的方法，其實是對 render 的進一步包裝： 123def ui_component url, options = nil render \"components/#&#123;url&#125;\", :locals =&gt; optionsend 雖然是簡單的方法包裝，但其實大量提升了可讀性，我們也可以拆分元件，統一放入 component 裡面管理。如果元件的構成很簡單，甚至還可利用 content_tag 來包裝。 12345def button_generator content, options = nil btn_class = \"btn \" options.merge(:class =&gt; btn_class) content_tag :button, content, optionsend 希望以後真的可以達到高度組件化，這樣就算是科科，也能簡單引用某個元件。 關於 layout 的新想法：我實在非常不喜歡 grid，但實務上無可避免地還是會使用到。那麼，有沒有比較折衷的辦法來維持可讀性，也就是所謂的 layout 與語意分離。 還真的有，而且這個方法實作起來並不難。答案是善用 css 的 attribute selector 1&lt;div layout=\"col-3\"&gt;&lt;/div&gt; 123[layout^=\"col-*\"] &#123; // your gird style&#125; 雖然看起來只是將 layout 拆至一個 attribute 裡面，但這樣至少不會看見 col-3 等 grid 的 rule 出現在 class 裡面。對我來說可讀性提高很多，但最理想的方式還是盡可能寫進 class 裡面吧！","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[]},{"title":"weekly-thought-5/29","slug":"weekly-thought-5-29","date":"2016-05-29T13:09:36.000Z","updated":"2017-02-19T11:19:08.000Z","comments":true,"path":"2016/05/29/weekly-thought-5-29/","link":"","permalink":"http://kjj6198.github.io/2016/05/29/weekly-thought-5-29/","excerpt":"","text":"發現的新東西flow第一次聽到，是從 henry 的口中。第二次看到，是從看了 draftjs 的 source code。 當前端的 code 無可避免地增肥之後（尤其是 js 跟 css)，我們也應該尋找更有效的代碼管理方式。像是逐漸引入的 eslinter 跟 stylelint 都是。 而 flow 給我的感覺有點像 Typescript，但優點是你可以完全用寫 js 的方式，也不需要改變副檔名（typescript 要寫成 a.ts)。不過還是會害怕抽象化滲透，所以一樣會先觀望一段陣子再套用到主站上吧。 draft假日閒來無事、天氣燥熱，在咖啡廳喝咖啡、聽音樂、寫 code 也蠻愜意的。所以就趁著假日的時光研究了一下科科所說的draft-js 所有的骯髒事（selection 兼容、檔案拖曳、編輯器內的樣式）draft-js 幾乎都幫你搞定了。當然因為這個 open source 還非常新（react conf 的時候才推出來），有時候噴錯也不知道從哪邊找起。但這的確是值得令人關注的 editor 解決方案。 目前編輯器會遇到的問題1. input 跟 textarea 是有極限的 他們只能渲染 plain text，如果想要對文字做加粗、斜體、標記等動作，需要花很大的功實作 當你的文字輸入到下一行時，textarea 高度不足不會自動幫你移位。你可能需要計算下一行文字的位置，然後做相關的操作。這也很費工，而且對使用者的體驗非常糟糕。(備註：現在已經有了新的解法 ) 2. contenteditable is terrible因為是將文字內容放在非 input 的 tag 裡面，每種瀏覽器的實作都不太一樣，也很容易就會有意想不到的問題發生。不過 contenteditable 的好處是他活得夠久，瀏覽器也都幾乎實作了，所以反而可以利用這樣的特性來解決當前編輯器遇到的問題。 draft 的概念其實也跟 react 很像，將 editor 跟 content 的狀態存放起來，而非依賴在 DOM 上面。而且他們的狀態不是用純 string 去儲存，而是用 Record(他們實作的資料結構)來代表每個節點。 而 API 文件也寫得挺清楚的，同時也完全實作 immutable 的概念。每次對編輯的內容做操作，就是完全更新狀態。剛開始會覺得很麻煩，我明明只是要一段 text，還要呼叫 getCurrentContent() 回傳的竟然還是一個 Map 在從裡面呼叫 getText()；或者我想要更動狀態時，還要做類似這樣的操作：RichUtils.toggleInlineStyle(curState,&#39;BOLD&#39;)，然後再把新的 state 傳進去。看似麻煩，不過這樣的方式到後期的開發顯然是有好處的。容易測試，易讀性高，容易修改、除錯。 facebook 也提供了蠻實用的範例 看完之後可以更瞭解 draft 到底是怎樣運作的。 這邊是我看了官方文件之後實作的範例：draft-example 。還不算太完整，之後會再慢慢補上。 reference a guide to draftJS 重新思考 rails helper在逐漸重構 css 跟 html 的過程中，常常會忘記 helper 的存在，最近寫一寫才恍然大悟，對啊！我不是有 helper 嗎？目前對於比較複雜的邏輯判斷已經會習慣性地去使用 helper，但在 view 裡頭，有沒有 helper 可以幫上忙的可能性？ 雖然用 partial 也可以做到類似的事情，但跟 helper 做搭配會更強大啊！ 而且因為 partial 有時候還要去對應路徑，而 helper 則是全域都可以使用。對高度重複的頁面來說或許用 helper 會更加簡單！ 例如我們很常用到的 tags。 當初 sudo tags 改版的時候花了不少時間去更動，因為幾乎每個 tag 裡面都重寫了一次 each，class 命名有時候也不盡相同。 不過使用 partial 又好像太小題大作，畢竟 tag 的架構並沒有如此複雜。 1234def tag_of_tags(tags, options = &#123;&#125;, html_options) raw tags.collect &#123; |tag| content_tag(:span,tag.name, options, html_options)&#125;end 這樣一來，每次我需要用到 tag 的時候就只要 1&lt;%= tag_of_tags(@post.tags) %&gt; 當然也可以做一些調整，例如加入 namespace 來符合我們的使用情境。1234def tag_of_tags(tags, namespace,options = &#123;&#125;, html_options) raw tags.collect &#123; |tag| content_tag(:span,tag.name, :class =&gt; namespace)end 1&lt;%= tag_of_tags(@post.tags, \"sudo\") %&gt; 這樣一來每次 tag 要更新的時候，我只要安心修改 helper，其他地方全部都會生效。寫起來自然輕鬆！ 以上只是一小部分的例子，舉凡 navbar button dropdown 等，幾乎是每個網站開發必備的元素。我們在新增 partial 的同時，說不定也可以搭配 helper 一起思考更多的可能性！ 關於文件，我有話要說最近因為想要讓 legacy 漸漸減少，會盡量地用重用性的角度來思考。 不過科科給了我一句話「太早談重用性，反而會掉入過度設計的陷阱」。仔細想過之後，的確如此吧！ 但我認為，這樣的嘗試是好的，對自己來講是從更寬的角度來看自己的 code，也可以減少一些自己以前的盲點等等。 而想要讓 code review 變得輕鬆的辦法，就是寫文件。不管對 senior 也好對 junior 也好都是有幫助。雖然我的 code 現階段還沒有達到很高的水準，可是透過寫文件這件事情，code reviewer 可以快速理解我的想法，為什麼我要這麼做。 而不是讓 reviewer 從頭看我的 code，揣測我到底在幹嘛？像是 modal 對我來說就是一個很好的嘗試，科科很快地就指出其中的問題跟盲點。 這樣一來，對我來說，我可以從自己的想法裡面寫出品質更好的 code；而 reviewer 因為容易理解我的想法，給予 feedback 的意願也就相對提高了。 當然，可能目前寫得還不夠多，想法也還不夠成熟也說不定，但是從這樣的練習過程中，我想也會慢慢進步吧！ 這是我為什麼很用心在寫文件的原因，因為對彼此來講都是節省時間。我省掉以後再看 code 時回想的時間，而 code reviewer 則是省下從頭開始理解的時間。 目前還在磨合期中，希望科科也可以提供建議！ referencegood commit message javascipt testhow to write test in existing javascript 很多人都是從前任接手 code 的，這篇文章教你如何從現存的 code 當中進行 refactor。裡頭有很多想法值得一提： 不要怪罪前任，要知道代碼的由來通常是有歷史的（每個人都會寫爛 code） 如果沒有 unit test 也沒關係，至少從自己做起 用消極的態度、因為情緒而過度設計，反而會造成更多問題 永遠不要情緒化寫 code don’t use !important with anger 目前也正在找尋適合主站的測試工具中，希望有一天我們可以達到超過…百分之五十的測試率。 日本工作三個月","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"js","slug":"js","permalink":"http://kjj6198.github.io/tags/js/"},{"name":"draft-js","slug":"draft-js","permalink":"http://kjj6198.github.io/tags/draft-js/"},{"name":"flow","slug":"flow","permalink":"http://kjj6198.github.io/tags/flow/"}]},{"title":"【筆記】易讀程式碼之美學","slug":"readble-code-art","date":"2016-03-19T16:00:00.000Z","updated":"2017-02-28T16:16:13.000Z","comments":true,"path":"2016/03/20/readble-code-art/","link":"","permalink":"http://kjj6198.github.io/2016/03/20/readble-code-art/","excerpt":"","text":"比較短的程式碼比較好嗎？雖然減少程式碼會提高易讀性，但縮短讀程式碼的時間才是重點。 表層結構 清楚的命名方法跟變數名稱 方法不需要用 do 選擇詞彙的時候不要用模擬兩可的名稱，ex: pop popItem 在方法名稱加入更多的資訊 1234 function getPage() &#123;&#125; // 對方可能不知道 getPage 的實作方式？爬蟲？ ajax？function fetchPage() &#123;&#125;// 可能比較清楚是用 ajax 的方式並且回傳 json。 找尋更明確的詞彙 send =&gt; deliver dispatch announce route find =&gt; search extract locate recover start =&gt; launch create begin open make =&gt; create setup build generate add new compose 清楚明確比可愛更重要 就算是 tmp 變數，也可以提供多一點資訊。 tmpNumber tmpFile tmpUsrData 如果迴圈的 i,j 有意義，那麼就取個適當的名字。 ex: row col index 選擇具體的方法名稱。 如果變數具有單位，把單位放進去。 startSec delayMs 重要屬性的變數命名 plainData entryptedData 如果變數的作用範圍比較大的時候，用比較長（or 包含資訊較多）的變數是比較好的選擇，相反的如果只有幾行程式碼就結束，其他人可以馬上看出這個變數在做什麼，那麼就算用 alias 也沒關係。 不被誤解的名稱 filter 是把東西 filter 掉，還是留下？ min max 前綴 布林值 computeData =&gt; 比較像執行一個耗費較大的 function 排版一致 符合排版一致 調整程式碼有的相似外觀 相關程式碼為一個段落。 註解的美學 為什麼排版那麼重要？第一個是其他人（或者是你）以後再看程式碼的時候，至少比較容易（也比較願意）看得懂，再來是你可以花更少的時間去理解你的 code 在幹麻，何樂不為？ 代碼品質工具 eslint stylelint ​ 用方法消除混亂？ 如果你發現你在做某一件事情感覺很混亂的時候，就該使用 method 包裝。 用精美不實的包裝來欺騙消費者是人類的本性（誤）。能不能欺騙別人不是重點，重要的是是否能夠欺騙你自己。連你自己都不尊重的 code 別人也不尊重的。 例如說： 123assert(checkTime('12:00')) === \"12:00\";assert(checkName('kalan', 20)) === &#123;name: \"kalan\", age: 20&#125;;assert(checkPaid(20000, true)) === 20000; 仔細觀察一下上面的 code ，不難發現它們都是在做一些同樣的事情，而且還有一些重複出現的字串。而且太長了，我們需要一點時間才能知道這幾行 code 在幹嘛。 這個時候就需要重構啦，我們可以用 method 把它包裝起來。 1234567891011121314151617181920function checkValue(type, value) &#123; if (type === \"time\") &#123; assert(checkTime(value)); &#125; if (type === \"name\") &#123; assert(checkName(value) === value; &#125; if (type === \"paid\") &#123; assert(checkPaid(value)) === value; &#125;&#125;// checkValue(type, value);// [string] [depend]checkValue(\"name\", kalan);checkValue(\"time\", 12:00);checkValue(\"paid\", 20000); 這樣一來 code 比較簡潔，易讀性也提升了！再次強調，並不是比較精簡的程式碼就是好 code ，容易讓人理解的 code 才是好 code。除了這些之外，還有一些好處： 清楚呈現測試的部分。 更容易加入其他測試！ 照順序及段落區分：落落長的程式碼不僅是別人，連自己都不會想看。在變數宣告、陳述式表達的時候，可以依照所做的行為不同拆分。這個寫文章也需要段落是同樣的道理。 123456789function getUserInfo(userName, age) &#123;&#125;getUserInfo(\"kalan\", 20);// getUserInfo(userName, age)// [string] [number]getUserInfo(\"kalan\", 20) 如果有相同的函式呼叫的話，可以讓參數對齊方便閱讀。 123456command = &#123; &#123; \"timeout\" , null, cmd_spec_timeout&#125;, &#123; \"timestamping\" , bull, cmd_adj_boolean&#125;,f&#125; 在寫註解的時候，其實不需要太拘泥，把自己當時想到的想法，以及這個 function 應該做的事情寫下來就好了，有時候過了一段時間你會忘記這個 function 在幹麻。 – #2. 註解篇： 註解是為了讓其他人了解程式設計者的想法而存在的。同時也讓自己了解自己當初的想法。 如何撰寫好的註解，以及哪些東西不需要註解。 不該註解的部分 為讀者設身處地著想 不要讓註解搶走了程式該有的位置 避免寫作抗拒。這通常需要一段時間才能體會到。但當專案架構還沒有變得複雜之前就盡快寫註解絕對是件好事。不然你只能寫下違背良心的 // TODO: refactor 然後就再也沒有下文了。 結語 選用特定寫法的原因 程式碼中的缺陷。 使用者會對哪個部分感到疑惑 維持註解簡潔 用更精確的方式來描述自己的程式碼，並且不要用代名詞來描述參數。 如果參數的行為較複雜，可以直接給範例讓使用者一目了然。 #3. 流程控制： 最常見的就是 if/else 的判斷。書中提供一個準則，就是肯定的條件句先擺前面、先處理簡單的狀況。如果你的 function / method 是有返回值的，就盡快讓他 return 吧！ 善用迪摩根定律：這個定律應該理工科都有印象吧！他可以把一些比較複雜的邏輯判斷簡化。 與複雜的邏輯搏鬥：書中提到一個蠻有趣的方式，我想把它記錄下來。在實作 range 的時候，我們可能有一個方法 overlapWith ，來判斷兩個 range 之間是否有重疊。比起使用直接比對這兩個 range 是否有重疊，不如比對這兩個 range 是否不重疊更簡單。因為只要比對兩種狀況 =&gt; other 的 end 在 range 之前。 other 的 start 在 end 之後。 將龐大的表示式用變數裝起來。123456789101112131415$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');// refactorconst $thumbUp = $('.thumb_up');const highLight = \"highlighted\";$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');// #4. 變數： 變數存在越久，就越難 debug 減少不必要的變數宣告。 什麼是不必要的變數？ 無法讓意思變得更言簡意賅 本身的邏輯不複雜，不需要再用變數取代 只使用一次 使用一次性寫入的變數 在 functional programming 當中，我們希望 function 是 pure 且 immutable 的，對於變數來說也是，盡量讓你的變數為 const 或 immutable 的。這樣子不僅你對 function 可以一目了然，也比較容易掌握出錯的點在哪裡。 將想法轉為程式碼：先用口語敘述行為，再把程式的行為轉換為程式碼。這樣子可以幫助程式設計師寫出更自然的程式碼。 避免撰寫不必要的程式碼 了解需求 重新思考需求 定期閱讀 API 以維持對標準函式庫的熟悉度","categories":[{"name":"程式筆記","slug":"程式筆記","permalink":"http://kjj6198.github.io/categories/程式筆記/"}],"tags":[]}]}