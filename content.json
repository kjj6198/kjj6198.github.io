{"meta":{"title":"欠擬合 | UNder-fitting","subtitle":"Fun Driven Frontend Developer 最近的夢想是能夠光榮地回鄉工作。\n如果你也對日劇、機器學習、日文、前後端開發、React、程式、咖啡有興趣，或許我們可以聊聊\n","description":"Fun Driven Frontend Developer 最近的夢想是能夠光榮地回鄉工作。\ninterested in #frontend #react #redux #rxjs #japanese #machine-learning\n","author":"Kalan","url":"http://kjj6198.github.io"},"pages":[],"posts":[{"title":"react-hot-loader 無法使用 react-hooks","slug":"react-hot-loader-hooks","date":"2019-01-21T03:06:17.453Z","updated":"2019-01-21T04:25:34.235Z","comments":true,"path":"2019/01/21/react-hot-loader-hooks/","link":"","permalink":"http://kjj6198.github.io/2019/01/21/react-hot-loader-hooks/","excerpt":"","text":"雖然說 react-hooks 也有一陣子了，不過那個時候我還正在服役，只能乾瞪眼。前幾天想把自己的 boileraplate 更新一下，發現在使用 react-hot-loader 時會沒辦法使用 react-hooks 相關的 API（如 useEffect, useMemo 等等），會出現如下圖的錯誤： ​​ 查了一下 issue，發現維護者本人說： Yes. RHL is 100% not compatible with hooks. There is just a few reasons behind it. SFC are being converted to Class components. There is reason - to be able to forceUpdate on HMR, as long there is no “update” method on SFC. I am looking for other way of forcing the update (like this. So RHL is killing SFC. “hotReplacementRender”. RHL is trying to do React’s job, and render the old and the new app, to merge them. So, obviously, that’s broken now. I am going to draft a PR, to mitigate both problems. It will work, but not today. 看來是因爲 react-hot-loader 裡頭的機制造成的問題。雖然看了一下 README，官方表示已經可以支援 react-hooks，但我發現還是不行，仍然會出現一樣的問題。 目前的解決方式是將 react-hot-loader 升級到 4.6.3，並且將 react 跟 react-dom 升級到 16.8.0-alpha.1。希望趕快發佈正式版本 QQ","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[]},{"title":"和 CORS 與 cookie 打交道","slug":"cors-and-cookie","date":"2019-01-18T06:13:25.660Z","updated":"2019-01-18T06:16:02.669Z","comments":true,"path":"2019/01/18/cors-and-cookie/","link":"","permalink":"http://kjj6198.github.io/2019/01/18/cors-and-cookie/","excerpt":"","text":"前言CORS 與 cookie 在前端是個蠻重要的問題，不過大多數在開發的時候，因為前後端的 domain 時常是相同的，所以很少去 care 這些問題。或者只要要求後端將 Access-Control-Allow-Origin: * 開好開滿就對了，很少去理解背後運作的機制。 針對這個問題，MDN 上其實有個非常詳盡的解說，所以這篇文章主要在於整理重點以及在實際操作上時常發生的問題。 同源政策（same-origin policy）為了防止 javascript 在網頁上隨地撒野，同源政策規定了某些特定的資源、程式碼，必須在同源的情況下才可以存取。 那麼，什麼是同源呢？一份 document 的來源，由 protocol, host, port 來定義。也就是說如果文件 1 來自 http://kalan.com，而文件 2 來自於 https://kalan.com 他們就不算同源；那如果是 subdomain 呢？像是 https://api.foobar.com 跟https://app.foobar.com。因為他們的 host 不同，所以也不算同一個 origin。 而有些資源是本來就能夠透過跨來源取得的： &lt;img /&gt; &lt;video /&gt;, &lt;audio /&gt; &lt;iframe /&gt;：可以透過定義 header 來防止他人嵌入 透過 &lt;link rel=&quot;stylesheet&quot; href /&gt; 載入的 CSS 腳本 &lt;script src=&quot;&quot; /&gt; 載入的 Javascript 而透過程式碼發出的跨來源請求則會受到同源政策的限制（如 Fetch, XHR）。 很顯然地，這樣的政策太過嚴格了。如果都要限制在同源政策下的話，前後端開發會非常難以進行，也沒辦法用 XHR 的方式套用其他 SDK 的 API。也因此出現了 CORS（Cross-Origin Resource Sharing）的機制。 CORS（Cross-Origin Resource Sharing）很多人都覺得 CORS 是前端才需要具備的知識。不過 CORS 通常需要後端設定相關的 header，並且了解背後所具備的含義才有辦法正確運作。 那麼跨來源請求是怎麼運作的呢？主要是由兩個 Header 來做相對的存取控制，Origin 和 Access-Control-Allow-Origin。 只要發送請求時的 Origin 和回應的 header 中 Access-Control-Allow-Origin 的值相同，或是Access-Control-Allow-Origin: * （代表允許任何網域存取資源） 如果不符合 CORS 的話，會顯示下列訊息： 如果你嘗試去讀取回傳的物件，還會得到 warning。 那麼…，我們如果按照提示所講的，將 fetch mode 改成 no-cors 會發生什麼事呢？ 的確，我們把惱人的錯誤訊息給處理掉了，但是情況似乎沒有比較好一點。 no-cors 並不是萬靈丹，就算使用了這個 mode，CORS 也不會因為這樣就打開大門，也就是你的請求並不會成功送出。也因此出現了 SyntaxError: Unexpected end of input 這個錯誤。這個 mode 通常是跟 service worker 搭配使用的。 從上面這個實驗當中我們可以得知，要解除 CORS 的封印只有一招，就是在伺服器端加上正確 Control-Access-Allow-Origin（host 必須跟 origin 相同或是 *）。 另外，CORS 這個機制只會運作在 javascript 送出 XHR 或 fetch 時，一般像是 curl 或 postman 並沒有這個機制，所以也因此常常在測試 API endpoint 時會忽略這項事情，導致前後端在測試 API 時有出入發生。 有些跨來源請求不會發生 preflight，而有些請求則會，MDN 上寫的條件蠻清楚的： 必須是 GET, HEAD, POST 其中一種方法 除了 user-agent 自動設置的 header 和特定的 header 之外，不包含其他 header。可接受的 headers 若有 Content-Type（注意是 request header ，不是 response header），則必須是下列的值 application/x-www-form-encoded, text/plain, multipart/form-data 也就是說如果不滿足以上條件的話，就會發出 preflight 請求。 我們試著改變 Content-Type 為 application/json 來達成 preflight 的要件（不為 application/x-www-form-encoded, text/plain, multipart/form-data）。 Preflight所謂的 preflight 就是請求會先以 HTTP OPTION 的方式送去另外一個網域敲門，確認沒問題後才會送出真正的請求。一旦觸發了這個條件，要做的事情就會變得麻煩許多。 你必須加入一個 OPTIONS 的相同 api endpoint，並且設定 Access-Control-Allow-Origin 來符合 CORS 要件 你必須加入 Access-Control-Allow-Headers，且必須包含所有不在條件內 header，否則無法通過。 如果沒有通過 preflight check 的話，會得到錯誤訊息如下： 12Access to fetch at &apos;http://localhost:3001/trigger-preflight&apos; from origin &apos;http://localhost:3000&apos; has been blocked by CORS policy:Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response. 或是你沒有在 OPTIONS 的回應標頭裡加上 Access-Control-Allow-Origin: 1Access to fetch at &apos;http://localhost:3001/trigger-preflight&apos; from origin &apos;http://localhost:3000&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. If an opaque response serves your needs, set the request&apos;s mode to &apos;no-cors&apos; to fetch the resource with CORS disabled. 如果成功的話，你會看到 network 裡頭有兩個請求，一個是 OPTIONS，另一個則是真正的請求。 如果我們加上一個自製的 header 呢？根據 MDN 所定義的要件，也應該觸發 preflight 請求才對，我們加上一個 X-Access-Token 看看會發生什麼事。 12345fetch('http://localhost:3001/trigger-preflight', &#123; headers: &#123; 'X-Access-Token': 'dontbeserious' &#125;&#125;) .then(res =&gt; res.json()) .then(log); 的確無法通過 preflight，如果要通過的話，必須再把 X-Access-Token 加入 Access-Control-Allow-Headers 中。 附帶身份驗證的請求cookie 並不能跨域傳遞，也就是說不同 origin 中的 cookie 沒辦法互相傳遞及存取，不然就天下大亂了。不過如果你在 a 網域送出了 b 網域的請求，且 b 網域回傳了 cookie 的訊息，那麼在 a 網域會以 b 網域的形式儲存一份 cookie，不過如果沒有設定 withCredentials 或是 credentials: ‘include’ 的話，就算伺服器有回傳 Set-Cookie，一樣不會被寫入。像是下圖： 在一般情況下如果再使用 b 網域的 API，cookie 是不會自動被送出去的。這個情況下，你必須在 XHR 設定 withCredentials 或是 fetch 的選項中設置 { credentials: &#39;include&#39; }，因為這也是一個跨域請求，所以也必須遵照 CORS 要件加入 Access-Control-Allow-Origin 1234fetch(`$&#123;hostname&#125;/cookie`, &#123; method: 'POST', credentials: 'include'&#125;); 1Access to fetch at &apos;http://localhost:3001/cookie&apos; from origin &apos;http://localhost:3000&apos; has been blocked by CORS policy: The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. 為了避免安全性的問題，瀏覽器還有規範 Access-Control-Allow-Origin 不能是 *。 1Access to fetch at &apos;http://localhost:3001/cookie&apos; from origin &apos;http://localhost:3000&apos; has been blocked by CORS policy: The value of the &apos;Access-Control-Allow-Credentials&apos; header in the response is &apos;&apos; which must be &apos;true&apos; when the request&apos;s credentials mode is &apos;include&apos;. 不過光是這樣還不夠，瀏覽器會自動拒絕沒有 Access-Control-Allow-Credentials 的回應，也因此如果要能夠將身份訊息傳到跨網域的伺服器當中，必須額外加上 Access-Control-Allow-Credentials: true。如果都有設定成功，應該會像下圖這樣，在 Request Cookie 可以看到 cookie 被成功送出。 好了，即使你成功設定了這些東西，你還是有可能沒辦法將 cookie 送到伺服器當中。關於這一點，可能是下列幾種情形： 1. 使用者封鎖了此網域的 cookie可能使用者把你加入了黑名單，導致 cookie 無法成功送出 解決方法： 改網域 檢討自己為什麼被使用者封鎖 2. 使用者阻擋所有外部網站的 cookieSafari 有時會被開啟，在 debug 的時候嚐了不少苦頭。 後記要處理 CORS 是件吃力不討好的事情，尤其是有時忘記加上 Access-Control-Allow-Origin 或是 Access-Control-Allow-Credentials，再跑 CI/CD、部署可能又是一天後的事了。這次把一些常見的問題整理起來，希望之後如果再有類似的情形可以知道怎麼處理。 不過現在有 AWS API gateway，可以幫你加上需要的 header 而不用動到主程式碼，或者乾脆一勞永逸掛一層 proxy 在同一個 domain 下之類的。 參考文章 https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"CORS","slug":"CORS","permalink":"http://kjj6198.github.io/tags/CORS/"},{"name":"cookie","slug":"cookie","permalink":"http://kjj6198.github.io/tags/cookie/"}]},{"title":"日本軟體業常見名詞轉換","slug":"japan-software-noun","date":"2019-01-15T09:52:38.627Z","updated":"2019-01-15T10:01:22.217Z","comments":true,"path":"2019/01/15/japan-software-noun/","link":"","permalink":"http://kjj6198.github.io/2019/01/15/japan-software-noun/","excerpt":"","text":"由於實在太多特定的詞彙了，每次看到每次都要查一遍實在太累人了，而且還要一直 context switch。統一整理成一篇記錄起來。 大部分的名詞都是由英文直接轉換成片假名，但當中還是有些直接用日文表達，或是平假名與既有單字結合。嗯說真的要直接對應起來還真有點吃力，不過想了一下中文好像也是這樣，沒什麼資格好說別人的。 如果還有相關名詞的話會持續更新。 日文 中文 來源 備註 フレームワーク 框架 framework コンポーネント 元件、組件 component 関数 函數 引数 參數 アロー関数 箭頭函數 arrow function 是 javascript ES6 新增的語法 メソード 方法 method 非同期処理 非同步處理 入力値 輸入值 ソースコード 原始碼 source code リテラル 字面值 riteral オブジェクト 物件 object 匿名関数、無名関数 匿名函數 分割代入 解構賦值 javascript 當中 const {a, b} = c 的語法 残余引数 rest javascript 當中 const { a, b, …rest } = c 的語法 デフォルト引数 default 戻り値、返す値 回傳值 コールバック 回呼（中文通常仍然用 callback) callback 真理値 布林值 true/false 配列 陣列 第 1 級関数 第一級函數 正規表現 正規表達式 シンボル symbol コンパイラ 編譯器 compiler 疎行列、スパース行列 稀疏矩陣 特異値分解 奇異值分解 接続コード 轉接頭","categories":[{"name":"Software","slug":"Software","permalink":"http://kjj6198.github.io/categories/Software/"}],"tags":[{"name":"日本","slug":"日本","permalink":"http://kjj6198.github.io/tags/日本/"}]},{"title":"【golang 筆記】 如何為你的專案設定環境變數","slug":"golang-env-variable","date":"2018-09-03T15:02:53.000Z","updated":"2018-09-03T15:24:36.000Z","comments":true,"path":"2018/09/03/golang-env-variable/","link":"","permalink":"http://kjj6198.github.io/2018/09/03/golang-env-variable/","excerpt":"","text":"前言在開發專案的時候常常需要切換不同的環境，也因此我們通常會設定不同的環境變數。不過如果直接寫死在程式當中每次修改起來實在太麻煩了，如果可以透過動態的方式傳入環境變數的話可以減少很多不必要的修改，程式也相對比較乾淨。 flag一般在 golang 可以利用 flag 這個 package 做到類似的效果，例如： 123456789var env stringvar accessToken stringfunc main() &#123; flag.StringVar(&amp;env, 'ENV', 'development', 'your current env') flag.StringVar(&amp;accessToken, 'ACCESS_TOKEN', 'xxx-oo-ooo', 'your API access token') flag.Parse() // start your application&#125; 或者也可以參考這篇文章中提到的方式，用 go build -ldflag 在 compile time 設定變數。 雖然這樣的確不用寫死值在程式裡頭，但變數仍然要事先定義好。 透過 YAML 載入為了解決上述問題，我們可以透過 yaml（或者你喜歡的 format）來統一管理環境變數。例如： 12345678910111213func LoadEnv(filename string) bool &#123; file, err := ioutil.ReadFile(filename) if err != nil &#123; // 在 production，我們可能會直接用 console 設定環境變數 return false &#125; var config := make(map[string]string) yaml.Unmarshal(file, &amp;config) for k, v := range config &#123; os.Setenv(k, v) &#125;&#125; 將 yaml 裡的變數載入後，在統一用 os.Setenv(k, v) 存入，這樣一來在 local 的環境下就可以很容易地調整變數，記得要把設定當給 ignore 掉，不然如果變數裡頭有敏感資料，又剛好是 public 的 repo 就會被看光光了。 後記我寫了一個相當簡單的 repo 來做這件事，如果在開發上真的有需要的話再持續優化他吧XD kjj6198/configo simple util to inject variable into env variable. Contribute to kjj6198/configo development by creating an account on GitHub. https://github.com/kjj6198/configo","categories":[{"name":"golang","slug":"golang","permalink":"http://kjj6198.github.io/categories/golang/"}],"tags":[]},{"title":"瓢蟲 - 伊坂殺手系列第二作","slug":"isaka-killer","date":"2018-08-28T16:24:39.000Z","updated":"2018-08-28T16:31:20.000Z","comments":true,"path":"2018/08/29/isaka-killer/","link":"","permalink":"http://kjj6198.github.io/2018/08/29/isaka-killer/","excerpt":"","text":"我很喜歡伊坂的殺手系列小說。他筆下的殺手並不是絕對的壞、絕對的無情，也不是像一般設定那樣因為遭受過某種重大打擊，對這個世界感到絕望憤而成為殺手。 伊坂筆下的殺手跟平凡人相同，就如同「上班族」一樣，大家都是為了討生活而工作著。當然這在現實中絕對是不正確啦！不過搬移到小說之後，這樣的殺手並不會造成道德上的擔憂還有讀者心裡的陰影，反而在劇情主軸的進行中，看見了許多人生的歡笑與哀愁。 伊坂的小說喜歡創造一個天馬行空的設定和奇怪的書名，卻又能夠在故事結尾將這些八字沒一撇的關係緊密結合。 這次的事件發生在列車上，一連串的殺手相遇，各種背景的人們因為不同的原因、委託而聚在一起，形成一種令人哭笑不得的場面。 伊坂並不會讓殺人事件只是殺人而已，比起殺人手法、邏輯推理，伊坂更喜歡用「心境」、「道理」來敘述整個故事，這就是他特有的「碎碎念功夫」。 一起來看看伊坂筆下的殺手吧！ 水果二人組雖然書名是取自那位瓢蟲殺手，但我對「水果二人組」兩人的形象印象比較深刻呢！（後面兩個人都掛了還真是可惜…） 看他們兩個人對話，「咦？這不就是朋友之間的閒談嗎？」幾句無厘頭的話語、互相調侃的笑語，卻會不約而同地在面對危機時，展現出濃厚的默契。 就像是故事尾聲中，蜜柑在檸檬的包包中發現了一本自己一直推薦給他，他卻總是找各種理由推辭的小說；還有蜜柑雖然總是說著記不起來小火車的名字，卻在最後發現了檸檬留下的死後訊息，也知道檸檬平時喜歡的小火車的個性。 其實朋友不就是這樣，默默地記住對方的喜好，嘴巴上卻又不饒人，裝作不在乎一樣。就像蜜柑在檸檬死後才發現那本沒看完的小說，就像檸檬留下的死後訊息被蜜柑發現一樣，兩個人已經沒有機會表達對朋友的感情了。 雖然只是平凡的小事，但為了朋友而付出的感情，是一輩子都忘不了的真實 我很喜歡他們不言自明的默契，還有彼此之間深厚的信賴感。這是我自己的詮釋，或許每個人都對這二人組有不同的看法就是了。 還有裡面有很多橋段出現的湯瑪士小火車。不得不說這個卡通真的是太經典了。 這部卡通是艾屈萊牧師依照自己的經歷寫成了故事書，最後再翻拍成動畫卡通。這個卡通是許多90年代後的人童年必備電視節目之一，每次播放時間一到，就會準時打開電視收看，當時可是蒐集了很多火車頭哦！！！！！！！！！！！（不過現在都丟掉了，換我弟在蒐集哈哈） 喜歡湯瑪士的努力、胖總管的堅定和嚴格的管理、高登的善良熱心……，每次看到壞火車出現（通常冒黑煙的就是了）就覺得很氣憤，幸好故事都是好人打敗壞人的劇情。 伊坂還真是厲害，事前的蒐集資料做得很充足，竟然研究了那麼多火車頭的個性，進而創造出一個湯瑪士迷的角色，把火車頭的個性完美揉合在故事當中，從主角的口中配合著劇情娓娓道出。 瓢蟲瓢蟲的英文叫作「ladybirds」、「ladybugs」，所謂的 lady 就是聖母瑪利亞。為什麼會有這樣的由來呢？是因為傳說中聖母瑪利亞於人間所受到的「七苦」，瓢蟲的翅膀上那七個斑點，彷彿承受著瑪利亞的七苦般。 而這位殺手「七尾」正符合了這樣的取名。似乎把人間所有的疾苦都吸收過來了，不管做什麼事都一定會衰到極點。看到這裡也不得不佩服伊坂的功力，竟然將書名如此巧妙地連結起來。 七尾的「衰」，不僅為小說創造出許多歡樂，也讓故事多了一份綺麗的幻想，「好吧！那就當作是在承受瑪利亞的七苦好了。」 但更令我印象深刻的是，就算執行任務中，再怎麼不順利、再怎麼衰運上身，他仍會一件一件處理好眼前的變故和突如其來的危機。就如同瓢蟲背著七苦而飛，「七尾」在無奈調侃自己的不幸中，也會默默地把交代的事情處理好。 那位討人厭的國中生那位國中生，我邊看邊在心中暗罵：「這個小屁孩到底什麼時候才要死？」。 他屬於標準的自以為念過很多書，就用書中的知識恃才傲物，為所欲為的假高材生。 其實，在叛逆的青春時期，誰不會自我意識過剩呢？想要對這個世界說些什麼，用自己的價值觀生活。長大之後才猛然省悟，原來當初自己傻得可以。 人是會迎合其他人的動物當人類出重大決策時，往往會參考群眾的反應，而非出於自己的判斷。所謂的群眾效應正是如此。這並不是缺陷，在大部分的情況下，人們可以從不熟悉的環境中迅速掌握資訊、情報，以便做出相對應的行為。 但我們要思考的是，我們是否讓這樣的行為模式控制了我們呢？如果不去思考、只順應著現況改變的話，總有一天是要吃虧的對吧！ 所以那位國中生雖然氣焰囂張，卻仍然順利地控制人心。只要理解這些淺規則，人們就會在不知不覺中被巨大的力量給操控。 他真的那麼厲害嗎？還是只是大家聽信傳聞罷了類似的談話一定常常出現在日常生活中吧！「這門課超容易過的！！」「聽說那個老師很嚴格。」，然後就這樣口耳相傳，最後大家只依照傳聞中的狀況來選課而不是內心真正想要的。那麼，大學的自由、大學的自主學習，不就在這樣的謠言中被摧毀了嗎？別人說的話可以聽，但不要太相信。 結尾伊坂的厲害之處，在於他並不會只是單純描述劇情而已，還會將社會現象、人心做連結，在角色對話中顯現出來。這方面他也做了不少功課，恐懼、群眾行為、墨菲定律、國家……，伊坂把這樣沈重的話題搬到小說裡，卻顯得相對輕鬆，讓我們在這樣的氣氛中思考：啊！原來以前也有發生過類似的事情，我都是這樣的想法。 延伸閱讀：（參考書目） 群眾是可以掌握的：《隱藏的邏輯，掌握群眾行為的不敗模式》 盧安達大屠殺 你真的理解風險嗎？《販賣恐懼：脫軌的風險判斷》","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"透過 vuex 與 webpack dynamic import 動態載入 module","slug":"vuex-dynamic-import","date":"2018-08-19T16:00:00.000Z","updated":"2018-08-29T12:34:27.000Z","comments":true,"path":"2018/08/20/vuex-dynamic-import/","link":"","permalink":"http://kjj6198.github.io/2018/08/20/vuex-dynamic-import/","excerpt":"","text":"在最近的專案中用到 vue 來開發，而如果要管理比較複雜的資料流貨狀態，通常都是用 vuex 來當作 Single Truth of Source 的 store。在 vue 裡頭建立 store 時，都是把所有的 module 寫完後，再統一放到 vue 的 root 當中。 123456789101112export default new Vuex.Store(&#123; modules: &#123; profile, users, menus, list, food, product, todo, ... &#125;,&#125;); 這在一般的中小型專案中沒有什麼問題，不過一旦專案的架構變得越來越大，很容易讓 store 的資料結構變得越來越大且越來越複雜。而且 module 裡頭的 action, mutations 一多，難免會增加不少不必要的 bundle size，也不是所有的 module 都是在 app 初始化之後就要馬上使用到。關於這點 vue 透過了 webpack 的 dynamic import 機制動態載入 component。 在 vuex 當中則可以透過 store.registerModule 的方式在有需要的時候才將 module 放進 store，有了這個 API，我們也可以搭配 webpack dynamic import 的機制來減少 bundle size，並且盡可能地讓所有的操作變得簡單，在 app 初始化的時候，我們也只需要放入必要的 module 即可。 今天就來跟大家介紹如何透過 webpack dynamic import 的機制做到動態載入 module。 Webpack Dynamic Import在開始之前，我們先來講講 webpack dynamic import 的機制。一般而言在 webpack 要做到 code splitting 的方法有 設定多個 entry 透過 SplitChunks 這個 plugin 來拆分出不同的 chunk 透過 dynamic import 的機制引入程式碼 如果我們要在 component 當中動態引入對應的 module 的話，最方便的方法應該是透過 dynamic import 的機制。它能夠讓 import() 變成一個 return Promise 的函數，在 webpack build 的時候，會自動把這些檔案拆分出來變成其他 chunks，例如： 1import(/* webpackChunkName: \"CreateMenu\" */ './pages/NewMenu.js'), 在 webpack build 的時候會把 CreateMenu.js 拆出來變成一個 chunk。 12345Version: webpack 4.16.3Time: 112msBuilt at: 2018-08-20 14:49:40 Asset Size Chunks Chunk Names Profile.c943bf21.js 32.7 KiB Profile [emitted] Profile 官方提供了撰寫 comment 的方式來決定 chunk name，在 debug 的時候比較清楚目前引入的是哪個 chunk。 要搭配這個機制需要額外設定 babel 的 plugin Syntax Dynamic Import Babel Plugin。 知道了 webpack dynamic import 的使用方式後，我們來整合一下 vuex。 引入時機要透過動態引入 module 的方式，勢必要考慮幾個問題： 在什麼時候引入 module？ 如果發生錯誤導致無法載入該如何處理？ 什麼時候引入 module？當 component 可能需要 store 的狀態時載入（廢話）。所以我們可以這樣寫： 12345678910// component.vueexport default &#123; mounted() &#123; import('./modules/menus').then(menus =&gt; this.$store.registerModule('menus', menus.default)); &#125;, render() &#123; // your template &#125;&#125; 看起來很單純，不過很快就會遇到幾個問題： 如果在 render 的時候還沒有載入完成，那麽當 template 當中取用 menus 的資料時，會因為 undefined 而整個爆炸 如果在其他 component 已經載入過了，也會有錯誤 duplicate getter key: menus 為了修正以上的問題，我們稍微修改一下： 123456789101112131415161718192021// component.vueexport default &#123; data: () =&gt; (&#123; loaded: false &#125;), mounted() &#123; if (this.$store.state.menus) &#123; import('./modules/menus').then(menus =&gt; &#123; this.$store.registerModule('menus', menus.default); this.loaded = true; &#125;); &#125; else &#123; this.loaded = true; &#125; &#125;, render() &#123; return loaded ? h() : null; &#125;&#125; 看其來確實好多了，不過在每個需要 store 資料的 component 當中都做重複的事難免有些麻煩，我們把它拆出來變成一個通用的 HOC component。 12345678910111213141516171819202122export default function createMenuModule(Component, moduleName, dynamicModule) &#123; return Vue.component(`dynamicModule-$&#123;Component.name || &apos;Component&apos;&#125;`, &#123; data: () =&gt; (&#123; isLoaded: false, &#125;), mounted() &#123; if (this.$store.state[moduleName]) &#123; dynamicModule .then(module =&gt; this.$store.registerModule(moduleName, module.default)) // register module into store &#125; &#125;, render(h) &#123; return this.isLoaded ? ( &lt;Component &#123;...this.$props&#125; /&gt; ) : null; &#125;, &#125;);&#125;// MenuList.jsexport default createModule(MenuList, import(/* webpackChunkName: Menus */ &apos;./modules/menus&apos;)); // return a higher order vue component 這樣子一來，就可以安心地在有需要的時候引入對應的 module，而在 component 當中不需要每次都處理惱人的載入邏輯與處理。當然你也可以修改一下參數，讓這個 function 可以接收多個 module。當然要考慮的事情又變多了（怎麼做 module name mapping、多個 promise 處理等），但概念是類似的。 有需要時再載入剛剛的範例中解決了我們前面提到的問題，不過仔細一看可以發現，如果我們直接將 import() 寫在參數裡頭，好像不管怎樣都一定會發送請求耶！如果可以先查看 store 裡頭有沒有對應的資料再決定要不要載入呢？。 所以我們接下來要再修改一下函數，讓 store 可以當作參數傳遞。 123456789101112131415161718192021222324export default function createMenuModule(Component, moduleName, loader = () =&gt; Promise.resolve()) &#123; return Vue.component(`dynamicModule-$&#123;Component.name || 'Component'&#125;`, &#123; data: () =&gt; (&#123; isLoaded: false, &#125;), mounted() &#123; if (this.$store.state[moduleName]) &#123; loader() .then(module =&gt; this.$store.registerModule(moduleName, module.default)) // register module into store &#125; &#125;, render(h) &#123; return this.isLoaded ? ( &lt;Component &#123;...this.$props&#125; /&gt; ) : null; &#125;, &#125;);&#125;// MenuList.jsexport default createModule(MenuList, 'menus', &#123; loader: () =&gt; import('./modules/menus'),&#125;) 把最後一個參數當作 function 傳入就好了，當然也可以在 loader 上做更多處理（error handling, error logging, GA…），讓整個 component 更加穩固。如果要做得更仔細一點，第三個參數也可以傳入像是 timeout, LoadingComponent 的機制，讓這個 higher order function 更加實用。（不過大部分的情況下都是希望 module 越快載入越好） 錯誤處理雖然我們希望 promise 順利載入，天下太平。但實際上有太多因素會影響 module 的載入。大部分是網路不穩或中途離線等等，因此我們需要一個錯誤處理機制。 在 mounted 的時候我們可以利用 catch 來處理錯誤，並且設定一個新的 data 來記錄 error 的資訊。 12345678910111213141516171819202122232425262728293031export default function createMenuModule(Component, moduleName, loader = () =&gt; Promise.resolve()) &#123; return Vue.component(`DynamicModule-$&#123;Component.name || 'Component'&#125;`, &#123; data: () =&gt; (&#123; isLoaded: false, error: null, &#125;), mounted() &#123; if (this.$store.state[moduleName]) &#123; loader() .then(module =&gt; this.$store.registerModule(moduleName, module.default)) // register module into store .catch(err =&gt; &#123; this.error = err sendToLoggingService(err); &#125;) &#125; &#125;, render(h) &#123; if (this.error) &#123; return h('pre', this.error); &#125; return this.isLoaded ? ( &lt;Component &#123;...this.$props&#125; /&gt; ) : null; &#125;, &#125;);&#125;// MenuList.jsexport default createModule(MenuList, 'menus', &#123; loader: () =&gt; import('./modules/menus'),&#125;) 當然也可以善用 vue 的 errorCaptured，或是實作一個 ErrorBoundary 元件來記錄這些資訊。 什麼時候要 unregister什麼時候要 unregister 呢？在前半段當中我們處理了載入的部分，但卸載的話並無法直接在 component unmount 實作，因為我們並不知道是否有其他元件有存取 store 的資料，所以除非是相當確信只會有單一元件使用，不然不要隨意 unregisterModule。 其他在 react 當中沒有那麼方便，不過有 react-loadable 可以用。但 redux 沒有類似 registerReducer 的 API，必須自己實作。如果有使用像是 redux-observable 或是 redux-saga（動態載入 epic 或是 saga） 的話，也可以透過類似的方式實作。 結論比起 react 與 redux，vue 的生態系當中對非同步載入的支援更好（更容易實作）。當然引入這樣的機制難免會提高 debug 的複雜度，雖然有效減少了 bundle size。但也要搭配各種機制才能讓整個 app 運行的更加穩固。 本文試著提出在動態載入時可能遇到的問題以及解決方式，希望可以幫助到正為 bundle size 所苦的開發者們。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"},{"name":"vue","slug":"前端/vue","permalink":"http://kjj6198.github.io/categories/前端/vue/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://kjj6198.github.io/tags/webpack/"},{"name":"vuex","slug":"vuex","permalink":"http://kjj6198.github.io/tags/vuex/"},{"name":"vue","slug":"vue","permalink":"http://kjj6198.github.io/tags/vue/"}]},{"title":"make 與 new 的差別","slug":"golang-make-and-new","date":"2018-08-15T10:00:00.000Z","updated":"2018-08-17T15:48:51.000Z","comments":true,"path":"2018/08/15/golang-make-and-new/","link":"","permalink":"http://kjj6198.github.io/2018/08/15/golang-make-and-new/","excerpt":"","text":"在 golang 有兩個保留字 make 與 new，也是剛開始學習 golang 的時候容易搞混的地方，這邊做個簡單的筆記。 newnew 可以用來初始化泛型，並且返回儲存位址。所以通常我們會用指標變數來接 new 過後的型別。特別要注意的是，new 會自動用 zeroed value 來初始化型別，也就是字串會是&quot;&quot;，number 會是 0，channel, func, map, slice 等等則會是 nil。 因為這個特性，如果我們對 map 做以下的操作的話，會出現 panic: assignment to entry in nil map 12345func main() &#123; people := new(map[string]string) p := *people p[\"name\"] = \"Kalan\" // panic: assignment to entry in nil map&#125; 因為初始化的 map 會是 nil map，不像其他的 primitive type 一樣有預設值。 如果用 struct 做初始化，也可以直接用 &amp; 代表指向的位址，下面兩個寫法效果是一樣的： 123456789type Person struct &#123; Name string Age int&#125;func main() &#123; p := &amp;Person&#123;&#125; p := new(Person)&#125; 好處是上面的 Person 也可以根據自己想要傳入的值額外再做設定，但 new 則是全部的 field 都會直接塞 zeroed value。 makemake 與 new 不同，是用來初始化一些特別的型別，像是 channel, map, slice 等等。另外特別要注意的是 make 並不會回傳指標，如果要拿到指標，就要考慮用像是 new 的方式來初始化型別。 12345func main() &#123; receiver := make(chan string) // 初始化 channel，但不回傳指標 person := make(map[string]string) people := make([]string, 100) // 初始化長度為 100 的字串陣列&#125; 還是要再度強調一次，make 不會回傳指標！下面這段程式碼會噴錯： 1234func main() &#123; person := make(map[string]string) fmt.Println(*person) // invalid indirect of person&#125; 結論make 與 new 在剛開始學習 golang 時容易搞混，有時參數要傳入指標時也會一不小心就用 make 來傳，這時候知道這兩者的區別就相當重要。 更多閱讀 https://golang.org/doc/effective_go.html#allocation_make https://golang.org/doc/effective_go.html#allocation_new","categories":[{"name":"golang","slug":"golang","permalink":"http://kjj6198.github.io/categories/golang/"}],"tags":[]},{"title":"再談生日悖論（Birthday Paradox）","slug":"birthday-paradox","date":"2018-05-01T16:00:00.000Z","updated":"2018-05-09T15:54:09.000Z","comments":true,"path":"2018/05/02/birthday-paradox/","link":"","permalink":"http://kjj6198.github.io/2018/05/02/birthday-paradox/","excerpt":"","text":"前言生日悖論是個剛開始上統計學時，老師很喜歡拿來唬弄學生的招式。通常老師會徐徐從錢包拿出 100 元，並且問學生，在教室中有沒有兩個人同一天生日？ 直覺上，我們可能會以為機率很低。不過事實上只要超過 23 人，2 人同一天生日的機率就有 50% 以上。 一部分的原因是我們將問題「其中兩人同一天生日」與「其中有人跟你同一天生日」聯想在一起，但兩者的機率是完全不一樣的。 「其中有人跟自己同一天生日」的機率為 1365\\frac{1}{365}​365​​1​​，不過「其中兩人同一天生日」的話因為範圍變廣了，機率自然也會增加。不過仍然有些違反直覺，照理來說，應該是呈現線性成長的才對吧？但事實上只要超過某個值，這個機率就會快速上升，我們下面會談到。 解法補集我們可以透過補集的方式來計算至少有兩人同一天生日的機率，也就是用 1 減去所有人生日都不相同的機率。那麼要怎麼計算呢？我們先來想想兩個人生日不同的機率：365365×364365\\frac{365}{365}\\times\\frac{364}{365}​365​​365​​×​365​​364​​（第一個人有 365 天可以選，第二個人則是 364 天）；接下來在想想三個人生日不同的機率 365365×364365×363365\\frac{365}{365}\\times\\frac{364}{365}\\times\\frac{363}{365}​365​​365​​×​365​​364​​×​365​​363​​。看出來了嗎？如果有 n 個人，則機率為365365×364365×363365×...n−1365\\frac{365}{365}\\times\\frac{364}{365}\\times\\frac{363}{365}\\times...\\frac{n-1}{365}​365​​365​​×​365​​364​​×​365​​363​​×...​365​​n−1​​ 所以我們要求算的機率為：P=1−(364365×363365×...n−1365)≥0.5P=1-(\\frac{364}{365}\\times\\frac{363}{365}\\times...\\frac{n-1}{365}) \\geq 0.5P=1−(​365​​364​​×​365​​363​​×...​365​​n−1​​)≥0.5化簡一下： 我們可以利用1+x&lt;ex1+x\\lt e^{x}1+x&lt;e​x​​的特性，進一步修改不等式： 從這邊可以觀察到，因為可以用自然指數來逼近，所以機率的成長也會隨著人數的增長而呈現指數變化。 結論很多時候我們學習數學常常會被公式跟奇形怪狀的題目耍得團團轉，卻一直沒有思考公式背後真正的含義、如何證明出來的，或者更重要的，學這些數學到底是為了解決什麼問題？","categories":[{"name":"雜談","slug":"雜談","permalink":"http://kjj6198.github.io/categories/雜談/"}],"tags":[]},{"title":"2017 年度總結","slug":"2017-yearly-review","date":"2017-12-31T16:00:00.000Z","updated":"2018-05-05T16:49:42.000Z","comments":true,"path":"2018/01/01/2017-yearly-review/","link":"","permalink":"http://kjj6198.github.io/2018/01/01/2017-yearly-review/","excerpt":"","text":"哈囉大家，2018 新年快樂 🎉。 昨天和女友選擇過一個很平凡的跨年，早上各自做彼此的事，晚上在家裡開伙吃飯，再一起跑步，最後一邊寫程式一邊看紅白，結束了 2017 年的最後一天。 每年年底都會試著回想以前做過的事，但如果沒有加以記錄，好像只能浮現一些零碎的片段 或是不完整的訊息，今年開始做了很多統計，試著記錄每筆開銷、統計自己寫的文章、Github contribution、睡覺時數等等。雖然這些事情看起來的確就像流水帳，但是在年底統計時，這些資料就能夠發揮用處。 有鑑於此，在昨天試著把一些整理到的資料彙整成網頁，結果發現一天要把這些東西整理完還是太難了，結果就用到稍早才完成。很多想要的效果跟排版都不是那麼理想，原本還想要做個煙火，但來不及只能做個轉場星星。 2017 年度總結 | Yearly Report 我的 2017 年度總結。在 2017 年發生了很多事（最近幾年過得實在很精彩），以至於想要好好地把今年發生跟學習的事情一一記錄下來。這次比較不一樣的是，我花了一天做了網頁，整理這一年裡的所有\b發生的大小事，以及一些我覺得很有趣的資料。 https://kjj6198.github.io/yearly-report Medium今年在 Medium 上總共發佈了 74 篇文章，其實閱讀人數一直沒有很理想，不知道是不是標題不夠犀利還是文筆不到位。或者 Medium 的中文使用者本來就不多，不過就算沒有多少人看我想我還是會繼續寫下去的。 1. 自學四年通過日檢 N2 心得 — 7.9K 自學四年通過日檢 N2 心得 – 日語八百屋 – Medium自學四年通過日檢 N2 心得 – 日語八百屋 – Medium 這篇文章會分成兩部分，第一部分談談自己對學習語言的看法，第二部分則是介紹一些我在學習日文時常用的學習資源。 這篇文章不會提到答題技巧或是短期衝刺的秘訣，原因很簡單，日檢等考試都可能會更改制度或題型，未來可能主流的考試也並非 JLPT，過度追求答題技巧可能只會造成反效果而已。 https://medium.com/日語八百屋/自學四年通過日檢-n2-心得-2e91435250c9 今年通過了日檢 N3, N2，算是完成了自己的目標之一。 這篇文章當時有分享在 facebook 上，所以觀看人數最高，到現在每週仍然有破百的瀏覽次數。我知道自學四年並不是一個很短的時間，但這裡面並不是在討論一些如何應試的心得，而是把自己一路從完全不會，透過自學的方式一路走到現在的歷程。 到日本工作是我的目標之一，好奇日本文化也好、想窺探日本人生存的方式也好，這些都是我未來想要體驗的事情之一。 2. 前端面試總結 — 4.6K 前端面試總結 – De-Magazine – Medium前端面試總結 – De-Magazine – Medium 國立科大資管系，目前已經有兩年工作經驗。平時專注在前端開發，接觸 React、Redux 開發約兩年的時間。除了一般的前端「工程」之外，自己也很喜歡畫面的實作與互動，同時也有在自己的小專案當中練習後端的知識，像是 AWS、Lambda、nodejs、資料庫、機器學習等等，不過最熟悉的還是前端相關。 一般的公司通常在信上附上地址，不過樂天市場會把一些重要的地標標示出來，例如 XX 號出口、在 XX… https://medium.com/d-d-mag/前端面試總結-dfe8bf07bfe1 今年離開了時刻旅行，到了 17 直播工作。期間也面試了不少公司，我把這些心得整理成一篇文章。前端是繼 JAVA 之後，開始學習的領域之一，當時電腦記憶體只有 2G，任何一個 IDE 開下去都會當掉，因此輕薄短小的 HTML 與 CSS 就成為了首選，結果就一路走到現在了。 最近也試著往更多元的方向前進，WebGL、Canvas、資料視覺化，都是我希望接觸的領域，也希望自己能夠更輕易地掌握資料流處理跟互動。 3. 淺談降維方法中的 PCA 與 t-SNE — 1.5KPCA 是在做機器學習時時常使用到的降維方法，但是因為是線性轉換的關係，在變換過程中會喪失太多的訊息。 這時候可以透過 t-SNE 來改善。t-SNE 是基於 T 分佈的演算法，透過計算 Kullback-Leibler Divergence（KL）的方式來降維，效果會比 PCA 更好，但速度比 PCA 慢很多。 4. 日語學習資源總整理自學日文會碰到許多困難與挑戰，其中之一就是找到優質的學習資源。我自己是以看書為主、網路資源為輔的方式學習，洋洋灑灑寫了很多筆記。 5. 日本服務業用語整理了一些常見的日本服務業用語。之前在打工的時候用上幾次。 6. 狂歡雙 11 — 祝我生日快樂生日剛好在雙 11，每次生日都可以搶便宜買東西給自己（雖然也很少在買）。這篇文章整理了我在 2017 年做的事情以及一些體悟。 7. 為什麼台灣人無法抵制全聯這是在全聯過勞死新聞出來後所寫的一篇文章，並不是每個人、家庭都有足夠的成本來抵制全聯。而且全聯對於低收入戶家庭有每個月固定額度的補助，這對一個收入不高的小家庭來說是個不無小補的幫助。 8. 淺析幾個 ramda 當中的 APIramda 是個相當好用的 functional programming 函式庫，這篇文章介紹了一些好用卻不常被提到的 API。 9. 你可能不知道的 Sass 技巧Sass 除了 nested class 和變數之外，其實還有很多好用的 function 跟使用方式。像是優雅地管理 z-index、更容易地取用變數、錯誤處理等等，都有不錯的效果。 10. 深入探討 redux 與 react-redux使用 React 也將近兩年多了，從 0.1x 到現在，整理了 redux 以及使用 react-redux 的技巧。 Medium 是個寫作、閱讀體驗都非常舒服的平台，雖然最近很多技術文已經出現了 README level 的現象，不過整體來講還是很喜歡。尤其是圖片排版跟網站 parsing，省了不少功夫。後台的統計也很清楚，每個禮拜還會送 e-mail，如果要做統計相當方便。 不過仍然有幾個缺點： 不支援 code block，如果要 highlight 只能自己放到 gist 上，不過 gist 在手機 app 上無法觀看。 不支援 LateX，如果要數學公式還要自己弄成圖片 關於第一點，因為 Medium 本身有發佈文章的 API，所以就自己寫了一個 lambda 把 code block 轉成 gist。 在 Medium 上還有很多文章，有興趣的話可以到 https://medium.com/@Shurado 看看。 undefined undefined undefined undefined Blogblog 主要寫一些技術文章跟小說心得，大部分都跟 Medium 同步。 https://kjj6198.github.io/ 日語八百屋這是我在今年三月左右創立的週刊，目前已經累積 40 多期。未來還會繼續走下去的，這個網站每個月會花費 1,020 的維護成本（資料庫、S3、cloudfront 等等）。 目前已經累積有 41 期週刊；總共有 219 篇文章與筆記；共寫了 71,115 個字。將近一年下來累積的成果，自己回想起來還是覺得很感動。這並不是什麼殺手級的應用，只是很單純的週刊而已。用一句一拳超人最愛說的話，就是興趣使然。 這一年也累積了不少讀者的回饋，列出幾個： 內容多元有趣！！！每周都很期待收到信^0^ 每週一中午的休息時間，很期待讀喔 ❤ 加油 ! 這個活動很有意義。 我從一開始就訂閱了 每期都有看！ 覺得你寫的很用心很好 讓我更認識日本文化 希望你能繼續做下去 我會一直支持哈哈哈哈 當然現在工作繁忙，有時難免會想要偷懶一下。 如果你也對日本文化、日語學習、旅行有興趣，歡迎隨時投稿。因為目前仍然是沒有收入的狀態，我能回饋的只有： 你的分享會被寄送到 1300 多位訂閱者的信箱 你的分享會被署名 你的分享會被放在日語八百屋的 medium 上 你的分享會放在日語八百屋的官網上 跟我當好朋友 以下是日語八百屋的相關資訊： Medium 官方網站 粉絲專頁 Instagram IT 鐵人賽佳作 — WebGL 與 Three.js 初探這一次想要挑戰比較不同的主題，於是選了一個一直想要好好研究卻沒有實際行動的 WebGL 和 Three.js。剛好下學期還開了一堂電腦圖學的課，要用 OpenGL 實作。 雖然還沒辦法到 production ready 的程度，不過從中瞭解到很多好玩的技術，像是矩陣轉換、線性內插、double buffering、光照等等。 Github今年一樣也寫了很多 code，不過沒有很認真地分析，只用 Github API 抓了一些資料。 2017 年有 1,205 個 Contribution；寫了 889,516 行程式碼；刪了 357,516 行程式碼。（備註：因為有時候忘記 ignore bundle 的代碼以及 node_modules，所以後面兩項數據有蠻多灌水的。） Daily Life在生活上有許多有趣的數據，今年記錄了自己平均睡眠時間（從五月初開始）、iPhone 裡面存的一些資料、收支等等，接下來看看這些資料吧。 平均睡眠時數：5.7 小時 最近實在太晚睡了，之前有一陣子曾經好轉到規律的生活，但最近事情一直做不完，然後又拖延，所以只好靠熬夜彌補。今年希望可以改善 每日走路步數： 6,716 步 這個數據看起來可能沒什麼感覺，不過這樣換算下來一年至少走了 245 萬步耶，希望薪水可以跟走路步數一樣高XD。 慢跑累積里程：73.8 公里 這應該是丟出來看會被笑到翻掉的數字。我從大概 2 月底左右決定好要要跑步，結果還是很半吊子。希望 2018 拿出來的數字比較好看一點。 旅行今年去了大阪、京都、奈良、東京，去日本真的很便宜。 收支今年有在記帳軟體上的支出為 223,935，至於收入不太好看就不拿出來獻醜了。 日劇今年看了很多日劇，在這邊順便總結一下，以下按照喜歡順序排名： 1. 四重奏（カルテット）四重奏對於人生的描寫真的太讚了。故事是描寫一群業餘的樂手，各自隱瞞著的人生故事。每個人都有一點性格上的缺陷，就像團名「甜甜圈」那樣。我很喜歡開場高橋一生的唐揚炸雞+檸檬那段。 唐揚炸雞能洗嗎？ 2. 派遣女醫第五季（Doctor-X）雖然前幾季也是在今年看完就是了。西田敏行跟遠藤憲一是兩大賣點，演技相當精湛又逗趣。 我從中學到最多的是大門的敬業態度，他最常掛在嘴邊的： 私、失敗しないので（我不會失敗） 對於病人來說，只要手術失敗就很有可能發生生命危險，因此每次的開刀都會全力把任何可能發生的事都考量進去。也才能每次都抱著信心地說著「我不會失敗」這種信心爆棚的台詞。 3. 你只想住在吉祥寺嗎？主角是一對住在吉祥寺，卻常常推薦客人放棄吉祥寺的兩姐妹。畢竟這裡高居日本人想住的城市第一名，要找到一個適合的房子也挺困難的。 這部日劇一集只有 30 分鐘，非常適合在中午休息時觀看。 每一集描繪一個故事，這些故事都是小市民的真實生活刻畫，為了改變生活，決定從換新房子開始。裡頭並不會苛刻地要求你努力向上，而是讓房屋成為你發洩情緒的出口。 工作已經很不容易了，就不要再把自己逼得太緊。請一天假小酌一番、泡個澡，明天再來好好面對生活。深刻感受到生活的重要性。在工作的同時別忘記了，自己是個活生生的人、不是奴隸，有血肉之軀、被打會哭，沒有必要讓工作壓垮自己。 「公司就是這麼渺小的東西，根本沒有必要為這麼渺小的東西傷心」（会社なんて小さいもんだよそんなもんで傷つく必要なんてない） 4. 房仲女王最近剛好搬家完畢，看了這部之後，深深感受到房子對一個人、一個家庭的影響是多麽巨大的。這部日劇主要是在描寫一位房仲業者賣房子的故事。 每一集都會賣一棟房子，她的名言就是：「沒有我賣不掉的房子。」，我覺得如果能夠把工作做到這種程度的自信，是一件非常專業的事情。 而說到的秘訣，她的說法很簡單 「我負責的不是一棟房子，而是客戶的整個人生」。 不過在台灣就另當別論了。 5. 過保護的加穗子（過保護のカホコ）這個取名其實蠻有巧思的，過保護（かほご）跟カホコ（主角名稱）剛好是發音相近。 如同片名，劇情在敘述一位被家人過度保護的媽寶，在日常生活中的大小事全部仰賴父母幫忙，鮮少遇到挫折，最後因為愛情而逐漸練習獨立。 這部劇從每個角度切入都能引人省思，像是家長們的「我是為了你好」的大旗道德綁架，不讓孩子們走自己的路；而在溫室中長大的孩子們，或許會思考這難道是我一生要走的路嗎；最後愛情的滋潤下，加穗子逐漸走出溫室，開始練習獨立。 高畑充希演這種無辜可愛的女孩演得相當出色。 6. 外貌協會（人は見た目が１００パーセント）這一部日劇如標題所示，描述三個因不會打扮而無法像其他女孩一樣受歡迎，或是在職場上不受重視，聯誼時也無法大放異彩的女生。 為了讓自己能夠更受歡迎，所以開始練習化妝、聯誼技巧等等，逐漸探討女孩們從完全不會打扮的ブス變成光鮮亮麗的焦點。 我不是女生，很難想像為了讓自己變得更受歡迎而努力保養的拼勁。不過從這部劇看來，的確是件很辛苦的一件事啊。 （吐槽：女主角明明就很正） 7. 民眾之敵（民衆の敵）雖然這部劇是在講政治，但比起一般的政治劇來說劇情是在太過清新以及理想化了。女主角因為想要賺更多的錢，決定選議員，最後變成市長。對於習慣政治劇的觀眾來說恐怕很難符合胃口，不過當成小品來看的話其實還不錯，至少不用到處濺血跟吸毒。 不過裡頭仍然點出了一些現實與理想的差距，例如政治家可能常常遇到的，為了某些人的福利，可能要犧牲另外一些人的權益。 或者只專注於眼前的問題，卻沒發現背後有更大的成因等等。 只專注於讓身邊的人幸福 這是女主角很愛說的一句話，雖然看起來短視近利，但我覺得這倒是一個做決策時很好的辦法。因為要讓所有人都幸福實在太困難了，所以就乾脆讓身邊的人幸福就好。看起來很偽善對吧？在現今的世道下如果救了一個人卻沒有救其他人就會被批評偽善。 （這部劇也有我最愛的高橋一生演出。） 電影今年看的電影都是日本電影居多，以下挑幾部印象深刻的： 1. 不幹了！我開除了黑心公司這部電影的預告相當吸引我，主角是一位業務，過著平凡的小市民生活，每天承受著壓力、辱罵、道歉中過活。 人究竟是為了什麼而工作的呢？ 為了生活不得不低頭工作，忍受各種不合理的對待與委屈，像劇中的男主角一樣，一度找不到生存的意義企圖跳軌自殺。在台灣這樣子的意識型態可能沒有那麼嚴重，不過在日本通常一進入公司，就會在公司待到退休不會再換工作。不過最近受到經濟泡沫的影響，終身雇用制也正在逐漸崩壞當中。不過你我都知道，台灣仍然有許多需要改進的地方，像是之前發生的全聯過勞死的新聞。 這讓我想到在「你只想住在吉祥寺嗎」其中的一幕。 公司就是這麼渺小的東西，根本沒有必要為了那麼渺小的東西而難過。 如果這份工作真的讓你感受不到熱忱的話，或許該停下來思考一下工作的意義了。 2. 我想吃掉你的胰臟（君の膵臓を食べたい）在先前的週刊有和大家分享過這部小說以及劇情，電影版也在最近上映了。 聽說哪個身體哪個器官不好，就會吃動物的某個器官來補 劇情似乎有點老套，女主角患病、個性活潑大方、意外認識個性陰暗的男孩、兩人開始一段邂逅、鋪陳幾個灑狗血的橋段。不過名字相當吸引人，許多人應該都會被這個有點奇怪的標題給吸引吧。 雖然如此，實際上看到電影時還是覺得挺感動的，尤其是女主角活潑的個性，相當吸引人。額外一提，這次看完電影也讓我了解到原來分類書籍是相當深奧的一門學問啊 解憂雜貨店（ナミヤ雑貨店の奇蹟）東野圭吾是我相當喜歡的作家之一，除了純推里之外，他的作品也涵蓋了許多主題，像是伽利略系列、物理學湯川等等，還有一些短篇作品（像黑笑、毒笑小說），或多或少在描寫日本社會現象等等。 解憂雜貨店這種療癒小說，第一次看時是被封面給吸引住的。看完果然也很佩服東野圭吾組織架構的能力，以及多個伏線最後終於完整拼湊的痛快。的確有些劇情太過理想，不過東野圭吾也不是那種只會丟出有夢最美這種漂亮話而已，仍然有許多故事是懷抱理想最後被現實打敗的人。 另外命名上也相當具有巧思。主角浪矢（ナミヤ）爺爺跟煩惱（悩み（なやみ））剛好順序調換了，這大概是學日文的人理解的會心一笑吧。 摘錄最後的台詞： 正因為是白紙，才能盡情揮灑。謝謝你最後留給我如此精彩的難題 白紙なのだから、どんな地図だって描けます。全てがあなた次第なのです。最後に素晴らしい難問をいただけたこと、感謝申し上げます。 總結2017 年發生了很多事，如果不是今天特別用這種方式整理，大概沒辦法體會到吧。看到這些數字都有一種幸好當初有記錄下來的感覺，以後或許也會用這樣的方式來回顧自己年度總結吧。 在 2018 還有很多想要達成的事，如果要用一句話總結，大概就是 我想做一個有用的人吧。 如果對我的文章有興趣，歡迎到以下連結追蹤： Twitter Medium Blog","categories":[{"name":"雜談","slug":"雜談","permalink":"http://kjj6198.github.io/categories/雜談/"}],"tags":[{"name":"2017","slug":"2017","permalink":"http://kjj6198.github.io/tags/2017/"}]},{"title":"Array.sort 淺析","slug":"array-sort","date":"2017-12-14T16:00:00.000Z","updated":"2017-12-17T06:22:45.000Z","comments":true,"path":"2017/12/15/array-sort/","link":"","permalink":"http://kjj6198.github.io/2017/12/15/array-sort/","excerpt":"","text":"Array.sort 淺析這篇文章不是談論在 Javascript 原生的 sort 要注意的事項。例如： 12[1, 2, 3, 8, 20, 30, 11].sort()// [1, 11, 2, 20, 3, 30, 8] 因為預設的 sort 方法會把值轉為 String，並按照 char code 做排序，所以才會出現上面的結果。 今天要來探討 Javascript 的 sort 背後的實作方式。 從 V8 的實作當中，我們可以看到幾個事實： Array 的 sort 是用 quick sort 排序 在陣列數量小於等於 10 的時候，使用插入排序。 為了簡化 V8 中的代碼，這邊撰寫一個簡單的快速排序代碼：（僅供參考） 1234567891011121314151617181920212223function quickSort(arr, p, r) &#123; if (p &lt; r) &#123; var q = partition(arr, p, r) quickSort(arr, q - 1, p) quickSort(arr, q + 1, r) &#125;&#125;function partition(arr, p, r) &#123; var x = arr[r]; var i = p - 1; for (var j = p; j &lt; r - 1; j++) &#123; if (arr[j] &lt;= x) &#123; i += 1; var tmp = a[j]; arr[j] = a[i]; arr[i] = tmp; &#125; &#125; var tmp = arr[r]; arr[r] = a[i + 1] arr[i + 1] = tmp;&#125; 深入探討：為什麼是快速排序？快速排序法的實現重點在於如何選擇一個相對好的 pivot，來避免最壞情況的發生。在實際的情況當中，輸入的資料並不一定是隨機的，所以在實務上都會使用 random 的方式來選擇 pivot。 第一個問題是，為什麼 V8 使用快速排序？雖然快速排序的平均時間複雜度可以達到 $O(nlogn)$，但是最壞情況也有可能達到$O(n^2)$。同時，快速排序並不是一個穩定的演算法，也就是兩個同樣值的資料，在排序之後位置可能會不同。 為什麼不用合併排序？合併排序簡單可以分為兩大步驟，先把 array 分解後再調用 merge 不斷合併。不僅平均、最壞、最好時間複雜度都可以達到$O(nlogn)$，演算法本身也是穩定的，為什麼不採用呢？ In-place我們在 quick sort 當中，並不需要對 array 做合併的動作，也就是整個演算法可以不另外耗費空間完成，而 merge sort 需要 $O(n)$ 的空間。因此儘管快速排序有上述的情況發生，但在實務上他仍然是一個相當好的選擇。 我們可以透過 randomize 的方式（關於如何隨機選取 pivot，實際上還能夠寫一大篇文章來解釋），來避免 $O(n^2)$ 的情形發生。 Stable不過儘管如此，我們還是沒辦法解決 stable 的問題，雖然在大部分的場景當中可能並不重要（畢竟資料排序通常都是由後端實作），不過如果真的碰到時，這就是非常重要的考量了。 並不是每個瀏覽器的實作都是用 Quicksort 插入排序如果仔細看一下 V8 的原始碼，會發現這一段： 123456while (true) &#123; // Insertion sort is faster for short arrays. if (to - from &lt;= 10) &#123; InsertionSort(a, from, to); return; &#125; 咦，為什麼在陣列數量小於等於 10 的時候要用插入排序法呢？ 要理解原因，我們先回想一下插入排序的原理。插入排序跟撲克牌整理牌的方式很像，每次拿起一張牌，找到一個最適當位置放入，每次的要插入的牌組都是已經整理好的，可以達到原址排序。 123456789101112function insertionSort(arr) &#123; for (var j = 1; j &lt; arr.length; j++) &#123; var key = arr[j]; var i = j - 1; while(i &gt;= 0 &amp;&amp; arr[i] &gt; key) &#123; arr[i + 1] = arr[i] i = i - 1; &#125; arr[i + 1] = key; &#125; return arr;&#125; 插入排序雖然跟氣泡排序擁有相同的時間複雜度，不過在交換次數上有很大的不同，氣泡排序有$O(n^2)$的交換次數，而插入排序最多只需要$O(n)$。 回到最剛開始的問題，為什麼在陣列數量小於等於 10 的時候要用插入排序法呢？ 對於小數量的陣列而言，如果已經排序好，或是相當接近有序的陣列，插入排序法是唯一可以達到時間複雜度$O(n)$的演算法。這是相當有效率的一件事。 結論因為在工作上需要排序，因此開始深入理解了原生的 sort 在背後做了哪些事情。除了要注意 js 會預設轉為字串比較之外，在處理資料量大的陣列時，理解背後的實作方式就顯得相當重要。 同時我們也了解到，不同的排序演算法都有其適合的場景，在使用 sort 的時候要記得： Quick sort 在實務上通常有最好的結果，但要注意 quick sort 並不是穩定的演算法 Merge sort 雖然能夠達到 $O(nlogn)$ 的時間複雜度，但是需要額外 $O(n)$ 的空間做 merge Insertion sort 在小數量的陣列排序上有不錯的效果，最好情形可以在$O(n)$ 比較完成。","categories":[{"name":"演算法","slug":"演算法","permalink":"http://kjj6198.github.io/categories/演算法/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://kjj6198.github.io/tags/algorithm/"},{"name":"sorting","slug":"sorting","permalink":"http://kjj6198.github.io/tags/sorting/"}]},{"title":"如何設計 user friendly 的 table","slug":"user-friendly-table","date":"2017-11-23T16:35:38.000Z","updated":"2017-12-17T06:39:17.000Z","comments":true,"path":"2017/11/24/user-friendly-table/","link":"","permalink":"http://kjj6198.github.io/2017/11/24/user-friendly-table/","excerpt":"","text":"認清一件事實，table 是拿來看，不是被當作絢麗的視覺使用的 最近在後台頻繁有使用表格的需求，如何設計對使用者良好的 table 是一項挑戰，尤其在資料筆數多、欄位多的情況下，使用者很容易就會被額外的元素吸引。 而在現代 div 排版盛行的影響下，使用 table 很容易就被當成二流的前端工程師。 其實對於呈現資料上，table 仍然是個相當有效的排版方式，且他們具有的特色可以幫助我們排版更加輕鬆。 HTML 中的 table在 HTML 當中 table 由幾個標籤組成： thead：定義表頭標題 tr：定義表頭的 row th：定義標題 tbody：定義表格內容 tfoot：定義表格的結尾部份 盡量不要拉滿整個 table 寬度讓 table 當中內容自行決定寬度。如果拉滿寬度的話，使用者很容易因為兩個 column 之間的距離間隔太長而不容易閱讀。 選擇顯示欄位如果資料的欄位太多（例如超過 10 個以上），可以透過 checkbox 等方式讓使用者選擇希望顯示的欄位。 加入 &lt;caption&gt;在表格當中可以加入 &lt;caption&gt;，方便標注表格的 title。例如： 123456789101112131415161718192021&lt;table&gt; &lt;caption&gt; &lt;h4&gt;出帳列表&lt;/h4&gt; &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;日期&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;人口&lt;/th&gt; &lt;th&gt;年紀&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;2017-11-11&lt;/td&gt; &lt;td&gt;kalan.chen&lt;/td&gt; &lt;td&gt;12375&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 透過 caption-side: top | bottom 可以做定位。 123caption &#123; caption-side: top;&#125; 移除不必要的顏色與 border 雖然乍看之下色彩繽紛，但對於使用者來說，border 和背景顏色都可能造成視覺雜訊，雖然是看似貼心的設計，但可能難以找到想要的資料。 使用簡單的灰階做辨識，並消除（或者調淡）邊界的顏色，去除不必要的視覺雜訊，讓使用者更容易找到資料。 表頭跟內容對齊一般來說文字會靠左對齊，而數字則是靠右對齊。 提供簡單的排序與搜尋對於後台來說，使用者可能會頻繁搜尋表格內的資料，一個方式是每次都用 ajax 請求更新資料，或者在前端實作。我們可以提供簡單的排序功能，方便使用者快速地找到資料，或是提供簡易的搜尋功能。 題外話：排序其實可以直接使用 element.appendChild 來做，如果 appendChild 的節點已經出現在 parent 當中，會直接替換位置而不會加入一個新的 node。 See the Pen table sort by 愷開 (@kjj6198) on CodePen. 考慮簡單的 @print對於像是出帳系統、記錄等等，營運人員除了在網頁上觀看外，也有可能需要將表格內容列印下來，這時可以使用 @media print 的方式處理列印的細節，例如 font-size 的設定可能要用 pt 表示、將顏色改為黑白、縮短間距等等，都是需要考慮的細節。 reponsive傳統的 table 在做手機版支援時，通常是使用水平滾動的方式來顯示。不過在手機上頻繁滾動對使用者來說仍然不是個理想的操作。 可以利用 data attribute 搭配 CSS 的 pseudo 完成。在手機上，我們將每一個 row 的顯示改為垂直。像這樣： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;table&gt; &lt;caption&gt;付款紀錄&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;方案內容&lt;/th&gt; &lt;th&gt;金額&lt;/th&gt; &lt;th&gt;數量&lt;/th&gt; &lt;th&gt;贊助日期&lt;/th&gt; &lt;th&gt;贊助狀態&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td data-label=\"方案\"&gt;一枝草一點露，一人一百支持 TingChi&lt;/td&gt; &lt;td data-label=\"金額\"&gt;$100&lt;/td&gt; &lt;td data-label=\"數量\"&gt;1&lt;/td&gt; &lt;td data-label=\"贊助日期\"&gt;2016-12-26&lt;/td&gt; &lt;td data-label=\"贊助狀態\"&gt;付款成功&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-label=\"方案\"&gt;一枝草一點露，一人一百支持 TingChi&lt;/td&gt; &lt;td data-label=\"金額\"&gt;$100&lt;/td&gt; &lt;td data-label=\"數量\"&gt;1&lt;/td&gt; &lt;td data-label=\"贊助日期\"&gt;2016-12-26&lt;/td&gt; &lt;td data-label=\"贊助狀態\" data-status=\"success\"&gt;付款成功&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td data-label=\"方案\"&gt;一枝草一點露，一人一百支持 TingChi&lt;/td&gt; &lt;td data-label=\"金額\"&gt;$100&lt;/td&gt; &lt;td data-label=\"數量\"&gt;1&lt;/td&gt; &lt;td data-label=\"贊助日期\"&gt;2016-12-26&lt;/td&gt; &lt;td data-label=\"贊助狀態\" data-status=\"fail\"&gt;付款失敗 &lt;div class=\"repay-information\"&gt; &lt;button&gt;重新付款&lt;/button&gt; &lt;button&gt;刪除紀錄&lt;/button&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 轉為 這樣即使在手機上也不需要滾動了。 See the Pen responsive-table by 愷開 (@kjj6198) on CodePen. 123456789101112131415161718192021222324252627282930313233343536table &#123; width: 100%; font-family: \"PingFang TC\"; td &#123; text-align: cetner; &#125; &#125;@media screen and (max-width: 500px) &#123; table &gt; thead &#123; border: 0; display: none; position: absolute; &#125; tbody tr &#123; border: 1px solid #aaa; margin-bottom: 1em; display: block; &#125; td:first-child &#123; display: block; font-weight: bold; text-align: center; &#125; td:not(:first-child) &#123; margin-top: 1em; margin-bottom: 1em; display: block; text-align: right; &amp;:before &#123; float: left; content: attr(data-label); &#125; &#125;&#125; 結論table 在資料呈現上相當方便，寬度的計算、等高都已經幫我們實作完成，在製作後台時，table 也幾乎是觀看資料時不可或缺的排版之一。 table 的設計上也有一些眉角可以注意，本篇文章提供了幾個製作 table 時需要注意的地方以及簡單的實作，未來如果有其他事項也會逐一加入。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"table","slug":"table","permalink":"http://kjj6198.github.io/tags/table/"},{"name":"CSS","slug":"CSS","permalink":"http://kjj6198.github.io/tags/CSS/"}]},{"title":"狂歡雙 11  —  祝我生日快樂","slug":"1111-happy-birthday","date":"2017-11-11T15:34:10.000Z","updated":"2017-11-11T15:37:28.000Z","comments":true,"path":"2017/11/11/1111-happy-birthday/","link":"","permalink":"http://kjj6198.github.io/2017/11/11/1111-happy-birthday/","excerpt":"","text":"今年 1111，除了各大電商正在雙 11 特價外，今天剛好也是我的滿 23 歲的生日。就把這幾年做的事做個整理吧。這篇文章篇幅很長，而且內容很瑣碎，幾乎都是從筆記跟日記當中東拼西湊寫出來的。 這篇文章有一大部分是寫給自己警惕用的。 我是誰？有時候，年紀越大越有一種逐漸迷失自己的感覺，每次都以為自己找到一個不錯的目標了，再繼續深究下去卻還有一大堆事情，直到現在我恐怕還是沒辦法講清楚我到底想要做什麼吧。不過人生大概就是這樣，會一直迷惘下去的，因此現在最重要的事情應該是，一旦決定好要做什麼，就不要輕易地反悔，否則就是在浪費人生了。 勞工大代誌這是我在勞工節製作的專案，從四月中旬開始規劃、搜集資料到實作，因為平時還有課業跟工作要顧，所以實際上花的時間不多，最後兩天甚至是熬夜在趕工。 有更多的原因是因為，寫到一半發現又有更多資料想要搜集，不知不覺就變得非常龐大了。 我以為給自己時間很充裕了，但仍然有太多議題沒有涵蓋到，像是年金制度、職災統計等等。 為什麼想要做這份專案國中跟高中的時候，或許是職科出身的關係，平時除了從報紙跟電視看看一些新聞外，很少汲取社會的議題和發生的事。 這樣半懺悔、半好奇的心態，開始搜集了一些台灣過去的勞工運動以及相關數據。像是薪資漲幅、平均工時、出生率等等，這些都是當我看到數據的當下才發現，原來事情那麼大條。工時高居全球、薪資漲幅凍漲將近十年、出生率最後一名、即將邁入超高齡社會等等。 如果說現在這個渺小的我能夠做些什麼，大概就是勞動節時上街遊行，聽聽勞工的聲音是怎樣，畢竟身為一位準勞工，再過不久大概就會遇到同樣的情境。 更何況是在我還沒出社會之前，就已經是那麼慘的現況了。 台灣的勞動環境仍然有許多待改進的地方，後人能夠享受到的果實絕不是理所當然。 這些前輩們用血汗、用人生、甚至賠上性命來爭取更好的勞工環境。 身為一位工程師能做的事情不多，這個社會上還有更多用科技無法觸及的事。但能夠拋磚引玉地讓人了解到「啊！原來還有這樣子的事啊」，就好了。 其實在查資料的時候，有很多讓人鼻酸的故事。 像是關廠工人臥軌時，民眾大喊輾過去；像是看到台電大樓的紀念碑連名字都沒有，藏在樹叢裡頭；像是看見 101 樹立的國殤紀念碑，卻過了那麼久才知道那是為何而來。 我們所處的社會當中有太多的理所當然，捷運順利地運作、高鐵能夠平安無事地從高雄開到台北、101 能夠安穩座落在臺北城、垃圾桶的垃圾有人收、廁所有人清、24 小時的便利商店，導致我們常常會忘記那背後隱藏的事情是由多少人的汗水（或是鮮血）堆積起來的，更何況是以前沒有任何勞基法保護的勞工們。 日語八百屋學日文我還依稀記得學日文初期，每天都在咖啡廳點完一杯拿鐵後，從中午待到晚上，學習方式也相當土法煉鋼。把書裡頭的課文看過幾遍後，練習書中的習題與文法，再把單字與學到的概念記錄在筆記本上。就這樣持續了一年左右，筆記本已經塞得滿滿的。 這期間真的空虛寂寞覺得冷，因為沒有人能夠讓你練習，在還沒有到達一定程度前，別人也只會用肥魯宅之類的字眼來嘲笑你而已。當時對我來說最好的方式就是用 lang-8。 有時候一不小心就會落入寫程式的陷阱，會非常直觀地去用「是否與程式有關」的方式選擇自己的行為。這對當時的我來說是個很好的指標，不過這顯然不該是不去學習新東西的理由。 幾年前的我曾經寫過「小說，我最愛的毒品」，看得出來當時文筆的稚嫩跟想法的天真。然而我很慶幸當時曾經有各種方式來記錄生活。包含部落格之外，我從國中到現在，已經寫了四本日記。 雖然用現在的角度來看，不免對自己以前的荒唐與智障莞爾一笑，不過他也的確構築了現在的我。我並不希望自己成為一個除了寫程式以外，眼睛黯淡無光，無法對世上其他事物產生熱情的人。 大約在前幾個月，我開始準備了線上課程。那對我來說是個很特別的體驗，因為之前並沒有任何日語的教學經驗，但想趁著這個機會來練習自己的教學規劃外，也希望能夠把以前的筆記、經驗統一做個整理。 規劃期花了我 2~3 個禮拜，從思考一位日語初學者在剛學習日文時會遇到的困難，循序漸進到名詞、形容詞、動詞、敬語常體轉換等等。送出審核時很緊張，很怕自己沒辦法通過。又偷偷地想，如果沒有通過至少我就不用準備了吧XD。 通過後，陷入了三個月的忙碌期，每天下班回來後就是坐在電腦前錄音，寫講義。幸好當時有規劃好整個課程架構，才讓課程順利上線。 這讓我深刻體會到線上教學的難處，雖然省下了實體教學的重複性與場地限制，但是每次的影片剪輯都要花將近 3 ~ 4 個小時製作、微調，更別說後期的字幕了，尤其是語言教學要在雙語間切換。 不過最後仍然順利上線了，對我來說這是個相當有成就感的一件事，看著大家報名與提問，覺得一切都很值得。 自學日文文章整理 自學四年通過日檢 N3, N2 心得 只要活著就會有痛苦－聲之形 給初學者的日文自學指南 日語學習資源總整理 日檢 N3, N2 文法總整理 - part1 日本服務業用語 我的日語學習之道 日本眾議院選舉 教科書上的八田與一 日文主題單字篇 - 剪髮 「気」的各種用法 語言能力在這個年代，語言能力已經算是基本條件。更何況，在台灣比我厲害的人超乎想像。更何況，幾乎每間大學、科大的應外系，標配就是英文和日文。就算精通這兩門語言，也只是統計樣本中的一點而已。 整理經驗大家在小時候是否都有寫過訂正本？如果我們可以把遇到的問題記錄下來，並且把當時的解決辦法記錄下來的話，以後遇到類似的問題就可以比較快的解決。 我在開發時會把當時遇到的問題、或是自己在開發途中延伸出來的概念記錄下來，並且在月底統一 review 一次，整理過後把概念已經相對完整的筆記統整為一篇文章發佈。 唯一能夠改變你的，只有你自己的行為而已。 你的未來不是擰螺絲工人摩登時代是卓別林的著名默劇之一，因為工業化跟經濟大蕭條的影響，勞工們被資本家壓榨，同時也造成百萬人失業。很諷刺的一部電影。 現在這個資本過剩的年代，生存已經不是太大的問題。 但如果不思考人生，那麽就跟裡頭的工人差不多，整天在工廠擰螺絲。 比起支配，我更想要幫助別人 - 卓別林 不要做不喜歡做的工作對一件事情有熱情是非常助力的。舉例來說好了，當時為了賺錢，早上通常在漢堡王打工，只能透過晚上自學來補足程式上的不足。進入實習後，才發現強度跟之前比起來實在是天壤之別。所有的事情都會在工作的壓力下被放大，產生的效應是非常可怕的一件事情。我在實習之後才接觸了許多當時線上課程完全沒教、業界卻已經逐漸開始引入的東西。 別人是用一天 10 小時的時間在做自己喜歡的事，而自己只是用閒暇擠出來的三兩分鐘來做，先不說天份上的差距，光是時間上就已經產生足夠顯著的差異了。 不要跟別人比較修了幾學分在現行體制下的大學教育制度下，畢業門檻通常在 120 ~ 140 學分左右，扣除專業選修及必修外，還有將近 30 多學分的通識課。 說真的，修的通識課是真的學到東西了，還是只是上下交相賊的營養學分而已？在大一的時候我也把學分修滿，到處去找一些看起來不錯的課上，雖然得到一份看似充實的課程表，但真正精華的知識也只有幾堂課而已，更別說在台科大選通識，根本就是個笑話。 比起推動 XXX 教育，找到自己真正想要幹嘛才是真正重要的事。在高職或許課業上的壓力比較沒有那麼大，但現在的國民教育，幾乎就像職場一樣，把一天 8 小時塞到滿檔，晚上繼續補習。晚上累得要命，更別提深入思考所學的本質、關心週遭事物、甚至是培養興趣。 因此在追求知識的同時，自己多出去看看週遭的事物、思考、深思熟慮之後再做選擇，比起到處比較學分來得重要多了。 不要被 Buzzword 影響你是真的喜歡現在做的事，還是只是時勢而已？前陣子推廣的程式教育以及多元領域課程、機器學習等等，其實都是假議題，如果不思考自己學習的目的，學習這些領域都只會落入痛苦的泥沼而已。 沒有人能夠幫你決定未來。 如果決定自己要做什麼很難，那麼可以從決定自己不要做什麼開始。 不要後悔自己的選擇人生是一連串的選擇。實習很好，唸書很好，出國留學很好，去旅行也很好，待在台灣也很好，只要那是你想要的，那就好。 但不要惋惜自己的人生，一旦你厭倦，你就只是在浪費人生。儘管我仍然不確定是否在這個領域上走下去是不是正確的道路。 不要汲汲營營於逢場作戲的人際關係剛上大學的時候常常會去跟同學進行「社交」活動，例如一起吃午餐、逛夜市、唱歌等等，後來想想，或許只是自己只是害怕沒有人的情況下，要不斷在問自己的問題而已。 這種時間通常才是最重要的，因為後來根本不會有人因為和你吃過飯，有過幾次交流，就突然變成知心好友。更別講有人會把這種行為視為拓展人脈。 因此如果真心想要在大學中找到比較要好的朋友，或許可以從社團、擔任幹部開始，當一群人有了同一個目標而聚在一起時，也比較容易和彼此交流，而不是午飯間的雜談閒聊而已。 年輕不是本錢很多人都會說年輕是本錢，目前的我很幸運，都還在平均年齡 30 歲以下的團隊工作。 但是這個社會很多人並不在乎你的經歷、能力是什麼。就像雖然我有兩年多的工作經驗，在社會上仍然會被認為是個剛畢業的大學生，然後再用各種美麗的包裝壓低你的薪水而已。 他們通常並不在乎你做了什麼，而是你的學歷、有沒有在上市公司上班、多益成績這種根本無法辨識的指標。當然啦具備能力的人通常也會有上述幾個條件，他們根本不在乎學歷年紀這種指標。畢竟資深有時只是代表做的比較久而已。 臉書最近，我把臉書上許多會令我分心粉絲專頁以及內容農場給刪掉了，像是各種行車記錄器影片、蘋果日報、即時動新聞等等。盡量讓我的動態牆不要被各種我不喜歡的事物強姦。 絕望的是，舉凡youtube 爆紅、某某女星私密照流出、一生要做的幾件事等等，下面的回應都非常熱烈。 他們看似無傷大雅，可是卻在默默腐蝕我的心靈，尤其像我這種會被下一個影片給吸引的人，一旦點開來第一部影片就會繼續看下去。 最後，為了避免惱人的通知，我把 Facebook 的 App 也刪掉了。除了剛開始有點不習慣之外，其實沒有太大的變化，反而空出更多時間來。也不會下意識地打開 App，如果真的想滑就用網頁版的，那種單純和不方便的操作方式反而可以減少我在 Facebook 上虛耗的光陰。 最重要的是思考台灣的教育在高中上後直接導向士農工商，成績比較爛的就被丟去二流的職業學校。把課程排爆棚，一天跟上班時間一樣的 8 小時，再加上補習班，根本沒有多餘的時間讓你思考人生、關心周遭的事物，只會讓人變得跟溫順。 對於一個只要頭腦不要太差，經濟狀況許可的一般人來說，一路安然到大學是個常態分佈現象。但神奇的是這群人在畢業以後，出來做的卻是幾乎在撿角般的工作。他們覺得自己很努力了。 可是努力這個字本身是個相當諷刺的字眼，尤其是這個年代來說，「努力」基本上已經是個基本條件，而不再是個能夠拿來說嘴的人格特質。在大學時拼命攢學分，去修一些名不見經傳的課程，對於無法用努力取勝的科目就施以小惠，再想辦法矇混過關。 最後發現四年過去了，找工作時一點屁用都沒有。從小到大我們並沒有好好地去思考自己想要的是什麼，導致念完大學之後已經逐漸喪失獨立思考的能力，變成隨波逐流的島民。 不要管太多，只要努力工作就好；修法？這是沒辦法的事；薪水被壓榨？就算不開心生活還是要過。於是圈養出了一群已經生活毫無目標可言，每天抱怨的愚民們。 他們不但鄙視那些地位比較高的人，一旦有人試圖反抗，想要為這個社會發聲，如果他看起來並沒有這群人那麼慘，他們還會沆瀣一氣去阻止這個人，變成了同階級之間的弱弱相殘。很怕其他人不小心就得到了比自己更好的生活。 這群人很努力，但如果被施以錯誤的教育以及思考上的怠惰，最終或許就會導致這樣的結果。 因此最重要的在於如何思考，這個目標是一輩子的課題，「生也有涯、而知也無涯」後面常常被省略一句，「以有涯隨無涯，殆已。已而為知者，殆而已矣」，用有限的生命來追求無盡的知（不只限於知識），是很危險的事情。如果這樣做還自以為很聰明，那就更危險了。 知識上的不足可以用思考彌補，但是不思考又一知半解，什麼事都做不好，那才是最可怕的。而目前的台灣大學生，恐怕都在往這個方向前進。 至於怎麼練習思考，最剛開始或許可以從閱讀開始。 2018 年目標轉眼間四五年過去了，走了不少冤枉路，每次到自己的生日，都會有種馬齒徒增的焦慮感，也不知道自己是否在一條正確的道路上。回顧一下之前所發生的事，不禁覺得自己有一大半的時間都在虛度光陰。不過儘管如此，他也的確是一部分的我。 想要做的事情還有很多，但如果真的要說出一個比較完整的目標，大概就是「我想做一個有用的人」吧。","categories":[{"name":"雜談","slug":"雜談","permalink":"http://kjj6198.github.io/categories/雜談/"}],"tags":[{"name":"雙 11","slug":"雙-11","permalink":"http://kjj6198.github.io/tags/雙-11/"}]},{"title":"Better Express error","slug":"better-express-error","date":"2017-11-09T16:48:23.000Z","updated":"2017-11-09T16:52:18.000Z","comments":true,"path":"2017/11/10/better-express-error/","link":"","permalink":"http://kjj6198.github.io/2017/11/10/better-express-error/","excerpt":"","text":"Better-express-error在 express 開發時，如果遇到錯誤，通常是直接印在 error page 上，或者在 production 端直接導到 404, 500 page。 這雖然沒有什麼值得一提的是，不過說真的，看到這種頁面，你會覺得開心嗎？ 熟悉 Ruby On Rails 開發的工程師，應該多少都用過 better_errors，或者 rails 本身內建的 error trace page 來 debug。 不過在 express 上，還沒有看到一個功能類似 better error 的 package，常常只能看這種醜不拉嘰的 error message 仰天長嘯。 於是，自己做了一個簡單的 middleware 處理這件事。其實本質上就是 bettor errors 的 express 實作啦 分析錯誤訊息1234567891011TypeError: range out of bound. Please check http://kjj6198.github.io for more information.at app.get (/Users/kalan/code/express-error/server/app.js:17:9)at Layer.handle [as handle_request] (/Users/kalan/code/express-error/node_modules/express/lib/router/layer.js:95:5)at next (/Users/kalan/code/express-error/node_modules/express/lib/router/route.js:137:13)at Route.dispatch (/Users/kalan/code/express-error/node_modules/express/lib/router/route.js:112:3)at Layer.handle [as handle_request] (/Users/kalan/code/express-error/node_modules/express/lib/router/layer.js:95:5)at /Users/kalan/code/express-error/node_modules/express/lib/router/index.js:281:22at Function.process_params (/Users/kalan/code/express-error/node_modules/express/lib/router/index.js:335:12)at next (/Users/kalan/code/express-error/node_modules/express/lib/router/index.js:275:10)at jsonParser (/Users/kalan/code/express-error/node_modules/body-parser/lib/types/json.js:109:7)at Layer.handle [as handle_request] (/Users/kalan/code/express-error/node_modules/express/lib/router/layer.js:95:5) 仔細觀察後可以發現，錯誤訊息的格式是相當整齊規律的。首先，第一行為錯誤名稱與訊息，這通常是最重要的資訊。第二行以後則是調用 stack。at … 是某個函數的呼叫，括號內則是檔名與行數、row 的訊息。 簡單分析完錯誤訊息後，我們可以把純文字轉為比較有用的資訊。因此透過 split(&#39;\\n&#39;)，再根據字串做簡單的正規表達式匹配，就能分成檔名與行數資訊了。 顯示 Error對於第一行的錯誤訊息，通常是最重要的資訊，因為程式碼就是在那邊噴錯的，因此對於第一行錯誤訊息，我們將他放在最顯眼的地方並且 highlight。 而第二行之後的錯誤訊息，用顏色及大小來標示檔案名稱、行數以及調用的函式名稱。 比起前面一坨黑黑的文字，這樣簡單的整理已經可以讓開發者可以一目了然到底發生了什麼事。 顯示檔案內容不過，除了顯示錯誤訊息之外，我們也希望能夠同時顯示對應的檔案內容，以及上下文有哪些。因此右半邊可以利用錯誤訊息中提供的檔案名稱與行數，顯示對應的檔案內容。 對於 nodejs 來說，只要透過 fs.readFileSync 就夠了。 12345678function(filename, line, row) &#123; const content = fs.readFileSync(filename); content.toString() .split('\\n') .slice(line - 5, line + 5) .map(content =&gt; `&lt;span&gt;$&#123;content&#125;&lt;/span&gt;`) .join('\\n');&#125; 這邊是透過很簡單的方式，直接印出前五行及後五行，更聰明的方式是透過像是 AST 之類的技巧，只印出對應到的 function 內容。不過現在我們直接印出前後五行的程式碼即可。 做一些調整與修改，大概長這樣： 透過簡單的 highlight，讓開發者馬上知道出錯的地方在哪邊。 REPL除了顯示 error 外，我們還希望這個頁面可以輸入一些簡單的程式，確認問題點後，再實際修改程式碼。 在 nodejs 當中，有個 VM 的模組，能夠讓你使用 V8 的 Virtual Machine contexts 執行給定的 code。透過這個模組，我們就能夠實現類似 REPL 的功能了！ 1234567891011const debugContext = vm.createContext(&#123; request: req, response: res, util: require('util'), Buffer: require('buffer').Buffer, stream: require('stream'), console: &#123; log: util.format &#125;, clear: ''&#125;); 把想要暴露的變數傳入 context 當中，在透過 POST 的方式讀取前端的 code，就可以很方便地達到 debug 的效果。 （以上還需要做一些調整） 全部整合！ 全部整合起來後，頁面大概會長這樣。 比起原本的純文字，雖然花了一些功調整頁面 style 與實現 REPL 的功能，不過讓 debug 的流程變得更加流暢了。 結論express-error 詳細的實作在這個 repo 裏頭，最近如果比較有空會在將實作抽換為 middleware 的形式方便大家使用。也會逐漸優化整個 layout 與 code highlight 的部分，並且讓整個流程跟畫面更加流暢一些。雖然不知道會過多久就是了 XD 如果有各種建議也歡迎提出 issue。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://kjj6198.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://kjj6198.github.io/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://kjj6198.github.io/tags/express/"}]},{"title":"透過 AWS lambda 上傳 Medium 文章","slug":"AWS-lambda-medium","date":"2017-11-09T16:46:28.000Z","updated":"2017-11-09T16:50:15.000Z","comments":true,"path":"2017/11/10/AWS-lambda-medium/","link":"","permalink":"http://kjj6198.github.io/2017/11/10/AWS-lambda-medium/","excerpt":"","text":"Medium 本身不支援 code block 編輯，雖然不知道背後的原因為何（或許工程師並非主要客群），所以如果要高亮程式碼，一個作法是直接貼圖片，一個是貼在 gist 上後再 embed 到文章當中。 程式碼用圖片貼出雖然可以達到高亮效果，但對工程師來說是一件相當不友善的事，因為無法透過複製貼上的方式來實際測試你的程式碼，或者編輯文章時還要手動修圖，是一件很麻煩的事。 不過貼上 gist 也有幾個問題 手機版無法觀看，會直接噴出連結給你而非嵌入的內容 自己貼 code 到 gist 太麻煩。（不過搭配 vscode sublime 等套件上傳到 gist 也是個不錯的方式） 為了盡量在 Medium 看到高亮的 code block，最後決定使用 AWS Lambda 解決這件事。 AWS Lambda對於 Lambda 還不了解的讀者，目前網路上已經有很多資源可以觀看，這邊不再贅述。Lambda 是讓 AWS 幫你執行想要的 function，而不用實際去建立一個 server（當然背後還是有 server 啦）。透過這種方式，我們不用寫個 function 就要部署到一台機器，甚至去維護它，我們只需要執行就好。 Github Issue為了串接到 lambda 的 endpoint，決定透過 github webhook 觸發。因為在 github 可以使用 issue 寫 markdown，還可以上傳圖片（github 幫你 host）、預覽、code block 等，其實相當方便。想要發布文章時，再透過 close issue 觸發 webhook，再透過 lambda 將 code block 上傳至 gist，最後呼叫 Medium API 建立文章。 Medium API https://github.com/Medium/medium-api-docs Medium 的 API 短小輕薄，不過方便好用。首先先到個人頁面的 setting &gt; Integration tokens 生成 token，再透過 token 呼叫建立文章的 API 即可。 Gist APIgist API 也是一樣，為了不讓自己的 gist 一片混亂，建議可以另外再開一個帳號專門存放文章使用的 code。到 settings &gt; developer settings &gt; personal access token &gt; generate token 建立 token，記得勾選 gist 權限。 串接 Lambda前置工作做好後就可以開始串接 lambda 了。 首先把建立好的 lambda endpoint 放到 github webhook 中，然後隨便找一個可以編譯 markdown 為 HTML 的 package（我是用 marked），結合起來就可以囉！ 一個簡單的實作在這裡。雖然稍嫌麻煩，不過其實還挺方便的。不知道 Medium 何時才要支援 code block QQ。","categories":[{"name":"AWS","slug":"AWS","permalink":"http://kjj6198.github.io/categories/AWS/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://kjj6198.github.io/tags/lambda/"},{"name":"medium","slug":"medium","permalink":"http://kjj6198.github.io/tags/medium/"}]},{"title":"自學四年通過日檢 N2 心得","slug":"jlpt-learning","date":"2017-10-07T13:47:12.000Z","updated":"2017-10-07T13:50:21.000Z","comments":true,"path":"2017/10/07/jlpt-learning/","link":"","permalink":"http://kjj6198.github.io/2017/10/07/jlpt-learning/","excerpt":"","text":"前言從大學開始，因為高中畢業後對日本文化相當有興趣，所以開始自學五十音。先談談我的背景： 高職電子科畢業 科大資管系 大學選修初階日文跟進階日文，不過進度本身已超過課程許多。期間雖然一直想報名日檢，但礙於自身實力與經濟考量，所以直到大學快畢業後才報考日檢。 以下是我這次的日檢成績： 日本語能力檢定 N2 (134/180) 日本語能力檢定 N3 (163/180) 這並不是很亮眼的成績，不過這篇文章會結合我自己自學日文的經驗，並且分享一些學習的技巧，畢竟一直以來依靠許多網路資源，希望能夠回饋給大家。 這篇文章會分成兩部分，第一部分談談自己對學習語言的看法，第二部分則是介紹一些我在學習日文時常用的學習資源。 這篇文章不會提到答題技巧或是短期衝刺的秘訣，原因很簡單，日檢等考試都可能會更改制度或題型，未來可能主流的考試也並非 JLPT，過度追求答題技巧可能只會造成反效果而已。 為什麼要學日文？首先先思考：「為什麼要學日文？」。 英文不論廣度以及對於工作的幫助，毋庸置疑都是一個投資報酬率遠高於日文的語言，想清楚自己為何要學習日文這件事很重要。 大家都會一點日文，感覺好像很簡單 我的好朋友們都選日文當通識，我想要跟他們一起上課 日文跟中文蠻像的，應該很好學 學日文應該很有用 學習一些大家都會用的日文很簡單，早安晚安、數數、形容詞變化，比較好一點懂得ます形變化就能夠橫行無阻了。不過這真的是你想要的目標嗎？你花了金錢和時間學習一項技能，最後遺忘。 所以在開始之前，我希望各位都能夠思考學習日文的理由，儘管最後得出的答案可能是興趣、看日劇、看動漫、追星、甚至只是一句爽都好，只要你知道你在做什麼。 這裡推薦大家閱讀一下 Denny 寫的為什麼你可能不需要「寫程式」補習班？。 學語言跟學程式很像。學日文的人太多了，如果搞不清楚自己的價值，那麼只能在社會的洪流中被淘汰而已。 要不要報名補習班？在學習日文的路上，如果有人能夠給你適當的指導，那麼絕對能夠少走很多冤枉路，在市面上有很多日語補習班，品質參差不齊。 所以在被其他補習班的話術迷惑之前，記得先上網做做功課，衡量自己的時間成本後再決定是否需要投入。 我在大學四年中雖然有修過初級日文及進階日文，但除了初級日文外，自身學習的進度都遠超過課程當中的內容。 用笨方法學日文1. 每天 2 小時學習初期絕對會是最枯燥跟痛苦的時候，因為你沒有任何的基礎觸類旁通，只能緩慢地累積單字量跟文法。這個階段我每天會安排空閒的時間念日文，然後做筆記。 大概 2 個月過後，我已經能夠使用形容詞變化、基本動詞變化，但這時我的單字量並沒有很多，大概只會一些生活常見單字跟動詞而已。 比起單字，這個時候的重點應該是盡可能地了解日文的文法規則和句子組成。 原因很簡單，我們都知道動詞進行式要加 ing 被動是要加上 ed，這是英文當中相當基本的規則。雖然你也可以從大量的句子當中找出這樣的規則，但直接學習文法是了解規則最快的方式。 打排球也要知道怎樣算出界跟犯規吧！ 等到基本文法學習完畢（名詞句變化、形容詞句、形容動詞、動詞變化、敬語常語轉換、て形應用）後，開始能夠看懂大部分的句子組成架構後，重點就轉為背單字了。 特別注意，動詞是一個語言的靈魂，動詞變化的掌握度決定你對語言的熟悉程度。所以初期學習日文的目標應該盡量以文法導向，先不用著墨太多會話與單字。 2. 利用零碎時間背單字下面會講到 Anki 這個應用程式，他能夠根據你對單字的熟悉度更改出現的頻率。 透過這個應用程式，開始在零碎時間累積單字，並持續加強不熟的文法。 這個階段也可以開始看一些比較簡單的文章，從文章中練習日本人是如何組織句子的。這個階段會是成長速度最快的階段，因為你已經有足夠的基礎。而這時你應該開始將核心著重於累積單字量上。 3. 深入日本文化像是「尊敬語」、「謙讓語」，以及他們的變化規則，雖然稍嫌複雜，不過已經有閱讀量跟單字量當作根基，很快就能上手。同時也可以開始針對日文的「複合動詞」、「擬態語」、「熟語」做加強。 4. 針對特定主題之前撰寫過服務業日語、日語單字剪髮篇，都是在特定情境下背單字，這可以提昇你對單字的熟悉度。 5. 多聞闕疑如果在學習的階段中遇到一些容易混肴的觀念，像是最常見的「が、は」的使用方式，先不用急著想知道答案，你可能看過 100 種不同的說法。這時候可以先放下心中的疑問，繼續學習，等到累積的閱讀量跟文法夠紮實的時候，自然就會知道。也就是我們常常說的「語感」 怎麼準備考試的？考試前我有買 「EZJapan N3 應考對策」跟「EZJapan N2 應考對策」。大概在前兩週開始寫試題，看解析，把不熟的單字背起來。平常看日劇，NHK 練聽力跟閱讀。 不過自己平時就有固定學習日文的習慣，所以考前 2 個禮拜時除了做題目練手感之外沒有做太多準備，下面會再提到我有利用哪些資源學習。 自學資源整理之前我有寫過一篇關於自學資源的文章，這邊再補充一些資訊給大家參考。 在學習日文到一定的程度後，就是靠單字跟閱讀量的累積來決勝負了。學習文法雖然能夠幫助我們快速理解，但是最重要的還是「累積」。 自己在跌跌撞撞找了很多網站跟資源後，選出幾個我覺得非常有用的網站推薦給大家，希望能夠幫助到一樣在自學之路上跌跌撞撞的學習者們。 1. Nippon 所藏我喜歡日本文化，所以到書店時如果有看到喜歡的雜誌或書籍就會買下來。其中我最喜歡的就是 Nippon 所藏。他的排版非常用心，而且內容相當豐富，我每一本都買下來了。裏頭也可以學習到很多關於日本流行的話題跟單字。如果程度還沒有很紮實的初學者，每一篇文章都有中文對照，也有提供單字跟文法筆記。 日本和食 100 品：提供許多日式料理的食譜，獲益良多。 日本流行話題 100 選：結合當時日本時下流行的話題，像是半澤直樹、王牌大律師、家政婦女王、日本核災、晴空塔等等。 日本潮流 100 選：以「時尚」為主題，裏頭有許多關於美容美髮相關的單字，有一章節是在討論如何修飾自己的造型、體態，後半段甚至還有約會筆記跟注意事項！ 日本職場案內 100 則：敘述日本的職場文化以及潛規則，像是年功序列制、團塊世代、寄信時、接電話時、交換名片時要注意的事情，也有一小節是在教你如何使用「尊敬語」與「謙讓語」，如果要到日本工作的朋友們，這本相當推 2. 音速日語學習大家在學習日文的旅途上應該都有它的陪伴吧，我自己在剛學習日文時是每天都會到音速日語學習中學習一個單元。一個單元雖然不多，不過累積了 3 個月之後就有將近 100 個單元。 3. 日劇在大學四年中，我看了許多日劇。不過我看日劇時會分成學習和純娛樂兩種，學習時我會把字幕擋起來，遇到聽不太懂的句子就直接暫停重聽，再把新學習到的單字或句子輸入到 Anki 當中之後再複習。 印象最深刻的是我之前把王牌大律師後面死刑辯論那一段全部背下來了XD。這樣子學習效果很好，因為他強迫你重複去聽某個句子，而且事後的複習又會加深印象以及日劇當中的場景作輔助。（雖然聽力還是我的罩門QQ） 4. Lang-8 是我在學習日文中，幫助最大的學習平台，沒有之一。他的運作方式是這樣的，你可以在這個平台上用你想要學習的語言撰寫日記，之後就會有相對的母語人士來幫你修改。 這樣子誰要來幫我改？這個網站的機制做得很好，如果你想要你的日記被別人看到，你就要用你的母語幫別人修改日記，才能拿到點數（Lang-8 裡頭稱作 L-point），點數越高你的排名就會越高，日記的曝光率也就越高。 所以別人為了拿點數，就會來閱讀、修改你的日記，久而久之就能搜集來自母語者的建議。 就算你只有 N5, N4 的程度也沒關係，放下自尊跟臉皮寫寫一些文章，今天的心情、發生了什麼事，試著寫下來，就算文法錯了也沒關係。 不過，也因為如此，偶而會出現修改品質參差不一的情形。例如：有些日本人就硬要你改成敬語。 或是省略 ている 的 い 時，有些日本人不知道你是不會還是真的不懂，所以就一律幫你加上去等等。所以修改之後的日記品質，必須靠自己確認。 這的確是讓我學習的一大動力之一，分享日記給日本人看，瀏覽其他國家學習中文後的日記，說真的挺好玩的。可以從中認識一些不錯的朋友也說不定喲！ 很可惜的一點是，目前 Lang-8 這個平台已經不開放註冊了。好像轉移服務到 HiNative 的平台上去了。Hinative 上比較像是用問問題的模式來進行，個人比較不喜歡，有興趣的讀者們可以參考看看。 我目前的排名是 445/410,886，不過已經荒廢了一陣子。歡迎之前有註冊的朋友們一起交流！ 5. 徵求外國朋友佈告欄除了日語學習外，也常常會徵求其他國家的朋友。但也有許多來者不善的貼文就是了。 至於能不能夠找到志同道合的夥伴，需要靠很大的運氣。 有許多人只是想要和外國人聊聊天而已，並不是真的想要做「語言交換」這個目的。而且就幾次交流的經驗來看，除非雙方都是為了學習語言，不然很容易就陷入純聊天的情況，根本無法進行語言交換。 6. Anki不多說，背單字的神器。我目前也只有累積 4,5000 的單字而已，不過因為我習慣把自己看到有趣的動漫台詞跟自己的筆記加進去，所以看單字的時候不至於那麼枯燥。 像是什麼趣味でヒーロをやっている者だ這種句子XD。至少在一片單字海當中，看到幾句中二的台詞能夠調解一下。 7. 日本語之森文法講解非常清楚。而且資源很豐富，想要短時間加強文法的讀者們可以參考看看！這個網站的特色是都是由日本人來講解文法的，所以可以用更 native 的方式來學習日文。 8. 原文小說我很喜歡日本推理的作品，像是伊坂幸太郎、米澤穗信、東野圭吾都是我很喜歡的作家，之前到日本時就買了幾本文庫本，在通勤時會拿出來翻，並且把不會的單字用螢光筆匡起來之後回家再查。 大概持續了兩個月左右，明顯感受到單字量大幅提升，不過看完一本小說的速度好慢QQ，老實說我還沒看完任何一本。 9. 日語八百屋在今年的 3 月份左右，我成立了日語八百屋週刊。因為我自己本身有在收集筆記跟文章的習慣，久而久之累積了不少，想說自己做個 email 的服務把這些筆記寄給大家，舒緩一下在漫長日文自學之路中的枯燥苦悶。 致力於滿足日文、日本、日劇愛好者們的求知慾以及資訊焦慮症。幫助減少學習阻礙、資訊不對稱、增加日本文化知識，內容涵蓋了日語學習、日本旅行、日本文化、動漫、語言學習技巧等等。 有興趣的朋友們也可以來訂閱看看，如果內容不喜歡隨時可以退訂，或者直接到 Medium 看看歷期週刊。 目前已經有 1200 多人訂閱，總共有 24 期週刊內容，也歡迎大家一起分享自己的學習心得或筆記。 日語八百屋 | 為日本愛好者而生的週刊 寫下來寫作是個很好組織自己想法的方式。如果在學習日文時有做筆記的習慣，那麼一年兩年累積下來的量相當可觀。 同時，如果你能夠將文章發佈在部落格當中，除了能夠幫助到其他人之外，因為需要讓別人看到，所以你更需要強迫自己組織好自己的文章架構。 光是寫下來這件事，你就贏過許多舉足不前的台灣人了。 一些推薦使用的工具 Evernote 非常好用的筆記軟體，除了用在日語學習上還可以用在工作、生活當中，他的搜尋機制相當強大，很容易就可以找到自己想要找的東西 Google drive typora：一個 markdown 的編輯器，喜歡 markdown 語法，或是想要嘗試簡潔地寫文章非常推薦這個軟體！ 結論其實當初沒有想很多，只是一直以來都對日本文化有興趣，想要趁著高中畢業的空檔學習。後來因為科系（資管系）的關係，有部分的技術文章或是部落格都是用日文撰寫，還有一年跑去台大修日本歷史（全日文授課），覺得當初幸好有好好學日文。後來出社會面試後，也因為日文的關係，在面試時遇到日本人時可以多講幾句話加深印象。 這次考完試給我最大的感受應該就是真正的日文學習之路才剛開始而已。 如果以檢定為目標，你可能會錯失許多學習日文的美景，不過考取檢定確實是一個測試自己實力的好方法，不管是為了什麼目標考取檢定，我們都應該要知道，檢定只是一個另外一個起點而已。","categories":[{"name":"日語學習","slug":"日語學習","permalink":"http://kjj6198.github.io/categories/日語學習/"}],"tags":[{"name":"日語學習","slug":"日語學習","permalink":"http://kjj6198.github.io/tags/日語學習/"},{"name":"日語八百屋","slug":"日語八百屋","permalink":"http://kjj6198.github.io/tags/日語八百屋/"},{"name":"JLPT","slug":"JLPT","permalink":"http://kjj6198.github.io/tags/JLPT/"},{"name":"日檢","slug":"日檢","permalink":"http://kjj6198.github.io/tags/日檢/"}]},{"title":"React16 重點整理","slug":"react-16-features","date":"2017-10-01T16:00:00.000Z","updated":"2017-10-07T13:45:00.000Z","comments":true,"path":"2017/10/02/react-16-features/","link":"","permalink":"http://kjj6198.github.io/2017/10/02/react-16-features/","excerpt":"","text":"react 終於正式發佈 v16 了，其實官方部落格的介紹已經相當完整（而且賞心悅目）。本篇文章作為筆記與統整，精簡了部分的細節。 1. componentDidPatch(error, info)react16 最亮眼的部分，加入 ErrorBoundary 的功能，確保在 lifecycle 時的錯誤不會影響到整個 component。之前如果在 render 時發生錯誤，會導致整個 component 不見。 只有在 Error 在 lifecycle method 被呼叫時才會傳入 componentDidPatch，所以在 constructor 之類的地方 throw Error 是不會被 componentDidCatch 給 catch 的。 componentDidCatch 傳入兩個參數 error, info。可以在 componentDidCatch 內處理錯誤，fallback UI 或是呼叫第三方服務紀錄錯誤等等。 1234567891011121314151617181920212223242526272829303132333435363738class Post extends Component &#123; constructor() &#123; throw new Error('oops'); // 不會傳入 componentDidCatch &#125; componentWillMount() &#123; this.setState(state =&gt; &#123; throw new Error('oops'); return &#123;&#125;; &#125;) &#125;&#125;class App extends Component &#123; constructor() &#123; super(props); this.state = &#123; post: &#123; content: '' &#125; &#125; &#125; updatePost = () =&gt; &#123; this.setState(state =&gt; (&#123; ...state, post: null &#125;)); &#125; componentDidCatch(error, info) &#123; this.setState(&#123; hasError: true &#125;); Logger.warn(error, info); &#125; render() &#123; return ( &lt;div&gt; &lt;Post post=&#123;this.state.post&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 除了上面的範例之外，你也可以透過 higher order component 的技巧將 componentDidCatch 包裝，或者是設定 ErrorBoundary 等等的 component 統一處理 children 的錯誤。 2. Text-Only component刪除了不必要的 span 與 react-text 節點，並且可以直接回傳字串。 123456789101112const Text = (&#123; text &#125;) =&gt; &#123; return 'pure string!';&#125;class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Text /&gt; // render 'pure string', rather than &lt;span&gt;pure string&lt;/span&gt; &lt;/div&gt; ) &#125;&#125; *3. ReactDOM.createPortal(component, dom)createPortal 也是我相當喜歡的新功能之一，他能夠透過在 Component Tree 裡頭另外 render 到其他 DOM 上，並且可以完全脫離 Children 也沒有關係，像是下面的結構。 1234&lt;div id=\"app1\"&gt;&lt;/div&gt;&lt;div id=\"app2\"&gt;&lt;/div&gt; 123456789101112class App extends Component &#123; constructor() &#123; &#125; render() &#123; &lt;div&gt; &lt;h2&gt;Main header&lt;/h2&gt; &#123;ReactDOM.createPortal(&lt;Sidebar /&gt;, document.querySelector('#app2'))&#125; &lt;/div&gt; &#125;&#125; App 裡頭可以透過 ReactDOM.createPortal()，除了閱讀性比較好之外（不用透過 callback 或是直接操作 DOM 的方式），還能夠對 Children 以外的節點操作，對於寫像是 modal 這種可能需要 overlay 的 component 很方便。（overlay 可能要再根節點上，比較好處理） 4. Custom Attributes123456render() &#123; return ( &lt;div ui-prefix-scroller='foo'&gt; &lt;/div&gt; ) &#125;; 5. prevent update在 setState 回傳 null 不會觸發更新（之前的版本會）。以後不想更新 component 可以透過傳入 null 來解決。 6. SSR 的支援詳細可以參考 What’s new with serverside rendering in react16，值得一提的是 react16 SSR 開始支援 stream，renderToNodeStream(Component) 回傳 stream。 以及文章作者提到的： please, please, please make sure you always set NODE_ENV to production when using React SSR in production! 結論以上就是 React 16 的主要更動。官方部落格有更詳盡的介紹。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kjj6198.github.io/tags/react/"}]},{"title":"前端面試心得","slug":"frontend-interview","date":"2017-09-01T16:00:00.000Z","updated":"2017-10-08T09:41:00.000Z","comments":true,"path":"2017/09/02/frontend-interview/","link":"","permalink":"http://kjj6198.github.io/2017/09/02/frontend-interview/","excerpt":"","text":"前言終於有時間整理最近的面試歷程了。先總結一些看到的事情： 通常公司面試只考 Javascript 的熟悉度，多數關於演算法或是解釋原型鍊等等，很少考 DOM 或是 Event 的操作。 幾乎不考 CSS，就算有也只是簡單判斷 class、ID 優先度這種基本題目而已。 沒有面試考 HTML，例如 semantic tag、accessilbility、input type 使用等等。 React、Redux、ES6 語法幾乎成為前端必備技能，Angular 比較少公司採用。 普遍的獵頭都不夠專業，也有可能是太菜了還沒被專業的獵頭找上 以下是這次面試的公司： Accupass Codementor Linker Network Inc. 樂天市場 17 media 背景國立科大資管系，目前已經有兩年工作經驗。平時專注在前端開發，接觸 React、Redux 開發約兩年的時間。除了一般的前端「工程」之外，自己也很喜歡畫面的實作與互動，同時也有在自己的小專案當中練習後端的知識，像是 AWS、Lambda、nodejs、資料庫、機器學習等等，不過最熟悉的還是前端相關。 期待的工作環境 能夠和前端團隊一起合作。之前的工作經驗因為前端開發都只有自己一人，所以比較難討論特定的前端技術 不會有太多突發狀況。像是突然就改需求、砍掉開發中的產品、因為人情而被迫開發的案子等等 有主產品以及明確的服務 技術含量高，可以和優秀的團隊一起共事 找工作的管道 inside jobboard yourator 104 人力銀行 f2e jobs PTT Soft_Job 版 1. Accupass 活動通應徵職位：Frontend Developer 一個活動票券的網站，最近正在將架構從 Angular 改寫為 React，原因是原本的 Angular 較難維護，而且很容易產生牽一髮動全身的情形。 面試前在 104 上被邀約面試，是由 PM 邀約面試的。 面試中團隊正在擴編。面試主要聊一些自己的工作經驗以及一些小項目。當天面試我的前端工程師是一位日本人XD，但是中文講得很好（全程都是中文面試）。 聊了關於 Accupass 的開發狀況、如何開發功能、管理時程等等，也和前端工程師聊技術，從 CSSModules、RxJS 聊到 CycleJS，感覺是個對前端技術很有熱忱的工程師。 面試結果婉拒 offer。 PM 相當希望我能夠加入 Accupass 團隊，婉拒後也撥了通電話詢問原因，並提及如果以後有機會希望能夠一起合作。不過由於其他職位更吸引我，所以拒絕了 Accupass 的 offer。 2. Linker Network Inc. 美商寶蘊凌科網路科技有限公司應徵職位：Frontend Developer 專門做 IOT、AI、機器學習的雲端運算平台，因為這些 platform 需要 UI 的支持，所以需要前端開發協助。官網還蠻簡陋的，看不出個所以然，不過做的事情技術含量很高。 面試前在 104 上主動投遞履歷，被電話邀請面試。這間公司做的技術含量很深，也有在線下辦一些社群。 面試中感覺得出來是個蠻技術含量很紮實的公司。自我介紹談了一下過去的工作經驗，以及用 React, Redux。 我之後才知道原來當初面試我的是 c9s ，想說怎麼那麼眼熟。感覺得出來是位大大，技術的掌握度很深。（不過本人看起來比較憔悴） 面試時考了些偏優化的題目，像是： js 如何做 minify？這題是要你大概解釋一下 js minify 的過程，最後簡化到如何消除程式碼中不必要的空白。這題的想法很簡單，不過實作起來有一些細節要注意，當時沒有想很多，被提示很多次才寫出來 前端效能優化可以怎麼做？提了一些常見的方式，不過感覺沒有很合面試官的胃口。像是 base64 編碼減少請求數、快取、ServiceWorker 等等。 如果要你做一個 SPA 的 framework，你會怎麼做？如果要我做，首先要考慮的是 router 的處理方式，畢竟 SPA 需要依靠前端做 router。後來被提醒了還要考慮 lifecycle 的問題 一些 Javascript 的問題 原形鍊的原理 new 背後發生了什麼事？ 如何實作繼承 this 指向誰 最後由一位看起來是主管的人跟我談一些公司現況、未來發展等等。 面試結果無聲卡（到現在已經三週），大概是太菜了吧QQ 3. 台灣樂天市場應徵職位：Frontend Developer 之前有參加過一次面試，不過因為沒辦法提供全職的上班時間（也不確定是不是）。所以重新又投了一次。辦公室的氣氛跟一般大公司差不多，要有員工證才能進辦公室。 面試前HR 聯絡，寄給我一張身家調查表以及程式考題。上頭的格式大概跟 104 履歷差不多。這邊我想特別講一下他們的面試邀約信。 一般的公司通常在信上附上地址，不過樂天市場會把一些重要的地標標示出來，例如 XX 號出口、在 XX 銀行上面、出電梯右轉等等，雖然這是一個微不足道的提醒，但對面試者來說很有用，畢竟誰都不想在大太陽底下看 google map 還不小心走反方向。 面試中這次的面試比起以前好像又更制式一些，還要寫智力測驗跟人格測驗的考卷，考一些類似加減乘除之類的題目，我好像還錯了幾題XD。整個面試流程又因為這樣拉長了一些時間。 跟工程師面試的過程蠻愉快的，主要也是聊一些工作經驗以及對技術的了解，兩位工程師感覺也是技術很強的大大。有一位工程師之前已經面試過我，跟我說「我對你的技術能力沒有太大問題」，但是因為卡兵役的關係還是被 reject 掉，整個很感動QQ。 後來我還發現原來有一位就是 react-bootstrap-table 的 creator。 面試主要考了一些 Javascript 的東西，像是： 遞迴以及實際應用例如有一題反轉字串，主考官叫我用遞迴實現，並問我好處是什麼。我想破頭也想不出來，網路也找不到答案。 閉包與實際開發應用 IIFE（立即執行函式） 的好處我舉了幾個例子，不過後來一位工程師跟我分享 jQuery 的原始碼，說用 IIFE 的方式也可以有效幫助 minify（因為把 window 參數化了），這招倒是我以前從來沒想過的。 React、Redux 的開發場景應用考一些 Redux 常見開發情景、管理 store 的方式、react lifecycle 的應用 （更新）如何不用 + 實作加法功能這題考對 bit operator 了解。透過 XOR 可以做到，高中的加法器有教XD，不過還是要畫一下真值表。 （更新）台灣樂天市場有一句令我印象深刻的標語：複雜的東西簡單化、簡單的東西流程化、流程的東西標準化、標準化的東西自動化。（不確定原文是不是這樣） 之後問了一些比較工程化的問題，像是 CI/CD、如何跑開發流程等等，樂天市場的技術線蠻多的，Angular、React、RoR、GraphQL 都有。 面試結果因為還是資格不符，所以基本上應該是被淘汰。不過前端 team 感覺得出來相當紮實，兩位工程師除了前端外都有其他領域的開發經驗，而且相當友善，面試結束時還請我喝了一杯飲料（雖然是公司的販賣機啦XD），也給了我很多關於職涯上的建議。 4. Codementor應徵職位：Frontend Developer 做一對一的線上 mentor 的服務。衍伸出來許多服務，像是線上 code review、debug、pair programming 等等。 面試前因為技術含量高，而且面對的對象又是工程師，想說是個很好練功的地方，在 104 上投遞履歷，隔天收到 HR 線上面試邀請。我還蠻喜歡線上面試的，不用額外跑到公司一趟對工程師來說實在是一大福音啊！ 面試中第一階段 — 工程師面試 跟 team lead 面試，聊一些過去的工作經驗，問了一些開發上的問題。口頭考了一些 javascript 跟 react 的理解 閉包 flux v.s MVC 解決了什麼問題：老實說我沒有實際用過 flux，只有看過架構圖跟 code，所以只能靠自己的理解來回答 javascript 是如何做到非同步的？談對 call stack 跟 event loop 的理解 第二階段 — 與 co-founder 面試 一樣在線上跟 co-founder 聊天。這個階段比較少提技術的部分，自我介紹完了之後，他對我的一個 side project 好像很有興趣XD，問我當初成立的動機以及為什麼沒有把它變成完整的服務。有好一段時間都在談這個小專案，也有談到 code mentor 也有在做類似內容平台的服務。 後來問了一些 code mentor 的歷史以及一些團隊文化。總共約 30–40 分鐘左右 第三階段 — 與 CEO 面試 CEO 人在 California，一樣在線上面試。主要也是聊一些自己的工作內容跟開發經驗以及一些關於人格特質的問題。應該是希望從對談當中聊聊彼此之間的契合程度吧！總共約 30–40 分鐘左右。 因為 code mentor 的 co-founder 以及 CEO 都是工程師出身，聊起來相當愉快，不會有種從上往下看你的感覺。 他後來問了一題「你覺得你自己是個聰明人嗎？」。我回答不是，看過越多的程式碼與演算法後更是如此覺得。 自己可能一輩子都沒辦法設計出像 React 那麼龐大的架構，或是各種排序演算法等等，怎麼想都不覺得自己很聰明。 面試後約五天後被婉拒，好像是找到更 senior 的前端。code mentor 給我的感覺相當愉快，不管是 CEO 或是 team lead 都給我一種對自己產品相當有熱忱的感覺。希望未來還可以跟他們一起合作。 5. 17 media應徵職位：Frontend Developer 這應該是我目前面試過最愉快的一間公司。從 f2e jobs 上看到徵才資訊，一直猶豫要不要投履歷，後來是朋友推薦後獲得面試邀約。 面試中因為 team lead 是用下班時間面試 18:30。我很準時到達辦公室，team lead 也很準時出現在辦公室。這點讓我很欣賞。 有些公司因為不確定面試者什麼時候來，所以多數都是工程師還在工作的狀態下突然被通知要面試才匆匆忙忙準備相關資料，或者臨時看一下履歷表。問了一下目前到現在面試幾個人了，他還特地秀出 slack 的訊息，還順便註記了幾個人遲到。是個相當重視時間的人。 剛開始先由 HR 帶領晃過公司一圈。辦公室挺大的，零食櫃跟冰箱很猛，還有咖啡機、咖啡豆、微波爐等器具，聽說 RD team 還有另外一間辦公室，不過當天去的情況看來還是有點擠。 再來是 team lead 面試，首先先自我介紹跟講一些工作經驗。 一邊聊一邊帶到目前公司、團隊的狀況。感覺起來是個蠻保護團隊的人。之後就是 live coding 了，為了模擬真實的情況，所以不會斷網路，主要考一些 javascript 常見開發應用跟 built-in function 的實作。 寫出來之後，team lead 就會從你寫的 code 當中開始討論技術。像是這邊為什麼要這樣寫，有沒有更好的寫法等等，他花了很多時間在討論、問問題以及提出自己對這段 code 的意見，感覺就像實際在 code review 一樣。這邊也花了最久時間，大概也有 1.5hr 左右吧。 最後會給你一段髒髒的程式碼要你做 code review 跟解 bug，一起討論完之後，面試就結束了。 出辦公室的時候大概已經 21:50 幾分了吧，他很有耐心都一直在旁邊做事。比較讓我印象深刻的是我們一起討論 \\B 的用法，這是很少人會去理解的正規表達式，所以討論完原本的答案後，我就請教他 \\`B `的用法。 他很有耐心地從 \\b、\\w 到 \\B 一個一個解釋，直接解開了我長久以來的疑問。（網路上很少把 \\b 解釋的很清楚） 他給我幾個感覺： 真實：不會隱瞞公司的狀況，讓你進來後覺得被騙，而且過程中不經意會講一些工作上遇到的無奈與感嘆，感覺已經看過不少風雨。 真誠：不會用很奇怪的考題來電人，還會跟你一起討論 code quality、這段 code 要如何改進。這在面試當中是一件相當難得的事情。再來我跟他提到因為辦公室太大讓我不知道一進門要找誰時，他說會再反映給 HR。原本我以為他只是說說而已（畢竟大部分的公司也都是聽聽而已），沒想到他真的有跟 HR 反應，讓我非常感動。 面試結果offer get。HR 打電話來說明 on board 相關流程。 面試心得面試真的好累QQ，如果可以的話實在不想到處奔波，全部採用線上面試，非常符合 lazy engineer 啊！ 這次面試除了「找工作」之外，也見識到許多開發者，他們或許不常出現在各大社群當中，但是論實力跟涵養，都遠比某些在社群上膨風的開發者來得深厚。並不是說參與社群是一件不好的事，還是有很多人為社群貢獻許多，不過線下也有許多人在默默奉獻，不應該用活躍與否來判斷一個人的實力。 這一次的面試除了「找工作」這件事之外，我學到的是 — 謙遜。在軟體開發的領域中有太多聰明人了，不斷在提醒著自己有多麽無知。 1. 履歷準備因為我平常就有寫 medium 跟部落格的習慣，履歷表就能順便放進去。而且因為履歷表是放在 github 上，所以很容易更新。 2. 工作經驗工作經驗並不是把公司名稱、職稱、年資寫進去而已，你負責哪些工作內容、在公司做了什麼事情，盡量寫得具體一些，例如： 用 React、Redux 管理複雜頁面開發 優化首頁 Loading 效能 就比擔任前端開發來得好許多。 3. Side Project除了工作以外，如果有自己的 side project 就更好了，身為工程師一定會有自己想要動手解決的問題。 可以讓面試官知道你喜歡的領域以及技術線，每個專案當中一定會有一些特定的問題是困擾你很久或是花了許多時間解決的。 4. 多問問題面試應該是個你來我往的雙向溝通，而不是一場你問我答的標準流程而已，知道如何反問對方，也能夠增加對公司的了解程度。 通常我都會問一些公司內部的問題，主要會針對這幾個方面問： 有沒有自動化？很多公司都還是土炮手動 SSH 登入部署。這種開發方式很可能間接一步反映到公司文化上，例如：申請預算流程繁瑣、對能夠自動化的東西視若無睹。 如何解決 bug？解決 bug 的方式可以看出公司如何排程。例如 bug 怎麼被回報的、誰來決定 bug 的優先度等等，通常從對方的回答就能判斷他們是否有一套規範來決定如何排程的 需求是否常常變動？從需求變動這個問題來看可以從很多角度切入，什麼是常常變動？在什麼時候變動？怎樣才叫做變動？這時候就能看出這間公司是否會出現明明開發時說 A，結果交差卻說 B 的情形了。 接下來就是從這上面延伸出來的回答繼續追問了，通常看面試官的回答程度大概就知道這間公司的內部情形了。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"面試","slug":"面試","permalink":"http://kjj6198.github.io/tags/面試/"}]},{"title":"淺談 ramda 中的幾個 API","slug":"ramda-introduction","date":"2017-08-24T16:14:45.000Z","updated":"2017-08-24T16:15:41.000Z","comments":true,"path":"2017/08/25/ramda-introduction/","link":"","permalink":"http://kjj6198.github.io/2017/08/25/ramda-introduction/","excerpt":"","text":"前言ramda 是個相當好用的函式庫，如果聽過 lodash 或是 underscore 的話，可以將 ramda 想成 functional programming 的 lodash，他們的 API 有許多相似性，差別在於 ramda 本身有 FP 的功能，任何的 API 只要你沒有傳入參數，ramda 就會自動幫你做 curry，這提供了相當大的彈性。 比如說在 lodash 當中，API 常見的使用方式為： 1_.map([1,2,3], (n) =&gt; n * 2); // [2, 4, 6] 而在 ramda 當中則是： 1R.map((n) =&gt; n * 2, [1,2,3]); // [2, 4, 6] 或者你可以這樣寫： 12const times2 = R.map((n) =&gt; n * 2); // return functiontimes2([1,2,3]); // [2, 4, 6] 這種方式讓我們不用被資料綁死，可以提高復用性。 如果你想要瞭解更多有關於 FP 的資訊，我推薦這篇文章：函數式程序設計為什麼至關重要 直觀 functional programming 一樣的 input 會輸出一樣的 output，不會受到外在狀態而改變結果 沒有副作用 ###為什麼選擇 Ramda ramda 的 API 相當多，大部分的 API 也都非常直觀，所以我們也不需要一一細談。不過 ramda 中有許多優秀的 API 或許可以幫助你減少開發上的複雜度，以下介紹幾個我覺得值得一看的 API propEq接受字串當作屬性，比對傳入的物件屬性值是否相等。 12345678910const obj = &#123; name: 'kalan'&#125;propEq('name', 'kalan')(obj); // true// 等價於const propEq = (name, value) =&gt; (obj) =&gt; &#123; return obj[name] === value;&#125; zipObj將傳入的參數壓縮為 object。 1234567R.zipObj(['id', 'title'], ['2', 'mytitle']);/*&#123; id: '2', title: 'mytitle'&#125;*/ ifElse在做 branch 的邏輯時相當好用，你可能會問，幹嘛不直接用 if…else 就好？ramda 當中的 API 都是回傳函數，這代表你可以用 compose 來組裝其他 API。 compose將函式組合，執行的順序是由內到外。可以把它聯想為國高中很常見的函數題 f(g(h(x)))。所以要先計算 h(x) 的值，再依序下去。 12345const a = compose( toInteger, toCurrency('TWD'), toUppercase)(\"125000\") useWith接收一個函數跟函數陣列。將資料丟入函數陣列運算出來的結果，再丟入第一個函數當中。 善用 useWith 可以幫助我們達到 point free 的效果。 12345678910111213141516171819202122const currencies = [ &#123; name: 'TWD', shape: '$' &#125;, &#123; name: 'USD', shape: '$' &#125;, &#123; name: 'JPY', shape: '¥' &#125;, &#123; name: 'CAD', shape: '$' &#125;];// without useWithconst getCurrency = (name, dic) =&gt; R.find( R.propEq('name', name), dic);getCurrency('TWD', currencies); // $// with useWithconst getCurrency = R.useWith( R.find, [R.propEq('name'), R.identity]); // 將第一個參數傳入 R.propEq，第二個參數傳入 R.identity，運算後的結果分別丟給 R.find 的第一與第二個參數。getCurrency('TWD', currencies); 使用 useWith 後消除了 name dic 這兩個參數。 converge這個函數跟上面的 useWith 有點類似，不過 converge 只接收一個參數。下面這張圖可以很直觀地看出這兩者的差別。 123const numbers = [1,2,5,8,10];const getRange = R.converge(substract, [getFirst, getLast])(numbers); // return 9 identity有點太直觀了……，反而不知道怎麼解釋。直接用程式碼解釋比較快。 1const identify = (arg) =&gt; arg 至於為什麼要這樣做呢？有時你可能需要組織你的函數達到 chainable，這時 identity 這個函數就能夠派上用場。 tap傳入參數給指定的函數，然後回傳值。這在 debug 或是串接其他第三方的時候相當好用。 1tap(console.log)('hello world'); // 傳入 hello world 給 console.log，並且回傳 hello world 這個值 上面的例子可能看不出來 tap 的用處，我們用搭配 compose 一起使用 12345678910111213const uploadToMedium = article =&gt; API.postArticle(article);const notifyAdmin = article =&gt; API.notify(article, subscribers);const log = article =&gt; Logger.log(article)const preprocessArticle = article =&gt; article.toLowerCase()const publishPostFlow = (article) =&gt; compose( preprocessArticle, R.tap(uploadToMedium), R.tap(notifyAdmin), R.tap(log));publishPostFlow(article); 這樣一來我們可以很方便地串接其他服務，而不必再撰寫類似 return article 這樣的程式碼，一方面可以減少樣板代碼的麻煩，一方面可以減少出錯的機率。 pluck跟字面上的意思差不多，將指定參數的 value 摘取下來變成新的值。在巢狀物件取值時很有幫助，例如： 1234567891011121314const data = [&#123; id: '1', content: 'content...'&#125;, &#123; id: '2', content: 'content...'&#125;,&#123; id: '3', content: 'content...'&#125;];const getIds = R.pluck('id', data); // return ['1','2','3'] pick, pickBy, pickAll實務上我們可能不會用到物件當中所有的屬性，可能只要取出一些屬性來使用而已，這三個 pick 系列的函數可以很方便做到這件事： 123456789101112131415161718const data = &#123; \"url\": \"https://api.github.com/repos/example/magazine/issues/1\", \"repository_url\": \"https://api.github.com/repos/example/magazine\", \"labels_url\": \"https://api.github.com/repos/example/magazine/issues/1/labels&#123;/name&#125;\", \"comments_url\": \"https://api.github.com/repos/example/magazine/issues/1/comments\", \"events_url\": \"https://api.github.com/repos/example/magazine/issues/1/events\", \"html_url\": \"https://github.com/example/magazine/issues/1\", \"id\": 252372781, \"number\": 1, \"title\": \"test issue\",&#125;R.pick(['url', 'repository_url', 'id', 'name'], data); // 回傳這三個屬性的值，如果找不到此屬性直接忽略R.pickAll(['url', 'repository_url', 'name'], data) // 回傳值如果屬性存在，沒有的話會回傳 undefinedconst isURL = (value, key) =&gt; key.indexOf('_url') !== -1R.pickBy(isURL, data); // 回傳任何屬性含有 _url pathOr前端在呼叫後端 API 時，回傳的 JSON 有時會有相當深層的結構，如果用一般的方式 a &amp;&amp; a.b &amp;&amp; a.b.c 的方式取值，不僅程式碼相當雜亂，而且一旦結構過深，就要寫更多的判斷式。 pathOr 接受陣列當作取值的順序，一旦取值回傳 undefined 就會回傳預設值。 1234567891011121314const article = &#123; id: \"116208916\", author: &#123; information: &#123; birthday: \"1994-11-11\", name: 'kalan', &#125;, subscribers_count: 1239 &#125;, content: &#123; title: 'title', body: 'body' &#125;&#125; 如果後端回傳的欄位不齊全，很有可能造成錯誤發生，這個時候就能透過 pathOr 來做處理。這樣一來如果生日沒有值的話就會用「未提供生日」這個字串取代。 12const getBirthday = R.pathOr(['author', 'information', 'birthday'], '未提供生日');getBirthday(article); memoize在計算質數、階層等運算量比較大情景，為了不在每次求值時重新運算一次，可以用 memoize 函數快取已經運算過的結果。 結論ramda 是個相當好用函式庫，這篇文章提出一些在一般操作比較少見的 API，不過 ramda 本身的 API 相當豐富，搭配 compose 你可以自由組裝自己的 function，並且利用以上提到方法來簡化你的函數。 如果你也喜歡這種程式碼風格，歡迎踏入 functional programming 的世界。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"ramda","slug":"ramda","permalink":"http://kjj6198.github.io/tags/ramda/"},{"name":"javascript","slug":"javascript","permalink":"http://kjj6198.github.io/tags/javascript/"},{"name":"function programming","slug":"function-programming","permalink":"http://kjj6198.github.io/tags/function-programming/"}]},{"title":"你可能不知道的 Sass 技巧","slug":"Sass","date":"2017-08-18T09:11:38.000Z","updated":"2018-08-28T16:18:44.000Z","comments":true,"path":"2017/08/18/Sass/","link":"","permalink":"http://kjj6198.github.io/2017/08/18/Sass/","excerpt":"","text":"我發現有許多前端工程師只把 sass 當作有變數、nested class 跟 &amp; 的 CSS 來撰寫。 在 Sass 當中有許多好用的函式跟功能，如果不知道如何使用的話，對一個強大的預處理器來說，這是件相當可惜的事情。Sass3.5 的更新加強了對 css variable 的支持。 在考慮使用 CSS in Javascript 或是引入 PostCSS 的 plugin 之前，先看看是否能夠用 Sass 達到同樣的目的吧！ 變數宣告我們可以透過變數宣告 !defualt, !global 資料型別 List, Map除了一般的變數用 $ 開頭宣告之外，其實在 Sass 當中還有兩種資料型別，List 和 Map。List 就像一般 array，而 Map 有點像是 Object。 如果運用得好，我們可以收斂一下常見的變數，像是 color, font, size 等等。同時 List 與 Map 在 Sass 當中提供了一些函數來操作，像是 map-get map-has-key 等等，以下我們以常見的顏色管理做舉例。 MapSass 的 Map 類似 Javascript 當中的 Object 的功能，提供了 key-value 的方式儲存變數，並且內建一些函式以供操作。 在顏色宣告時，我們通常都會這樣寫： 123456789101112131415$mainColor: #aaa;$fontColor: #333;$dangerColor: red;.word &#123; color: $fontColor;&#125;.container &#123; background-color: $mainColor;&#125;.btn.danger &#123; background-color: $dangerColor;&#125; 如果將原本的變數改寫為 Map 的形式： 1234567891011121314151617$colors: ( main: #aaa, font: #333, danger: red);.word &#123; color: map-get($colors, font);&#125;.container &#123; background-color: map-get($colors, main);&#125;.btn.danger &#123; background-color: map-get($colors, danger);&#125; 當然，這個函數還有一些優化的空間，我們下面會再做介紹。 其他 API map-get map-has-key merge-map ListList 可以簡單的聯想為 array，Sass 內建了一些函數提供操作 List。List 的內容可以是顏色、字串、甚至塞入 Map 也可以。比如說我們想要對一連串的 content 賦值： 12345678.tag.danger::before &#123; content: \"danger\";&#125;.tag.normal::before &#123; content: \"normal\";&#125;//... 當內容一多，寫這種重複的 CSS 是一件很痛苦的事，這時候就可以使用 List 簡化操作。使用 Map 或是 List，也可以用 @each...in 的迴圈來遍歷整個 Map 或是 List。 123456789101112$contentList: ('danger', 'normal', 'suck');@each $content in $contentList &#123; .tag.#&#123;$content&#125;::before &#123; content: $content; &#125;&#125;// compiled.tag.danger &#123;&#125;.tag.normal &#123;&#125;.tag.suck &#123;&#125; 管理 z-index運用 List 當中的 API 來管理複雜的 z-index。 z-index 一直是每個前端工程師的心頭之痛，因為很容易就使用 magic number 來管理。一般的解決方法是用變數的方式來管理： 12345678910$zindex-dropdown-backdrop: 990 !default;$zindex-navbar: 1000 !default;$zindex-dropdown: 1000 !default;$zindex-fixed: 1030 !default;$zindex-sticky: 1030 !default;$zindex-modal-backdrop: 1040 !default;$zindex-modal: 1050 !default;$zindex-popover: 1060 !default;$zindex-tooltip: 1070 !default;// 取自 bootstrap 代碼 我們可以運用 index 這個 API 搭配 List 達到類似的效果： 123456789101112131415161718192021222324$zIndexs: ( 'dropdown-backdrop', 'navbar', 'normal', 'dropdown', 'fixed', 'sticky', 'modal-backdrop', 'modal', 'popover', 'tooltip');.dropdown &#123; z-index: index($zIndexs, 'dropdown') // 類似 indexOf&#125;.dropdown-backdrop &#123; z-index: index($zIndexs, 'dropdown-backdrop');&#125;// ....tooltip &#123; z-index: index($zIndexs, 'tooltip');&#125; 這樣一來，我們除了可以減少變數前綴的麻煩，也可以避免用區間來防止 z-index 被其他元素時插入的困擾。（只要直接在 List 加入值就好，不用再修改其他值）。 以上 Map 與 List 的介紹用實例讓大家了解在實際開發時的運用，當然使用場景不限於以上兩種而已。 我們之後會再優化這些 function。 其他 list 函數 nth index join append zip length 內建函數在 Sass 當中有一些函數可以幫助簡化 CSS 檔案。 darken lighten這兩個函數在操作 hover 狀態時非常好用，有時候我們收到的需求是：「hover 後的顏色變暗 10%」，通常設計師會直接給你顏色，不過透過 darken, lighten 這兩個函式操作的話能夠讓我們在實際開發上更有彈性。 1234.btn &#123; background-color: #000; &amp;:hover &#123; background-color: #333; &#125;&#125; 搭配 darken, lighten 1234.btn &#123; background-color: #000; &amp;:hover &#123; background-color: lighten(#000, 30%); &#125;&#125; rgba rgbSass 支援 rgba 與 hex 混合的語法，你可以直接這樣寫： 12345body &#123; background-color: rgba(#000, 0.3); // compiled background-color: rgba(0, 0, 0, 0.3);&#125; 比起原生的語法要額外寫 RGB 這三個參數，直接用 16 進位的表示法相對簡潔許多。Sass 會自動偵測是否要幫你轉換。 invert將輸入的顏色反轉。 @at-root在開發時，如果想要 access 到外層的 class，又希望保持模組化所以將 class 寫在 nested 內時，@at-root 就相當好用。 12345678910111213141516.tooltip &#123; //... font-size: 20px; @at-root body.active .tooltip-backdrop &#123; position: fixed; &#125;&#125;// compiled.tooltip &#123; font-size: 20px;&#125;body.active .tooltip-backdrop &#123; position: fixed;&#125; 加入 @at-root 之後，編譯後會將 class 搬移到最外層，而不是在 tooltip 裏面。這在保持模組化時、不想將 class 寫在外層、不想導致太深層的巢狀 class 時相當有用。 mixinmixin 在 autoprefixer 還沒有發佈之前，一直都被用來當作加入前綴使用。不過除了前綴之外，我們還能夠利用 mixin 做到許多事。像是： 管理字體大小 設定常見的 media query 簡化 class mixin 的撰寫方式是以 @mixin 作為開頭，呼叫時用 @include。 管理字體大小在 desktop 以及 mobile 上我們可能有不同的字體大小或字級想要管理，首先我們能夠用 map 宣告字體大小，再搭配 mixin 簡化流程。 123456789101112131415161718192021222324252627282930313233343536373839$fontSizes: ( desktop: ( 'x-large': 32px, 'large': 30px, 'medium': 26px, 'normal': 18px, 'small': 14px, 'x-small': 12px ), mobile: ( 'x-large': 28px, 'large': 24px, 'medium': 20px, 'normal': 16px, 'small': 12px, 'x-small': 10px ));@mixin font-size(size: \"normal\") &#123; @media screen and (min-width: 768px) &#123; $desktop: map-get($fontSizes, desktop); font-size: map-get($desktop, size); &#125; @media screen and (max-width: 767px) &#123; $mobile: map-get($fontSizes, mobile); font-size: map-get($mobile, size); &#125;&#125;.article &#123; @include font-size(normal); &amp;.large &#123; @include font-size(large); &#125;&#125; 這樣一來可以很容易地在手機、桌面中切換不同的字級設定。 管理 @media在 class 寫一大堆 @media 是一件很頭痛的事，我們可以設定好 $breakpoint 的變數後，再利用 mixin 封裝。 12345678910111213141516$breakpoints: ( desktop: 960px mobile: 568px,);@mixin for-mobile &#123; @media screen and (max-width: map-get($breakpoints, \"mobile\")) &#123; @content; &#125;&#125;@mixin for-desktop &#123; @media screen and (min-width: map-get($breakpoints, \"desktop\")) &#123; @content; &#125;&#125; 你也可以將所有的 breakpoint 統一封裝為一個 mixin，並且透過傳入參數的方式來決定，不過分開的寫法比較直覺一些。 Function在 Sass 當中寫 function 非常簡單。宣告 function 時用 @function 表示： 123@function return123 &#123; @return \"123\";&#125; 或者加入參數： 12345@function returnString($string) &#123; @return $string;&#125;returnString(\"123\"); // \"123\" Sass 裡頭有迴圈、for-loop、while 等等的功能，所以你可以客製化自己想要的函數，幫助開發。 Logging在 sass 當中，我們可以利用 @warn 、@error、@debug 這兩個函數做更好的開發體驗。 123456789@function getMessage($message, $type: \"error\") &#123; @if $type == \"error\" &#123; @error $message; &#125; @elseif $type == \"warn\" &#123; @warn $message; &#125; @else &#123; @debug $meesage; &#125;&#125; 如果你是使用原生的 Sass 編譯，則 error 會直接打斷編譯流程，並且印出錯誤在 stdout，使用 warn 的話不會打斷編譯，但會印出訊息在 stdout 上，而 debug 則是單純印出在 stdout 上。 搭配以上的功能，我們來實作一些在開發上常見的函數吧！ BEM utils為了讓 CSS 保持命名空間，我們常常使用 BEM 來組織 CSS 代碼。不過卻常常出現 __、-之類不太好看的符號，一不小心就可能打錯，我們可以使用 mixin 封裝這個功能。 12345678910111213141516171819202122232425262728293031@mixin block($block_name) &#123; .#&#123;$block_name&#125; &#123; @content; &#125;&#125;@mixin element($element_name) &#123; @at-root &amp;__#&#123;$element_name&#125; &#123; @content; &#125;&#125;@mixin modifier($modifier_name) &#123; @at-root &amp;--#&#123;$modifier_name&#125; &#123; @content; &#125; &#125;@include block(article-entry) &#123; padding: 20px; @include element(content) &#123; font-size: 20px; &#125; @include element(footer) &#123; background-color: #fff; @include modifier(larger) &#123; height: 500px; &#125; &#125;&#125;//.article-entry &#123; padding: 20px; &#125;.article-entry__content &#123; font-size: 20px; &#125;.article-entry__footer &#123; background-size: #fff; &#125;.article-entry__footer--larger &#123; height: 500px; &#125; 注意到我們在 mixin 當中使用了 @at-root，所以編譯的 CSS 會一律放到最頂層，這可以解決 BEM 層數太深的問題，也可以在開發時保持良好的模組性。你也可以在 mixin 加上一些參數決定是否要套用 @at-root 來保持開發上的彈性。 z-index 管理在上面的例子當中，我們利用 map-get 來取值，在實際開發上我們可能會想要再簡化一些，現在搭配 @function 做改善。 123456789101112131415161718192021222324252627282930313233$zIndexs: ( 'dropdown-backdrop', 'navbar', 'normal', 'dropdown', 'fixed', 'sticky', 'modal-backdrop', 'modal', 'popover', 'tooltip');@function zindex($name: normal) &#123; $index: index($zIndexs, $name); if (!$index) &#123; @error \"#&#123;$name&#125; doesn't exist! please checkout your `$zIndexs` variable.\"; &#125; @return $index;&#125;.dropdown &#123; z-index: zindex('dropdown') // 類似 indexOf&#125;.dropdown-backdrop &#123; z-index: zindex('dropdown-backdrop');&#125;// ....tooltip &#123; z-index: zindex('tooltip');&#125; 我們將 $zIndexs 包裝起來，並且如果傳入的參數並不存在於 $zIndexs 當中就會直接打斷編譯過程，並且顯示錯誤，也提供了相關的錯誤訊息給開發者參考。 引入 css variable目前比較新的瀏覽器都已經支援 css variable 了。我們可以將顏色等變數使用 css variable 重新撰寫，並且使用優雅降級來確保在其他瀏覽器也能正常工作。 123456789101112131415161718192021222324252627282930313233343536373839$colors: ( main: #aaa, font: #333, danger: red);:root &#123; @each $key, $color in $colors &#123; --#&#123;key&#125;: $color; &#125;&#125;@mixin css($prop, $key) &#123; #&#123;$prop&#125;: map-get($colors, $key); @if (map-has-key($colors, $key) == false) &#123; @error \"Unknown key `#&#123;$key&#125;`. checkout your `$colors` variable\"; &#125; @supports (--foo: \"bar\") &#123; #&#123;$prop&#125;: var(--#&#123;$key&#125;); &#125;&#125;.container &#123; @include css('background-color', \"main\");&#125;// compiled:root &#123; --main: #aaa; --font: #333; --danger: red;&#125;.container &#123; background-color: #aaa; @supports (--foo: \"bar\") &#123; background-color: var(--main); &#125;&#125; 這個 @mixin 寫得比較陽春一些，你可以加入更多參數或修改讓這個 mixin 能夠配合其他屬性。 結論PostCSS, CSS in Javascript, styled-component，都是為了解決問題而發展出來的工具，不過 Sass 也有許多功能值得大家參考，這篇文章提出一些常見的開發問題，並使用 Sass 來解決。Sass 的函數並沒有想像中那麼複雜，而且功能強大，你甚至可以利用 Sass 的內建函數來建置 sin, cos 等三角函數幫助運算，撰寫排序演算法、使用遞迴（如果你想的話…）。 使用 Sass 並不代表你需要拋棄 PostCSS 或其他工具帶來的便利性，像是 autoprefixer 以及 cssnano 等等，都是相當好用的插件。你甚至可以搭配使用帶來更快速及穩固的開發體驗。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"sass","slug":"sass","permalink":"http://kjj6198.github.io/tags/sass/"}]},{"title":"飛機能飛嗎 — 天氣造成的空難","slug":"aircrash-extreme-weather","date":"2017-08-05T12:00:07.000Z","updated":"2017-08-05T12:17:34.000Z","comments":true,"path":"2017/08/05/aircrash-extreme-weather/","link":"","permalink":"http://kjj6198.github.io/2017/08/05/aircrash-extreme-weather/","excerpt":"","text":"我並不是機師或是受過訓練的專業人士，只是剛好家住在機場附近，喜歡看看飛機了解一下空難而已，以上言論難免有錯誤之處，盡請斧正。另外本篇文章可能會造成閱讀者的情緒不安或焦躁，在閱讀前請三思 最近這幾天長榮員工因尼莎颱風集體請天災假，除了引起廣大迴響跟在 PTT 上實況飛機降落情形外，好像也就這樣了。剛好天時地利，寫篇關於天氣造成的空難，希望能夠讓各位（以及自己）更了解天氣對飛機產生的影響。 剛搬完新家兩個月，大約在行天宮靠近飛機巷的位置，從窗外的陽台就能聽見、看見 20 幾架飛機降落，當天的颱風夜也是。 我對飛機跟機師一直以來都是抱持著景仰的心態，跟軟體開發不同，那是一個無法容忍 bug 的世界，任何一個失誤都會造成無法挽回的結果。同時，撰寫一個穩定的飛機內部程式，代碼數應該就超過 100 萬了吧？已經遠超出我目前寫過的代碼了。 前言 — 你有勇氣嗎？在閱讀本篇文章之前，請先確認自己對空難的接受度。 如果你是那種會在颱風夜的機場大呼小叫的乘客，希望你看完這篇文章後能夠學會閉嘴；如果你上飛機第一件事是睡覺而不是看一下逃生門在哪，希望你以後會記得。 天氣對飛機造成的影響風現代的飛機設計通常都可以應付天氣惡劣的狀況。即使如此，在起飛、降落這兩個程序當中，仍然會有許多突發狀況。 起飛時，因為飛機在滿載燃油、乘客的狀況下起飛，又因為剛開始的速度不足，需要靠襟翼、縫翼這兩個機翼的幫忙來提昇受風面積、增加昇力，飛機才能夠順利起飛。 如果這時風向突然改變，從逆風變為順風，就有可能因為空速不足而導致升力降低。通常會提高機鼻以及增加動力來獲得升力。 但是在颱風這種極端天氣下，如果風速的變化相當劇烈，飛機很容易受到影響，如果來不及在風速改變時作出反應（飛機加速、減速都需要時間），很有可能來不及控制飛機就出事了。 下降時也是一樣，如果突然由逆風變順風，導致降落速度增加，甚至是風切變等狀況，在颱風的影響下所有的風速都會對飛機產生巨大的影響。 風切變簡單來說就是風速、風向在兩點之間的急劇變化。飛機這種龐然大物很容易受到風的影響，如果風速急劇變化，會導致飛機在短時間內有劇烈的速度、高度變化，這也是為什麼在颱風降落時會有大怒神的感覺。（相信我，你不會想要體驗的） 降落速度太快，飛機就會衝出跑道；速度太慢，飛機有可能失速而垂直落地。 我搭飛機那麼多次遇到颱風也沒事啊 當然，機長們受過專業的訓練，會盡量地往天氣最好的地方飛行，降落時也會無所不用其極地找出最佳的進場時機。但中華航空642班機就沒有那麼幸運了。 這台飛往香港的班機中，因為當天的天氣不佳，側風在下降時甚至超出標準，但機長仍然選擇降落，最後因為被起降架無法承受負荷而斷裂，右機翼斷裂往右翻滾，最後再跑道的草皮上停止。 看完你一定會想，WTF 都已經降落了還空難，怎麼那麼雖小？是的。 除了天氣本身會直接影響飛行之外，這場空難的最主要原因是機長與副機長並未按照標準程序操作。 蛤？不按照標準程序操作，機長跟副機長也太不專業了吧？在責怪機師不專業之前，我們先想想他們要承擔的責任有哪些。 把乘客平安送到目的地 聽命公司的要求起飛（而非出自專業判斷） 若決定停飛，可能被公司檢討，可能會上明日報紙頭條，可能會被其他航空公司嘲笑 若決定不降落，可能會被公司檢討，受到乘客指責，明日上頭條 有沒有發現什麼不對勁了？機師的判斷竟不全然來自專業，而是受到多方面的影響，這是多麽不合理的一件事情。 機師也是人，難免會夾雜情緒在裡頭。所以儘管天氣不允許，機師們還是得咬牙放手一搏。儘管現在現代飛機的設計已經相當進步，但我們真的能夠全身而退嗎？ 霧、雨霧跟雨是相當常見的天氣因素。霧最直接的影響就是能見度。飛機目前可以靠儀器降落系統（ILS）完成降落。這個精密的儀器能夠告訴飛機跑道的中線，以及下滑的軌道，至於更詳細的原理可以參考維基百科。 但是飛行員通常還是需要目視跑道，確認飛機飛在正確的路線上。關於目視跑道有一套規定，飛行員如果找不到跑道，最低能夠下降到某個標準高度。 如果在這個標準高度內仍然沒有找到跑道就要執行迷失進場（missing approach）程序並且重飛（Go around），但有時候因為機師過於自信、受外力影響、天氣影響等等原因，可能就會不遵守此程序。 像是波蘭空軍圖-154墜機事件就是一個相當經典的例子。 這架載著波蘭總統列赫·卡辛斯基以及多個高層長官的飛機，企圖在俄羅斯斯摩棱斯克降落時墜毀。當時因為機場起大霧，能見度只有 500 公尺左右，因此塔台建議飛行員直接飛往備降機場。 但此建議被機長拒絕，並且嘗試到 100 公尺高度時若不能降落在使用自動駕駛儀重飛。 結果導致機翼撞上樹梢墜落至地面解體，起火燃燒。機上乘客與機組人員 97 名全部遇難。 當時調查人員的結果認為，當時飛行員承受了間接壓力。有波蘭外交部禮賓司長、波蘭空軍司令官在後頭盯著你，硬著頭皮也要開下去。結果就釀成悲劇了。 前幾年發生的復興航空222號班機空難也是因為能見度影響、飛行員未遵守盲降標準而讓飛機在高度過低的情況下撞上樹林。（當然除了未遵守標準降落還有其他因素綜合在一起才導致這場悲劇）。 其他因能見度導致的空難 新加坡航空006號班機空難 冰雹冰雹對飛機來說是個相當可怕的夢魘，因為時速高達 800 ~ 900 公里的飛機，撞到冰雹可不是鬧著玩的。如果撞到擋風玻璃有可能會導致碎裂，被引擎吸入也可能導致引擎故障。南方航空242號班機空難就是因為在暴風雨區被冰雹侵襲，導致兩具引擎熄火故障，最後因迫降失敗而墜毀在公路上。 其他因天氣因素而觸發的空難如果你對因天氣引起的空難有興趣，可以參考維基百科的連結，或許可以給你更多的啟發。 事實上儘管是天氣因素影響，但仍然有 80% 的空難是因為人為錯誤而發生的。關於空難，很常見的心態是：「這次不一樣」 因為科技進步，所以這次不會墜機； 因為有XXX輔助，所以這次不會墜機； 因為已經建立了標準程序，所以這次不會墜機； 因為已經…，所以這次不會…。 這次不一樣實在是個可怕的心態。 如果不幸發生空難人生總是充滿著意外，僅管搭飛機的意外次數已經遠小於車禍（兩位受過正規訓練的機師、精密儀器輔助的飛機），要讓飛機墜毀是一件不容易的事。但我們還是要以防萬一。 在每趟飛行前記得保旅行平安險及旅行不便險，確保飛機在任何狀況下延誤，或是不幸發生空難時，能夠獲得最大的保障。至於如何挑選保險就看各位的需求了。 如果在飛機上發生空難，請先保護自己再去想辦法救別人。確定氧氣罩戴好能夠吸到氧氣，再來幫助別人。 在起飛前靜下心來聽空服員解釋逃生設備以及使用方式，他們很有可能救你一命。 採取防撞姿勢，雙手抱頭向前彎曲，頭貼在前方的座椅上，將撞擊力道降到最低。（以上描述僅為示意，詳細的防撞姿勢以空服員指導為準） 平時就當一位合格的旅客，不吵鬧、不喧嘩、不對空服員、地勤大呼小叫、多積點陰德。讓服務你的人心情舒適是確保整趟旅程品質的不二法門。 接下來可以怎麼做？ 僅靠政府、民航局來監督航空公司已經不太可靠。但人民團結起來的力量不容忽視，為了自己的生命著想，希望你能多關注這方面的議題，適時發聲與撻伐（記得理性溝通），讓航空公司想要說幹話的時候先三思。 嚴格遵守飛安標準。關於起飛與降落有一套標準規範（根據飛機與航空公司各有不同），必須要求航空公司嚴格遵守。 建立配套措施，讓颱風天仍然得上班的行業有個安心工作的環境。 結論1. 尊重專業無論何時我們都應該尊重專業，不僅是機上的機師，各行各業皆如此。不過尊重專業的前提是對方要是位專業人士。 2. 讓錯誤被大家看見空難不應該是大家說聲 R.I.P 就了事了，如果幾十人甚至幾百人的生命只能換來 R.I.P 的話是很令人扼腕的結局。每場空難都是相當珍貴的經驗。 3. 創造讓機組人員能夠安心的環境這在現在的台灣或許還是天方夜譚。但對於不合理的工時、環境、要求的公司，我們應該要能夠抵制或是拒乘，讓雙方的談判籌碼對等，才有扭轉的空間。而機師能夠心無旁騖地，依照自己的專業而非高層壓力做判斷。做得好就鼓勵，不按照程序飛行的機師我們也要幹到爆，讓他們知道背後都是有雙眼睛在監督著的。 4.不要讓天氣控制了情緒大家都想搭飛機，前往目的地。但無論如何，安全仍然是最重要的事，我們能做的是緩和自己的情緒。 停飛不是兒戲，不管對機長、航空公司、乘客來講都是個耗時、花費金錢的決定。 如果機師不需要再背負上層壓力；如果對於惡劣天氣的應對不是先試試看再說；如果公司講幹話、做蠢事能夠受到制裁，或許大家都可以過得輕鬆一點。 好吧講太遠了。 最後如果你對飛機、空難有興趣的話，可以搜尋看看 Discovery 的空中浩劫，你會發現空難的原因五花八門，遠超乎你的想像。有把飛機給小孩開結果墜機的；有兩台飛機在跑道上互撞直接罹難的；有在天空上沒有燃油最後滑翔到機場的；有起飛時踩著煞車硬要飛結果墜機的；有自動駕駛跟駕駛操作衝突而墜機的；有飛機不聽話結果墜機的；有因為貨艙放太多酒精結果燒起來而墜機的……，或許這些看似與我們無關的空難，能夠對你有些幫助。 本篇文章無意對任何機師、機組人員提出批評，只是分享個人觀點以及整理因天氣因素發生的空難事件。 最後，祝福每位機師跟乘客旅途愉快。 Bon Vayage!","categories":[{"name":"雜談","slug":"雜談","permalink":"http://kjj6198.github.io/categories/雜談/"}],"tags":[{"name":"飛機","slug":"飛機","permalink":"http://kjj6198.github.io/tags/飛機/"},{"name":"空難","slug":"空難","permalink":"http://kjj6198.github.io/tags/空難/"},{"name":"天氣","slug":"天氣","permalink":"http://kjj6198.github.io/tags/天氣/"}]},{"title":"淺談降維方法中的 PCA 與 t-SNE","slug":"PCA-and-t-SNE","date":"2017-07-17T16:00:00.000Z","updated":"2017-07-19T14:29:06.000Z","comments":true,"path":"2017/07/18/PCA-and-t-SNE/","link":"","permalink":"http://kjj6198.github.io/2017/07/18/PCA-and-t-SNE/","excerpt":"","text":"在機器學習當中，如果特徵數過多時，有可能會造成一些問題，像是： 過擬合 (overfitting) 處理速度較慢 如果超過三個特徵以上不好視覺化 所以這時候就需要對特徵做降維，在實務上，一個幾百幾千個的特徵當中，手動挑選特徵顯然不是一個明智的方法，所以以下來介紹兩個在機器學習中常常使用的兩種降維方法。 PCA（principal component analysis）主成份分析在介紹 PCA 之前，我們先來定義一下我們的目標是什麼： 將一個具有 n 個特徵空間的樣本，轉換為具有 k 個特徵空間的樣本，其中 k &lt; n 以下是 PCA 的主要步驟： 將數據標準化 建立共變異數矩陣（covariance matrix） 利用奇異值分解（SVD）求得特徵向量（eigenvector）跟特徵值（eigenvalue） 通常特徵值會由大到小排列，選取 k 個特徵值與特徵向量 將原本的數據投影（映射）到特徵向量上，得到新的特徵數 PCA 最重要的部分就是奇異值分解，因此接下來的章節讓我們來談談奇異值分解 直觀理解奇異值分解在矩陣分解當中，奇異值分解是個相當有名的方法。矩陣分解在高中數學當中最常見的用途就是解方程式（如 LU 分解），從奇異值分解的公式當中我們可以直觀地了解： 其中 A 為一個 m x n 的矩陣，𝑈 跟 V 都為正交矩陣，𝛴 為奇異值矩陣。奇異值矩陣為矩陣 A 對應的特徵值，在 PCA 當中又叫做主成份，代表對保存訊息的重要程度，通常由大到小遞減排列在對角中，是個對稱矩陣。 那麼這邊的 A 對應什麼呢？當然就是我們的特徵，只是特別要注意的是這邊的 A 我們通常使用共變異數矩陣（covariance martix）來求算，記得資料一定要先正規化後在進行奇異值分解 共變異數矩陣（covariance matrix） 因為共變異數矩陣常用 Sigma 表示，不要跟上面的 𝛴 搞混囉。因此如果要降維，我們可以用 U 的前 k 列乘上對應 𝛴 當中的特徵向量，就可以得出新的特徵了，而從幾何的角度來看 這樣子的運算在幾何當中，其實是將 X 投影到 U 的前 k 個向量 當中的黑線為特徵向量，長度為特徵值。 當中的藍點為數據原本的位置，紅點則是投影到特徵向量的位置。以上，我們成功將 2 維的數據降至一維了。 當然也可以從 3 維降到 2 維： PCA 的應用在降維的時候，我們希望留下最重要的特徵，剩下的比較不重要的特徵我們直接捨棄掉。 像是判斷一個人時，最重要的判別方式可能就是眼睛、鼻子、嘴巴等等，所以膚色、頭髮等等的特徵我們就可以捨棄，事實上在人臉辨識當中也常利用 PCA 做降維。 這是對奇異值分解相當直觀的了解，篇幅關係無法深入細談，若對奇異值分解有興趣可自行到維基百科 t-SNEPCA 是個相當直觀且有效的降維方式，不過在三維轉換為二維時我們可以看到，有些數據的集群完全被搗成一團。 PCA 是一種線性降維的方式，但如果特徵與特徵間的關聯是非線性關係的話，用 PCA 可能會導致欠擬合（underfitting） t-SNE 也是一種降維方式，不過他用了更複雜的公式來表達高維與低維之間的關係。t-SNE 主要是將高維的數據用高斯分佈的機率密度函數近似，而低維數據的部分使用 t 分佈的方式來近似，在使用 KL 距離計算相似度，最後再以梯度下降（或隨機梯度下降）求最佳解 。 高斯分佈的機率密度函數 其中，X 為隨機變量，𝝈 為變異數，𝜇 為平均。 因此原本高維的數據可以這樣表示： 而低維的數據用 t 分布的機率密度函數可以這樣表示（自由度為 1） 其中，x 為高維當中的數據，y 為低維當中的數據。P, Q 分別代表機率分佈。 為什麼會使用 t 分佈來近似低維的數據呢？主要是因為轉換成低維之後一定會丟失許多訊息，所以為了不被異常值影響可以使用 t 分佈。 t 分佈在樣本數較少時，可以比較好模擬母體分布的情形，不容易被異常值所影響。 T 分佈與高斯分佈的機率密度函數 兩個分佈之間的相似度求算兩個分佈之間的相似度，經常用 KL 距離（Kullback-Leibler Divergence）來表示，也叫做相對熵（Relative Entropy）。 在 t-SNE 中使用了困惑度（Perp）來當作超參數。 論文中提出通常困惑度在 5 ~ 50 之間。 Cost function用 KL 距離計算 Cost 求梯度可以寫成 最後再利用梯度下降法（或隨機梯度下降法）就可以找到最小值了。 實測：使用 MNIST 測試測試集可以到這裡下載，首先我們先用 PCA 降到二維看看。 PCA PCA 降維 可以發現降到二維之後，資料幾乎被搗成一團，完全看不出集群，這是因為 PCA 的線性降維在過程中損失太多訊息。 t-SNE 接下來使用 t-SNE 測試 使用 t-SNE 降維 這是使用 t-SNE 後的降維結果，可以發現降維過後，資料仍然分群地相當明確。從這兩張圖可以非常明顯看出這兩者（PCA, t-SNE）的差別。 小結後來又有人提出一連串改善 t-SNE 效能的演算法，詳情可以參考Accelerating t-sne using tree-based algorithms，大部分熱門的資料分析程式語言也都有實作，像是 sklearn, R, matlab 等等。 不過畢竟 t-SNE 不是線性降維，在執行時間上會比 PCA 來得久許多。 當特徵數量過多時，使用 PCA 可能會造成降維後的特徵欠擬合（underfitting），這時可以考慮使用 t-SNE 來降維 t-SNE 的需要比較多的時間執行 論文當中還有一些優化技巧（如何選擇困惑度等等），因為還沒有閱讀完畢，之後會再逐漸補上 參考資料 Van der Maaten L, Hinton G. Visualizing data using t-SNE Accelerating t-sne using tree-based algorithms 利用各種樹的演算法來加速 t-SNE 的運算 線代啟示錄 - 奇異值分解 文章同步發表於 medium","categories":[{"name":"機器學習","slug":"機器學習","permalink":"http://kjj6198.github.io/categories/機器學習/"}],"tags":[{"name":"降維","slug":"降維","permalink":"http://kjj6198.github.io/tags/降維/"},{"name":"PCA","slug":"PCA","permalink":"http://kjj6198.github.io/tags/PCA/"},{"name":"t-SNE","slug":"t-SNE","permalink":"http://kjj6198.github.io/tags/t-SNE/"}]},{"title":"做了一份週刊 - 日語八百屋","slug":"what-is-yaoya","date":"2017-07-13T16:00:00.000Z","updated":"2017-07-19T14:52:32.000Z","comments":true,"path":"2017/07/14/what-is-yaoya/","link":"","permalink":"http://kjj6198.github.io/2017/07/14/what-is-yaoya/","excerpt":"","text":"自學日文也已經三年多了，做了一份周刊，叫做日語八百屋。 粉絲專頁 Medium 什麼是日語八百屋？八百屋的由來源自於日語的八百屋（やおや），除了大家熟知的「蔬菜店」之外，也有「很多」的意思在裡頭。 我的目標很簡單：「滿足日文、日本、日劇愛好者們的求知慾以及資訊焦慮症。幫助減少學習阻礙、資訊不對稱、增加日本文化知識，內容涵蓋了日語學習、日本旅行、日本文化、動漫、語言學習技巧等等。」 學語言，多的是從微不足道的小事開始，50 音、文法、單字、敬語，最後內化成自己的事物，積跬步，成千里，最後逐漸變成「八百」。 學英文的線上資源很多，平台也相對完整，voicetube、希平方、tutorABC 都是不錯的學習管道，有大量的影片可以學習，在網路上用心搜尋，也能夠找到不錯的資源。 不過在學習日文的資源相對較少，多數都是從部落格上、FB 社團上而來的片段資訊。像是音速學習日語、王可樂的日語教室等等，仍然是以傳統的線下教學或是買書自學居多。 訂閱了週刊之後，每個禮拜一早上，我們都會寄送 5 ~ 10 篇不等的文章給讀者們閱讀。 為什麼不用經營粉絲專頁的方式就好？這答案其實蠻主觀的，因為日語相關的粉絲專頁幾乎是多到噴出來，在 facebook 順手搜尋日語、日文、日劇就會出現數不清的專頁。 然而，這些片段的資訊散佈在網路的各個角落，不僅統整困難之外，初學者在茫茫大海中也不知道該從哪裡開始。 分享特定領域的資訊不是我們的目的，而是想要不侷限在文法、單字、日文學習的範圍上，盡量由多面向的方式更深入日文這個語言。 出書跟開課，我們沒有那麼多的資源這樣做，而且坊間已經有很多人在這樣做了。 粉絲專頁，也夠多人在經營了，不缺我這一個興趣使然的日語學習者。所以對我來說目前最簡單也最純粹的方式就是寄送 email。 開設的粉絲專頁只是用來做推廣而已，基本上不會有太多貼文。 跟一般的粉絲專頁有什麼不一樣？不過，如果只搜集文法、單字相關的資訊，似乎有些枯燥乏味，而且網路上、各大書店、部落格上的內容豐富，絕對有許多優秀的教材。 要說不一樣的話，我們主要是用 email 來推送內容的。 email 雖然不像 facebook 那樣即時，但這反而是個優點，可以讓你只專注在目前的內容中。再來 email 不會被其他外在因素干擾，而且大家檢查 email 的頻率大概只比 facebook 少一點點吧！ 利用 email 渾然天成的特性，我們一週會推送 5 ~ 10 篇不等的文章，絕對是在一週（甚至是一天）看得完的份量。 雖然不一定能對學習有顯著的幫助，但希望能夠藉由這樣的方式，不僅擴展自身對日文的理解之外，也順便了解日本文化。因此，涵蓋的範圍很廣，有關於日本文化的，都可以是本週刊的素材之一。 未來希望能夠讓大家都能夠輕易地分享自己的筆記或連結，讓這份週刊的廣度更活躍，所以如果有人也願意分享文章或是學習筆記的話那就太好了。 畢竟一個人對日本所知有限，有人每天追劇、有人追動漫、有人對歷史瞭若指掌、有人可能懂得分析經濟等等。但如果能夠把這些內容結合起來，這份週刊就會變得非常有料：）。 最後，不妨到網站訂閱一下 https://www.shurado.com 吧！ 技術線因為想要專注在寫文章上，花了兩天左右建好網站，並且逐漸擴充功能，反正最基本的功能只要達到： 寄信 製作電子報 寄送電子報 存放歷期週刊的頁面 首頁 基本上就差不多了。整個 app 是用 Ruby On Rails 寫的，用 Redis 管後台任務，比較麻煩的頁面互動就用 react + redux + redux-observable 解決。 寄信的功能主要串接了 mailgun 跟 mailchimp 這兩個第三方套件。mailgun 是負責寄送單一信件，例如訂閱確認信等等；而 mailchimp 則是負責寄送電子報。兩個的 API 都還蠻好串接的，文件也寫得很不錯。 之後還會陸續加上一些功能，例如： 在後台發布文章時，能夠同步發表到 medium 跟粉絲專頁 日文文章可以依照需求加入平假名讀音 可以用搜尋的方式找到想要的週刊或 issue 後記想說在畢業前好好做點事情，所以趁著熱情還沒消失前，也在 hahow 上開了一門課叫做從 0 到 1 - 為初學者而設計的日文課，整理了基本的日文文法。 後來想想，訂價實在太便宜，$1500 裡頭涵蓋的文法幾乎是一堂 $10000 出頭的補習班課程。 不過結果還挺出乎意料的。原本想說能夠成功開課就不錯了，沒想到現在募資率竟然已經破 900% 了。現在想想，如果知道準備一門課那麼累的話，或許我就不會開課了，尤其是在雙語之間上字幕，實在有夠累人。 心得不知不覺這份週刊已經要到 20期了，最大的體會是技術已經不是最大的瓶頸，而是如何產生這些內容。雖然之後或許可以靠著機器學習的幫忙省下一些功夫，不過內容的生產永遠是有需求的，不過光有內容，卻沒有良好的體驗來吸引讀者們的話，再怎麼努力產出也是白搭。 希望能夠繼續堅持下去。","categories":[{"name":"日語學習","slug":"日語學習","permalink":"http://kjj6198.github.io/categories/日語學習/"}],"tags":[{"name":"日語學習","slug":"日語學習","permalink":"http://kjj6198.github.io/tags/日語學習/"},{"name":"日語八百屋","slug":"日語八百屋","permalink":"http://kjj6198.github.io/tags/日語八百屋/"}]},{"title":"redux-saga 與 redux-observable(待整理)","slug":"redux-saga-and-redux-observable","date":"2017-05-04T16:00:00.000Z","updated":"2018-08-28T16:18:55.000Z","comments":true,"path":"2017/05/05/redux-saga-and-redux-observable/","link":"","permalink":"http://kjj6198.github.io/2017/05/05/redux-saga-and-redux-observable/","excerpt":"","text":"前陣子有幾個很突出的函式庫，專門處理 redux 當中非同步的 action。最簡單暴力有效的方法是 redux-thunk，的確，一般的 ajax call 或是簡單的發送非同步請求時，thunk 能夠很直覺也很方便地完成我們要的需求。 但，如果是更複雜的應用呢？比如說： 為了減少伺服器的負擔，我們只想要對使用者最後的操作做處理 如果發送請求之後，在還沒取得回應之前，我們想要取消請求 如果我們要在 action 裡頭對這些請求做判斷，很快這些 action 就會變得肥大臃腫，逐漸難以維護。而且，thunk 並沒有辦法取消請求。 這篇文章會透過範例，介紹 redux-saga 跟 redux-observable，並且分析兩者的不同之處，最後再來做比較。 要解決什麼問題？這兩個函式庫雖然風格非常不同，但是要解決的問題是相同的，有效管理 side effect。而最大的不同點在於，redux-observable 使用 RxJS 實作，而 redux-thunk 使用 es6 的 generator。 所有解決非同步的方式都有一種目的，讓非同步的操作看起來像是同步的。 callback最剛開始的解決方案是 callback，但缺點顯然易見，很快就會因為多層牽套的關係導致越深層的程式碼越來越難維護。 Event後來，採用監聽 event 的方式，我們可以很快地對事件變化做特定的行為，這在簡單的非同步狀況下可以有效解決問題，但如果是事件同時併發，或是監聽多個事件的話，一樣會出現 callback 的問題。 Promisepromise 把之前的 callback 做扁平化，任何的操作可以用 then(resolve, reject) 的方式達成，同時 Promise 也有提供all 之類的操作對多事件統一處理。 ReactiveX什麼是 functional reactive programming 簡稱為 RxJS 在去年七月份左右逐漸竄紅，主要的概念在於提供一連串的 functional API 操作 Observable Stream。 Your mouse is database 這篇文章的將 UI 上的事件操作都當作無止盡的 stream wiki observer pattern 和一般的 observer 的不同點在於，如果一個 Observable 物件沒有接收到 subscribe 方法時，並不會開始流動。 reactive，對資料的變動做出反應。 將所有的資料都視為 observable stream，統一用 Observable 處理。 reactive programming redux-observableobservable 是什麼？其實這個名詞並不是新玩意，在 UI 上我們也常常使用 observer 的概念。例如 addEventListener(eventType, handler)。 監聽畫面上的某個事件，並且對此事件做相對應的處理，這就是 observer。 當然，這樣的概念很廣泛，事實上我們也不需要過度的解釋名詞。 在 Rx 當中，我們將所有事件的組合當作一個資料流 結論這邊我沒辦法很明確地說這兩個函式庫適合的場景，因為這兩個函式庫要解決的問題其實非常類似，只是手法不同而已。 如果你先前就已經具備了足夠的 RxJS 的知識，比較習慣 functional reactive programming 的話，那麼 redux-observable 很適合勝任這個工作。 又或許，在團隊裡頭技術的迭代較快，可能今年 react，明年變成 Angular(哪家公司會這樣做XD)，那麼選擇 redux-observable 會在之後技術線改變時較容易修改，因為 Angular2 本身配備了 RxJS，搬移的成本較低。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"redux","slug":"redux","permalink":"http://kjj6198.github.io/tags/redux/"},{"name":"saga pattern","slug":"saga-pattern","permalink":"http://kjj6198.github.io/tags/saga-pattern/"},{"name":"observable","slug":"observable","permalink":"http://kjj6198.github.io/tags/observable/"},{"name":"RxJS","slug":"RxJS","permalink":"http://kjj6198.github.io/tags/RxJS/"}]},{"title":"5/1 勞工大代誌","slug":"labor-project","date":"2017-04-30T16:00:00.000Z","updated":"2017-07-19T14:02:30.000Z","comments":true,"path":"2017/05/01/labor-project/","link":"","permalink":"http://kjj6198.github.io/2017/05/01/labor-project/","excerpt":"","text":"先來看成品吧！ 記錄一下這個專案的始末。 規劃從四月中旬開始規劃、搜集資料到實作，都是一個人慢慢整理而成的，除了想要練習更好的視覺化技巧之外，主要還是想透過這樣的方式來了解台灣的勞動問題，以及曾經經歷過的勞工運動。 因為平時還有課業跟工作要顧，所以實際上花的時間不多，最後兩天甚至是熬夜在趕工。有更多的原因是因為，寫到一半發現又有更多資料想要搜集，不知不覺就變得非常龐大了。 不過這個專題仍然有太多議題沒有涵蓋到，像是年金制度、職災統計等等。因為時間上的關係，無法深入介紹。 為什麼想要做這份專案國中跟高中的時候，或許是職科出身的關係，平時除了從報紙跟電視看看一些新聞外，很少汲取社會的議題和發生的事。 這樣半懺悔、半好奇的心態，開始搜集了一些台灣過去的勞工運動以及相關數據。像是薪資漲幅、平均工時、出生率等等，這些都是當我看到數據的當下才發現，原來事情那麼大條。 工時高居全球、薪資漲幅凍漲將近十年、出生率最後一名、即將邁入超高齡社會，這些都是現在台灣正在面臨，且有可能會日漸嚴重的議題。 如果說現在這個渺小的我能夠做些什麼，大概就是勞動節時上街遊行，聽聽勞工的聲音，畢竟身為一位準勞工，再過不久大概就會遇到同樣的情境。 更何況是在我還沒出社會之前，就已經是那麼慘的現況了。 台灣的勞動環境仍然有許多待改進的地方，後人能夠享受到的果實絕不是理所當然。 這些前輩們用血汗、用人生、甚至賠上性命來爭取更好的勞工環境。 身為一位工程師能做的事情不多，這個社會上還有更多用科技無法觸及的事。但能夠拋磚引玉地讓人了解到「啊！原來還有這樣子的事啊」，就好了。 其實在查資料的時候，有很多讓人鼻酸的故事。 像是關廠工人臥軌時，民眾大喊輾過去；像是看到台電大樓的紀念碑連名字都沒有，藏在樹叢裡頭；像是看見 101 樹立的國殤紀念碑，卻過了那麼久才知道那是為何而來。 我們所處的社會當中有太多的理所當然，捷運順利地運作、高鐵能夠平安無事地從高雄開到台北、101 能夠安穩座落在臺北城、垃圾桶的垃圾有人收、廁所有人清、24 小時的便利商店，導致我們常常會忘記那背後隱藏的事情是由多少人的汗水（或是鮮血）堆積起來的，更何況是以前沒有任何勞基法保護的勞工們。 最後，特別感謝小公主陪我度過忙碌的一個月，幫我找資料跟拍照，這一個月陪我一起奮鬥；還有 潘敬昇 （Sheng Pan） 義無反顧地幫我設計了很有質感的 LOGO 跟 Title，還有設計上的建議。 最後，如果你們也有什麼勞工議題或心得想要分享的話，可以在 facebook 或是 twiiter 加入 #勞工大代誌 這個 hashtag。如果你喜歡這份專案，也可以順手把他分享出去。 另外，除了在網站裡頭所提到的議題跟事件，還有太多是我不知道、不清楚的事情存在在這個社會上。 我整理了一份勞工大代誌總表：https://goo.gl/nPxeg2 任何人都可以編輯。 敬，所有勞工們。 後記 之後這個專題被分享到求職天眼通上，也算是讓更多人知道了。 暑假選修了一門叫做職場災害與防治","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"勞動節","slug":"勞動節","permalink":"http://kjj6198.github.io/tags/勞動節/"},{"name":"視覺化","slug":"視覺化","permalink":"http://kjj6198.github.io/tags/視覺化/"},{"name":"d3js","slug":"d3js","permalink":"http://kjj6198.github.io/tags/d3js/"},{"name":"勞工大代誌","slug":"勞工大代誌","permalink":"http://kjj6198.github.io/tags/勞工大代誌/"}]},{"title":"Rails app 自動化部屬 - hubot 與 heaven","slug":"chatops","date":"2017-03-01T15:12:42.000Z","updated":"2017-03-02T12:55:43.000Z","comments":true,"path":"2017/03/01/chatops/","link":"","permalink":"http://kjj6198.github.io/2017/03/01/chatops/","excerpt":"","text":"前言目前所在的公司裡頭是直接在本地端的 terminal 跑 cap staging deploy 指令。 capistrano 作為自動部署化的工具非常方便，但難免會遇到幾個問題： 不是團隊中的每個人都有相同的環境 大家都在部署，結果 staging 上現在到底是哪個 branch，完全一頭霧水。 deploy 這件事情卡在本地端。 對一家新創來說，越穩定的開發效率和流程，就越能夠專注在產品當中。所以我們希望做到幾件事： 開發團隊都可以輕鬆的部署 不用在本地端下指令部署，還要多設定 ssh。 就算沒有開著電腦，也可以輕鬆地部署 能夠記錄部署的狀況 如果出問題了，可以快速 rollback 回上一個版本 逐漸厭倦了在 terminal 打指令，ssh key 手動加的日子。於是打算自己研究有沒有更流暢的部署流程。 之前在 Sudo 裡頭，幸好有 @ocowchun 跟 @henry 兩位懶工，devops 做得非常完整，才能夠專注在開發功能，而不是一堆繁複的設定當中。（雖然才剛開發完就關閉服務了…） 目前覺得最合適的解決方案是搭配 hubot-deploy 以及 heaven 來幫助部署。 但 heaven 的文件實在寫的有夠爛。 看了老半天，甚至看了一下 source code 才知道到底該怎麼設定。於是決定將整個設定流程分享給大家，希望能夠減少其他 devops 們走歪路的時間。 主要流程 hubot 接收到部署指令後，會發送 github deployment，同時會觸發 deployment 這個事件，這時 github 就會發送 POST 給在 webhook 設置的 url（這邊接收者為 heaven），heaven 接收到請求之後，就會開始部署，再一一回傳我們想要知道的部數狀況。 hubot-deployhubot-deploy 能夠用 slack 對 slack-bot 下指令的方式建立 github 的 deployment event。 heaven是一個 Rails 的 application。主要有一個 /events 負責接收從 github deployment 傳來的 deployment 與 payload。 設定步驟heaven 的文件寫得不明所以hubot-deploy 也是草草帶過。幾乎只能靠著他們提供的流程圖，不斷的試錯與通靈。 設定 hubot-deploy getting started with hubot 利用 yeoman 產生 hubot，並且選擇 adapter 為 slack。 在 package.json 中加入 hubot-deploy，或者 run npm install hubot-deploy --save-dev 在 external-scripts.json 裡頭加入 hubot-deploy。 到 apps.json 中設定想要部署的 repos 有哪些： 12345678&#123; &quot;repo_name&quot;: &#123; &quot;provider&quot;: &quot;capistrano&quot;, &quot;auto_merge&quot;: false, &quot;repository&quot;: &quot;kjj6198/deploy101&quot;, &quot;environments&quot;: [&quot;production&quot;, &quot;staging&quot;] &#125;&#125; 這些資料在 hubot 送出 deployment 時會一併塞入 payload 當中。像是這樣： 1234567891011121314151617181920payload: &#123; &quot;name&quot;: &quot;repo_name&quot;, &quot;robotName&quot;: &quot;yourrobot&quot;, &quot;hosts&quot;: &quot;&quot;, &quot;notify&quot;: &#123; &quot;adapter&quot;: &quot;slack&quot;, &quot;room&quot;: &quot;123456789&quot;, &quot;user&quot;: &quot;123456789&quot;, &quot;user_name&quot;: &quot;kjj6198&quot; &#125;, &quot;config&quot;: &#123; &quot;provider&quot;: &quot;capistrano&quot;, &quot;auto_merge&quot;: false, &quot;repository&quot;: &quot;kjj6198/deploy101&quot;, &quot;environments&quot;: [ &quot;production&quot;, &quot;staging&quot; ] &#125;&#125; 特別要注意的是，provider 的欄位之後會送給 heaven，所以 provider 的值必須是 heaven 有的（之後會提到），或是自己實作 Provider。 這樣子我們的 hubot 就算設定完成了。先部署到 heroku 上測試看看，部署到 heroku 很簡單： 123456heroku logingit initgit add .git commit &quot;init&quot;heroku creategit push heroku master 部署成功後，比較重要的變數有幾個： 變數名稱 用途 HUBOT_GITHUB_TOKEN GITHUB_TOKEN，到個人帳號 &gt; settings &gt; personal access tokens 設定。設定好權限，因為 hubot 只是用來建立 repo 的 deployment，勾選 repo 即可。 HUBOT_SLACK_TOKEN 你的 slack-bot token。可以到這裡設定 全域變數可以到 heroku 的 dashboard 或是直接用 command line 設定： 12heroku config:set HUBOT_GITHUB_TOKEN=abccccheroku config:set HUBOT_SLACK_TOKEN=abcccc 測試一下是否成功。在你設定的頻道中輸入 hubot deploy:version 其中的 hubot 要跟你的機器人名稱相同，例如機器人的名稱為 tripmomo，那麼我就要輸入 tripmomo deploy:version。 成功的話 hubot 會回應你目前的版本訊息。 確認 hubot 有送出 deployment 事件。輸入 hubot deploy app to statging 輸入 curl -H &quot;Authorization: token YOUR_GITHUB_TOKEN&quot; https://api.github.com/repos/my-github/my-repo/deployments 看看 deployment 是否建立成功。如果成功會回傳： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; \"url\": \"https://api.github.com/repos/my-github/my-repo/deployments/28301325\", \"id\": 123456, \"sha\": \"2e3xxxxxxxaaaaaaabbbbbbb\", \"ref\": \"develop\", \"task\": \"deploy\", \"payload\": &#123; // from apps.json \"name\": \"my-app\", \"robotName\": \"tripmomo\", \"hosts\": \"\", \"notify\": &#123; \"adapter\": \"slack\", \"room\": \"aabbccdd\", \"user\": \"aabbccdd\", \"user_name\": \"kalan.chen\" &#125;, \"config\": &#123; \"provider\": \"capistrano\", \"auto_merge\": false, \"repository\": \"my-github/my-repo\", \"environments\": [ \"production\", \"staging\" ] &#125; &#125;, \"environment\": \"staging\", \"description\": \"deploy on staging from hubot-deploy-v0.13.27\", \"creator\": &#123; \"login\": \"kjj6198\", \"id\": 123456, \"avatar_url\": \"https://avatars2.githubusercontent.com/u/123456?v=3\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/kjj6198\", \"html_url\": \"https://github.com/kjj6198\", \"followers_url\": \"https://api.github.com/users/kjj6198/followers\", \"following_url\": \"https://api.github.com/users/kjj6198/following&#123;/other_user&#125;\", \"gists_url\": \"https://api.github.com/users/kjj6198/gists&#123;/gist_id&#125;\", \"starred_url\": \"https://api.github.com/users/kjj6198/starred&#123;/owner&#125;&#123;/repo&#125;\", \"subscriptions_url\": \"https://api.github.com/users/kjj6198/subscriptions\", \"organizations_url\": \"https://api.github.com/users/kjj6198/orgs\", \"repos_url\": \"https://api.github.com/users/kalanchen/repos\", \"events_url\": \"https://api.github.com/users/kjj6198/events&#123;/privacy&#125;\", \"received_events_url\":\"https://api.github.com/users/kjj6198/received_events\", \"type\": \"User\", \"site_admin\": false &#125;, \"created_at\": \"2017-03-01T12:24:20Z\", \"updated_at\": \"2017-03-01T12:24:20Z\", \"statuses_url\": \"https://api.github.com/repos/my-github/my-repo/deployments/12345667/statuses\", \"repository_url\": \"https://api.github.com/repos/my-github/my-repo\" &#125; 更多 deployment API 可以到 github deployment API 看看。 設定 heaven 到 heaven 將 repo clone 下來。 設定全域變數 變數名稱 用途 DEPLOYMENT_PRIVATE_KEY 因為 heaven 是用 ssh 登入，需要 private key。如果 server 在 ec2 上，也可以用 pem 的方式來設定。 GITHUB_CLIENT_ID 到個人設定頁面 &gt; OAuth application 產生 GITHUB_CLIENT_SECRET 到個人設定頁面 &gt; OAuth application 產生 DATABASE_URL heaven 會建立資料庫紀錄 deployment GITHUB_TOKEN heaven 會使用 gist 來當作 stdout stderr。所以在設定 token 時記得把 gist 打勾勾。 其他的變數可以到 這裡 查看。 補充說明 DEPLOYMENT_PRIVATE_KEY：原始檔案長這樣 123456789101112131415161718192021222324252627-----BEGIN RSA PRIVATE KEY-----MJVGa/WNT9aFs63ykxLCdGzav8CfQ5vKXrLrllHXUYFaB2yaN72L+fSsXAy9zMs2vy6wV2fB6j3YrVNCnBwUUNGTX9Ka6eeK98dCvHVyyE9Iz3CJAWZxaI03Px/xX9psM4kDWe7IA6+mnuCVSzwQVWMdOoAXbQbhGdfeixbqljNhJrKW/jA9w4BNarwGYv4E0MwdU9x7zpk826ytza87yXHSdNuTKcsGQk4XHMYxJECj4EM8vTlVlEyEXZtCeh2zP4bjYkTcBom4nC/q7Ea7Pmy1iDJqs0qc1L/xtNMypMhx4iIaeDVawkvBaL6t9IPTKVuC9Y1uw5nJP1gwxXa5qoazhcikzqRYmaeWIzsZrcVShZBrJO9/a/APxXY7qJpJ0r1YYTykw7THYj2QYiv8cfF64/vh9cB0NELEp5hIuS82Mf6CjqRR7QYR+By3uIdDhQ77NMpQlmIC+TCJsLoADqwmEEZCiQSejtkXXtN/mNl581jP8+ViNkWZfPYWe7g6yUeXVN1cBPo6AIu+lStE+SlR8lbu7sdpn6lid1pJf50zeythabze81y/nrAdx+JnscACBJBrERkhm2wdULkqwMV2g0U53YpYVAs2fFU1hGzRcE5zF1sdy9RLLX45MzrmlRErTbSUcnoQJhhCso5uNY6MMnr/rQF920KA0Ufr40IBcQ8bOSX7lJucST5bZLDgH7g16rimHgK4I9rrvKy4plvbolfpuKGMYJDS3Q7IW5cL5lWLU3HaVSn+VyZe8p3AprVx0XmSCwpmUzbDI6FoqniVPVdgis2tV1uKdnJPVn0DoK0ersosGXmALytbYLeEarH/cIlGGCoGbIX+Iv3u8aICBEG2eR8eXmQSlGI5rp9hGK/JrlkL3PywVmPw4EfiatiS6Y12Tuu8bdpPxBTzXK3PoZ23Pc+1l7NXXIzBeGnj56bALOIbAY5kg+lIRdtPNSTAW8IVgFJUl4uzy/NXn/ewiE093ZVs59I2x4OoS14S20mkM/ldWbvlVm4Z3JxCxIWsIV8aLznttic5MJUGjGoqH1Brg0o1HyWdkoEcC1N0G57oO4pN4UTD5co5xY9jAi2NIcFCYzqrdTfSlPWJBZLhjZ5hOXIwuTeJfRxDAVphaUqfpXb3o3URGRWiGENAkIYKiq4XeNguwrFBzg5CB7NEKvjbjJ31GI26yAPa7yrKpuNFAjPpO6JKdL8slvx8GXCOSbhGPFxzmtYzEeMxmnHqOa0Z953XeheKfJoipqRAyENxPBvclDonqVfxuTvwcZzqFD+XjDJCJ5INwuwk2WupVzQjzV6TagcIX63Kq1Z9HSoFIBiCrdLzTMDG4Ro32wpN1tFQFz6alvwKtifGwhvG3qqmsfcQqw56gGY0DWIqG5x/thdG7UzZT7iMVDJVLAO5wNnBK6L+feov9LqP7ONAonBVawmTv0ArjVhhkYZEi6d+ymvPpL1ORFAymLnedpk4VmmmQvkUu0KudRqulavTIrnXFkuv2va+5X9mHGoNNMo1TXk2XX1eM4Rc7nAY6IwPyAuFEtT5ocWBklB/qUZtdu4fG876o0X87GklR9ZfPG+tWpH2F+1j1mMHKuiP-----END RSA PRIVATE KEY----- 要修改成： 1-----BEGIN RSA PRIVATE KEY-----\\nMJVGa/WNT9aFs63ykxLCdGzav8CfQ5vKXrLrllHXUYFaB2yaN72L+fSsXAy9zMs2\\nvy6wV2fB6j3YrVNCnBwUUNGTX9Ka6eeK98dCvHVyyE9Iz3CJAWZxaI03Px/xX9ps\\nM4kDWe7IA6+mnuCVSzwQVWMdOoAXbQbhGdfeixbqljNhJrKW/jA9w4BNarwGYv4E\\n0MwdU9x7zpk826ytza87yXHSdNuTKcsGQk4XHMYxJECj4EM8vTlVlEyEXZtCeh2z\\nP4bjYkTcBom4nC/q7Ea7Pmy1iDJqs0qc1L/xtNMypMhx4iIaeDVawkvBaL6t9IPT\\nKVuC9Y1uw5nJP1gwxXa5qoazhcikzqRYmaeWIzsZrcVShZBrJO9/a/APxXY7qJpJ\\n0r1YYTykw7THYj2QYiv8cfF64/vh9cB0NELEp5hIuS82Mf6CjqRR7QYR+By3uIdD\\nhQ77NMpQlmIC+TCJsLohtJEmEEZCiQSejtkXXtN/mNl581jP8+ViNkWZfPYWe7g6\\nyUeXVN1cBPo6AIu+lStE+SlR8lbu7sdpn6lid1pJf50zeythabze81y/nrAdx+Jn\\nscACBJBrERkhm2wdULkqwMV2g0U53YpYVAs2fFU1hGzRcE5zF1sdy9RLLX45Mzrm\\nlRErTbSUcnoQJhhCso5uNY6MMnr/rQF920KA0Ufr40IBcQ8bOSX7lJucST5bZLDg\\nH7g16rimHgK4I9rrvKy4plvbolfpuKGMYJDS3Q7IW5cL5lWLU3HaVSn+VyZe8p3A\\nprVx0XmSCwpmUzbDI6FoqniVPVdgis2tV1uKdnJPVn0DoK0ersosGXmALytbYLeE\\narH/cIlGGCoGbIX+Iv3u8aICBEG2eR8eXmQSlGI5rp9hGK/JrlkL3PywVmPw4Efi\\natiS6Y12Tuu8bdpPxBTzXK3PoZ23Pc+1l7NXXIzBeGnj56bALOIbAY5kg+lIRdtP\\nNSTAW8IVgFJUl4uzy/NXn/ewiE093ZVs59I2x4OoS14S20mkM/ldWbvlVm4Z3JxC\\nxIWsIV8aLznttic5MJUGjGoqH1Brg0o1HyWdkoEcC1N0G57oO4pN4UTD5co5xY9j\\nAi2NIcFCYzqrdTfSlPWJBZLhjZ5hOXIwuTeJfRxDAVphaUqfpXb3o3URGRWiGENA\\nkIYKiq4XeNguwrFBzg5CB7NEKvjbjJ31GI26yAPa7yrKpuNFAjPpO6JKdL8slvx8\\nGXCOSbhGPFxzmtYzEeMxmnHqOa0Z953XeheKfJoipqRAyENxPBvclDonqVfxuTvw\\ncZzqFD+XjDJCJ5INwuwk2WupVzQjzV6TagcIX63Kq1Z9HSoFIBiCrdLzTMDG4Ro3\\n2wpN1tFQFz6alvwKtifGwhvG3qqmsfcQqw56gGY0DWIqG5x/thdG7UzZT7iMVDJV\\nLAO5wNnBK6L+feov9LqP7ONAonBVawmTv0ArjVhhkYZEi6d+ymvPpL1ORFAymLne\\ndpk4VmmmQvkUu0KudRqulavTIrnXFkuv2va+5X9mHGoNNMo1TXk2XX1eM4Rc7nAY\\n6IwPyAuFEtT5ocWBklB/qUZtdu4fG876o0X87GklR9ZfPG+tWpH2F+1j1mMHKuiP\\n-----END RSA PRIVATE KEY----- 既然公開，這組 private key 當然報廢了 設定 Gemfile因為 heaven 的動作會是拉下最新的 repo 後，執行 cap ... deploy 的指令，所以capistrano 的版本必須跟要部署的那個版本相同。同時，也要注意任何 asset 相關的 gem 也要一併放入 heaven。舉例來說，如果我的 Capfile 有用到 12345gem 'capistrano', '3.4.0'gem 'capistrano3-unicorn'gem 'capistrano-rails'gem 'sitemap_generator'gem 'capistrano-rvm' 那麼就要將這些 gem 加入 heaven 的 Gemfile 當中。因為 heaven 會將要部署的 repo 抓下來之後，進去資料夾輸入 cap staging ... deploy 的指令，所以如果沒有安裝相對應的 gem，heaven 就沒辦法部署了。 串接 github deployment 先到 repo 的 settings &gt; deploy key 加入 ssh-key。 到 repo 的 settings &gt; webhooks &gt; add webhook Payload URL 填入你的 heaven 部署 host 的網址，例如：https://yourapp.com.tw/events。如果想要修改，可以到 heaven repo 的 routes.rb 中修改 Content Type 選擇 application/json Secret 依需求選填 下面問你這個 webhook 要監聽哪些事件，我們是用 deployment 來做部署的，所以選擇 deployment 以及 deployment status。 部署如果是部署到 heroku 的話，因為 heaven 要開 redis 跟 resque。記得加入相對應的 add-on 以及 REDIS_URL 。 同時別忘記了要建立資料庫 heroku run rake db:migrate。 hubot-deploy 常用指令 hubot deploy:version 目前版本 hubot deploy repo： 根據 apps.json deploy 指定的 repo name。 hubot deploy repo/branch：將指定 repo 的某一個 branch 部署到預設的 environment 中。可設定 HUBOT_DEPLOY_DEFAULT_ENVIRONMENT 來決定 hubot deploy repo/branch to staging：將指定 repo 中的 branch 部署到 staging 筆記 heaven 的文件雖然不明所以，但是程式碼跟測試寫得蠻完整的，熟悉 ruby 的開發者甚至可以將整個 heaven 架設好，修改一下程式碼，加上 routes，直接建立 UI 一鍵部署。 OptionParser::AmbiguousOption: ambiguous option: -s：不確定是不是 Capistrano 更新之後指令有變動。解決方法是到 lib/heaven/provider/capistrano.rb 修改 deploy_command 1234567891011121314151617181920212223242526module Heaven # Top-level module for providers. module Provider # The capistrano provider. class Capistrano &lt; DefaultProvider ..... def execute return execute_and_log([\"/usr/bin/true\"]) if Rails.env.test? unless File.exist?(checkout_directory) log \"Cloning #&#123;repository_url&#125; into #&#123;checkout_directory&#125;\" execute_and_log([\"git\", \"clone\", clone_url, checkout_directory]) end Dir.chdir(checkout_directory) do log \"Fetching the latest code\" execute_and_log(%w&#123;git fetch&#125;) execute_and_log([\"git\", \"reset\", \"--hard\", sha]) deploy_command = [cap_path, environment, \"部署的 cap 指令\"] log \"Executing capistrano: #&#123;deploy_command.join(\" \")&#125;\" execute_and_log(deploy_command) end end end endend 因為 heaven 在部署時會使用 gist 當作 stdout 跟 stderr，在設定 GITHUB_TOKEN 的時候一定要記得把 gist 的 scope 打勾 Net::SSH::AuthenticationFailed: Authentication failed for user apps@staging.tripmoment.com ：SSH private_key 設定有誤。先確定這組 ssh key 是否已經加入 github，再來確定將 passphrase 拿掉，並且將 ssh private key 變成一行加上 \\n。 ArgumentError: Could not parse PKey: no start line 沒有將 SSH private key 的 passphrase 移除 後記通常在公司裡頭，開發團隊人數不多的話，devops 都是由後端兼任的，前端比較少接觸。不過用「我是前端，我不需要管 devops」這種藉口搪塞自己不去學習好像也說不太過去，畢竟開發一個健全的系統絕對不可能只有前端而已。 這篇文章試著將文件中沒有提到或是省略的步驟整合起來，heaven 跟 hubot-deploy 的文件中有太多沒有提到的細節，導致整合起來時需要花不少時間試錯。希望能夠節省大家踩雷跟翻原始碼的時間。 這篇文章還有許多 devops 的細節沒有詳述，畢竟建立一套完整的 devops pipeline 需要時間，自己對於 CI/CD 的設定也還不夠熟悉。 參考資源： 顆顆 devops 筆記 chatops","categories":[{"name":"rails","slug":"rails","permalink":"http://kjj6198.github.io/categories/rails/"}],"tags":[{"name":"devops","slug":"devops","permalink":"http://kjj6198.github.io/tags/devops/"},{"name":"chatops","slug":"chatops","permalink":"http://kjj6198.github.io/tags/chatops/"},{"name":"capistrano","slug":"capistrano","permalink":"http://kjj6198.github.io/tags/capistrano/"}]},{"title":"IT 鐵人幫完賽心得","slug":"webgl-it","date":"2017-02-28T15:44:42.000Z","updated":"2017-02-28T16:28:51.000Z","comments":true,"path":"2017/02/28/webgl-it/","link":"","permalink":"http://kjj6198.github.io/2017/02/28/webgl-it/","excerpt":"","text":"連結 今天是鐵人賽的最後一天，感覺自己最後結尾的部分收得不是很好，也有很多部分都因為時間上的關係沒有很完整地介紹完。 挑戰 30 天連續發文的確是一件非常不容易的事情，自己也更了解到如果還有類似的機會，一定要事先做好準備才行，才不會突發狀況發生時，急就章地寫完文章結尾。 同時，這次挑戰的主題是以前從來沒有碰過的 webGL 及 3D 圖學。原本以為前 10 天的學習能夠掌握基本的知識，不過實際上要了解 webGL shader 的應用跟撰寫、活用 three.js API 等等，都需要相對應的圖形理論做補助，這樣框架用起來才能得心應手。 不過 10 天的學習完全不夠用，光是要了解 GSGL 的撰寫就要不少時間了，更別說應用在實際的計算上。儘管已經有框架幫我們處理掉底層的操作，但如果需要更進階、或是更強大的活用，就必須更了解背後的操作。 aframe 的部分，我會再找時間陸續補齊（如果有時間的話QQ）。未來也希望自己能夠繼續往 3D 之路邁進，讓前端畫面的展現更加豐富。 這絕對需要時間的累積跟練習，也比以往的前端開發更有挑戰性，不過這 30 天的確學習到了很多過去完全不懂的知識。過去望之生畏的 shader ，現在也能夠寫、也能夠看懂；three.js 的 API 有基本的認知和了解；同時也看了一下 webVR 的發展跟認識 aframe 這個框架。 這 30 天可以堪稱最充實的一個月了（笑）。我知道本系列文章中仍然有許多不完整的部分，但希望各位讀者或多或少都能從中獲得一些知識！ 後記得到佳作。算是自己 2016 的總結吧！有太多事情沒有好好地記錄下來。 看到報名通知時其實掙扎蠻久的，因爲前端可想而知，今年寫 react redux 的人一定很多，既然如此，何不嘗試一下自己想碰很久，卻一直沒有碰過的 webGL？ 一直以來都對畫面上的互動很有興趣，但是對一位工程師來說，處理動畫之類的邏輯是很煩人又枯燥的事。這一個月雖然學習的東西跟網站開發天差地遠，甚至很少能夠應用在實際的開發當中（壓榨時程都不夠了，誰還在管特效？）。不過能夠學習這些知識，拓寬自己的視野，又何嘗不是件好事呢？ 越來越多公司對前端的要求，都是在數據視覺化上。以前被視為無聊、枯燥，在大數據的時代下開始被重視，對這個方向的要求就是 canvas 以及 webGL 的操作能力，不過現在也已經有很多框架幫你處理底層的 API 了。但身為前端，還是要有對底層的基本認識。不然總有一天抽象化滲透還是會找上門。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"webGL","slug":"webGL","permalink":"http://kjj6198.github.io/tags/webGL/"},{"name":"IT 鐵人幫","slug":"IT-鐵人幫","permalink":"http://kjj6198.github.io/tags/IT-鐵人幫/"}]},{"title":"伊坂幸太郎 - 摩登時代","slug":"morden-time","date":"2017-02-21T16:00:00.000Z","updated":"2017-03-01T06:03:20.000Z","comments":true,"path":"2017/02/22/morden-time/","link":"","permalink":"http://kjj6198.github.io/2017/02/22/morden-time/","excerpt":"","text":"《摩登時代》原本是喜劇天王卓別林最著名的一部默劇電影。並且被認為是美國史上最偉大的電影之一。 在討論社會學以及國家、個人、家庭之間的關係時，這部電影也常常會被拿出來討論。 雖然是用戲謔而滑稽的手法詮釋的電影，卻將殘忍的事實完整的描述出來。 從卓別林的眼中看見這個國家所隱含的殘酷現實，這就是我們所知的城市，儘管醜陋，卻是我們必須賴以維生的重要場所。這樣令人哭笑不得的劇情，是卓別林突出的功力。 摩登時代這本書是伊坂幸太郎在2010發表的長篇小說，配上花澤健吾的插畫，更富有戲謔感。 伊坂幸太郎將這個故事從頭說起，主軸仍然是在討論這個國家、組織的運作，卻更有戲劇性，雖然也有不少湊篇幅而出現的情節，不過這部小說是連載之後才出版成小說的。 這次連伊坂幸太郎都跳入這個故事中，「我的小說無法改變世界」、「小說啊！只能滲進讀者的體內，然後溶解」似乎隱約道出他的無奈。但不管如何，唯一能確定的是，他深厚的寫作功力以及架構，的確讓這篇故事相當精彩。 「你有沒有勇氣？」是讀完小說後，最深刻的印象之一，男主角平凡的要命，膽小怕死又背著老婆外遇，這樣一位平凡人，就跟螺絲釘一樣。 故事從一位系統工程師發現某個交友網站的程式內部隱藏著某種驚人的事實，愈是深入了解，愈發覺事情的不對勁，因為鍵入特定的關鍵字而受害，這位工程師開始深入調查，然後開始展開了一連串的故事。 書中寫到了許多小故事，也是伊坂的特有風格之一。 每本作品都會有個人物串場，而且不限於人而已，連湯瑪士小火車也曾出現在伊坂的筆中。不僅和劇情有呼應，也似乎在傳達著這個社會下所顯現出來的殘酷。 漢娜鄂蘭 「邪惡的平庸」，強調平庸才是邪惡的源頭。 事情拉回到二次世界大戰，猶太人被納粹黨大量屠殺的喋血事件。 當時的劊子手「艾西曼」被批評為惡魔。後來發現，他並不是懷抱著對猶太人的憎恨而屠殺，而是依照著上級命令行事罷了。 然後呢？他就不需要懷有內疚感或是責任感，一切都只是遵照指示，不需要受到良心的譴責。 每個人都只是機械性地完成工作，卻對整個工作流程一無所知。只是遵守著龐大的組織運作而已。然而這樣的思想並不只存在於當時。 這是巧合嗎？ 還是一種帶有歷史性、諷刺的無奈輪迴？漢娜鄂蘭、伊坂幸太郎所要表達的觀念竟然不約而同地出現在現代。 這是伊坂幸太郎的答案「如果因此做什麼都不會覺得不痛不癢的話，這個人就完了」。 在這個資本過剩的年代，生活雖然不容易，卻已經比之前好太多了。更何況年輕時的機會成本出乎意料地低，真的要讓賺錢、找工作這件事變成放棄思考的藉口嗎？就算真的努力工作，存到不錯的存款，又能夠這樣認定這就是正確的嗎？ 邏輯上的確說得通，畢竟別人怎麼活是他們的事，能夠做自己喜歡、有回報、擅長的的事當然是個大幸運，但大部分的人都只能擇其一，並且這樣活下去。 既然有實現夢想的人，那就有不得不放棄夢想的人在。 但是，拿自己的職業做比喻好了。我是一個前端工程師，工作就是從實現設計師所產出的 mockup，儘管頭銜好聽了一點，但本質上也跟擰螺絲的卓别林沒什麼不同。 任何重複性的工作，久了就會覺得枯燥，劇中的卓别林擰啊擰著，擰出病來，甚至把女生的胸部當作螺絲擰下去，結果被抓去監牢。 從早打晚埋頭敲鍵盤，不去思考需求、不去思考這樣做對不對、功能的必要性，那麼的確就跟擰螺絲的工人差不多。 「我只是按照上級指示行動。」這句話聽起來多令人心寒。很多人為了生活跟賺錢放棄思考。捨棄思考的我們、努力（而盲目？）工作的我們，真的只是完成工作就好了嗎？在這樣下去豈不是就像被操控的小丑一樣？ 在這個百花齊放的時代，更要不斷提醒自己，我是個活生生的人，有血肉之軀，被打會痛、開心會笑，而不是他人的工具，被動地為他人所用，而是應該要有自己的價值。 人是會習慣的動物工作久了會習慣、反覆練習而純熟。面對不熟悉的領域最原始的情緒就是恐懼跟害怕，如果因為這樣而不敢接觸世界的話，未來也一定會更膽怯的吧！ 總結想說的很多，但最完整能表現的大概是這一句吧！ 「比起支配人，我更想要幫助人」卓別林 -《大獨裁者》 至少在年輕的時候，做什麼事情機會成本都還小的可以時，趕快接觸世界。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"},{"name":"卓别林","slug":"卓别林","permalink":"http://kjj6198.github.io/tags/卓别林/"},{"name":"摩登時代","slug":"摩登時代","permalink":"http://kjj6198.github.io/tags/摩登時代/"}]},{"title":"高度相同的排版解決方案","slug":"responsive-flex","date":"2017-02-01T07:33:41.000Z","updated":"2017-03-01T03:04:54.000Z","comments":true,"path":"2017/02/01/responsive-flex/","link":"","permalink":"http://kjj6198.github.io/2017/02/01/responsive-flex/","excerpt":"","text":"在前端的頁面中，我們經常會碰到需要相同高度的排版。最直覺的方法就是將容器裡的所有元素設為 float 或是 inline-block。 float 及 inline-block如果是使用 float 排版，不但要先撐開父元素容器(clearfix)，還要針對子元素設定 margin。所以一旦內容太多，或是高度不足就會跑版。 而且，這樣的排版最大的缺陷就是，必須設定高度。 那，如果不設置高度呢？就算設定了 min-height 也一樣，當內容超出高度時，就必定會面臨 overflow 的危機。 後來決定直接用 css media query 在不同的螢幕寬度下分別給予不同的高度。雖然解法比較麻煩，也比較醜一點，但的確解決了寬度過窄時會跑版的問題。 這個問題後來一直深埋在心中，直到最近發現了 flex 的奧秘。 排版遇到困難，先想想 flex人生遇到挫折的時候，想想 flex，這個彈性盒子常常會救你一命。flex 已經支援大部分的主流瀏覽器，而且真的很好用！ 將 display 設置為 flex 的時候，如果子元素沒有設定高度，則子元素的高度會是其中最高的那個。 一行屬性就解決了我朝思暮想的問題，真是優雅的 flex。 但除此之外，我們還需要對排版做一些調整。 flex 預設如果沒有設置 flex-wrap 屬性的話，就會以單行顯示的方式來撐開父容器。因此我們可以再加上一行。 1.wrap &#123; flex-wrap: wrap; &#125; 好了，高度相同的 responsive 排版，不宣告 height 就此完成。大概的 css 會長得像這樣： 1234567891011.container &#123; display: flex; flex-wrap: wrap; justify-content: space-around;&#125;.card &#123; height: auto; width: 30%; border: 1px solid #aaa;&#125; 不支援 flex 的瀏覽器怎麼辦？首先 flex 已經支援大部分的主流瀏覽器了，不要用支援度這種藉口來忽視這麼好用的 flex。但如果瀏覽器真的不支援，可以用 js 的方式來做排版。主要的原理是不設定高度，偵測 container 裡面的所有元素，並且找出高度最高的，並將此高度套用到每個元素中。 寫了一個很基本的範例代碼： 12345678910111213141516171819var cards = document.querySelectorAll('.card');function getMaxinumHeight(elements) &#123; var nums = []; elements.forEach(function(value) &#123; nums.push(value.offsetHeight); &#125;); return nums.sort(function(a,b) &#123; return a &lt; b; &#125;)[0];&#125;var maxHeight = getMaxinumHeight(cards);cards.forEach(value =&gt; &#123; value.style.height = maxHeight + 'px';&#125;); Table is new sexy雖然古老的 table 排版已經被唾棄，不過像是等高這種場景，如果不幸無法使用 flex 時，可以利用 table 的特性來達成等高排版。 要完成 table 排版，可以使用 display: table, display:table-row, display: table-cell，來完成。 display: table 等同於 &lt;table&gt;；display: table-row 等同於 &lt;tr&gt;；display: table-cell 等同於 &lt;td&gt;。 See the Pen table-height by 愷開 (@kjj6198) on CodePen. 不過，雖然能夠達到等高的效果，但 HTML 的 markup 變得更複雜了。而且 table 在使用上仍然有一些限制，像是 margin 沒辦法在 table 裡頭生效等等，這些在實作 mockup 時都是很大的阻礙。所以，如果能夠用 flex 來做的話，就盡量使用 flex 吧！ 延伸閱讀Flexbox responsive equal height","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://kjj6198.github.io/tags/flex/"}]},{"title":"code-review-101","slug":"code-review-101","date":"2016-12-31T16:00:00.000Z","updated":"2017-02-28T16:19:16.000Z","comments":true,"path":"2017/01/01/code-review-101/","link":"","permalink":"http://kjj6198.github.io/2017/01/01/code-review-101/","excerpt":"","text":"前言身為前端工程師，通常在整個團隊裡面會是最常發送 pull request 的人。為了讓自己的 PR 更容易被測試，以及讓 reviewer 更容易的 review，總結了一些注意事項。 pull request 的描述 這個 pull request 的目的。例如：修正 layout、新增 feature、某個畫面的 style 等等 記住每個公司的成員都可以看見 pull request ，所以確保 pull request 的敘述提供夠完整的資訊。 明確地說明你想要怎樣的 feedback。 使用 prefix 來說明你的 pull request 狀態 將需要看這個 code 的成員加入進來（可以使用 github 的 assign 功能） 提供 feedback 如果你不同意 pull request 內的寫法，先停下來思考一下，為什麼你不同意。想清楚了再留下 comment 用詢問代替命令。「為什麼你不採用這樣的寫法呢？」優於「不要這樣寫！」，先問問看對方的想法或是意見，說不定他們不那樣寫是有理由的，這時候就可以做適當的溝通與交流。 解釋為什麼你覺得這些 code 需要被修改（不符合 style guide？不符合公司命名規範？沒有寫 test case？） 提供更好的方法來改善目前的 code 盡量避免具有攻擊性的評論。（ex:這樣寫很白痴。） 保持謙虛。 盡量避免斷定。（別這樣子寫 code！） 在線上溝通的時候，難免會有某些誤解產生。這個時候可以考慮面對面溝通。 用個 emoji 來加強你的語氣，例如：good job 👋 👍。 需要修正哦👻（這好像有點嘲諷？ 回應 feedback 感謝那些願意幫你 code review 的人。 對於任何不清楚的地方，發問就對了。 如果這個 feedback 有被實作或是在某個 commit 裡面，提供連結給他。 如果討論越來越複雜而且一直得不到結論，試著當面跟他溝通。 每個人 必須理解大家都有不同的 coding 風格，而且寫程式總會有許多解法跟選擇，所以在討論的時候應該適當做權衡，並且充分解釋為什麼你覺得這樣比較好。 用問的，不要用命令的。 不要劃分責任（這是你寫的不關我的事、這部分是你要處理的） 試著去理解一下作者的觀點和想法。 如果有一個 pull request 被 merge 了，記得留言並且感謝發送 pull request 的人。（optional） 結論雖然以上總結了那麼多點，不過我覺得圍繞的點還是在於是否為對方著想吧！身為一位 deployer，或是 code reviewer，你會希望看到怎樣的 pull request，從這個角度切入，或許會更有感觸也說不定。畢竟如果出錯了，甚至是因為自己的疏忽，把 code 部署到 production 上了，還要再浪費整個團隊的時間重新找 bug，再重新部署一次。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[]},{"title":"javascript 筆記","slug":"javascript-note","date":"2016-11-14T11:51:39.000Z","updated":"2018-08-29T14:33:08.000Z","comments":true,"path":"2016/11/14/javascript-note/","link":"","permalink":"http://kjj6198.github.io/2016/11/14/javascript-note/","excerpt":"","text":"這個禮拜不談「新」東西，多數會是關於網頁開發的重新思考。算是回過頭來漸漸補齊自己的技術債吧！比起前幾個禮拜所談的新東西，這一篇文章可能相對枯燥一點，當然篇幅也會比較長，但我認為這是必要的。 這些東西在前端變化快速的時代下或許顯得不那麼重要，不過思考總是件好事。 語義化標籤重新思考語義化這件事會有這個想法，是看到 instant article 的 html 架構，他們規範 instant article 的架構必須符合他們的規範，而且結構的表達也很清楚。我在裡頭看到了好多我以前沒有注意過的 html tag。像是 address figure caption summary 。好奇之下查了一下文件等等。發現其實有很多語義化的標籤都已經支持目前主流的瀏覽器，spec 也寫得很清楚，但是目前主站多還是以 div + class 的方式做表達，雖然有些地方會套用 header，但我認為有更多適合的語義化標籤可以加入使用。除了減少不必要的 class 命名，也能夠提高 html 的易讀性跟 SEO，重點是，我們寫的是符合標準的 html。 而且 w3c 在 html5 致力推廣語義化的標籤，諸如 nav header dd dt 等等，並且將一些沒有意義的 tag 刪除或是不推薦使用如 b font center 等等。 對於 class 的思考語義化 css 用了那麼久的 class，我回去找了找 spec，發現了 w3c 對 class 的描述。 There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content. -w3c 雖然 class 並沒有使用上的規定，但是鼓勵盡量將 class 用於表達元素內容而非描述元素的展現。也就是說那些 col-md-* 等表現性的 class 名稱其實在 w3c 的 spec 裡面是不符合規範的。但是會出現 unit class 的原因卻是因為我們沒有按照標準來而孵化出來的產物。雖然很多人擁護 unit class 的便利性跟節省開發的速度，但我認為比起開發上的時間節省，身為網頁開發人員，我們要注重的更應該是頁面的表達跟使用者的互動。 當然不得不承認的是，在理想上跟實際上總是會有差異。因為嚴格說起來，facebook 也沒有符合規範，他們是用css module的方式進行開發。 不過這裡想提出這樣子的想法跟大家討論。雖然標準的定案到瀏覽器的實作，總是要花不少時間。 為什麼要符合標準？ 標準規範是由一大堆科學家研究過後、大量的討論過後所制定出來的規範，給大家遵守以便達到統一性。 通常這些規範是 best practice。 為什麼我們要為了節省開發時間而寫出不符標準的網頁本末倒置？ 我們有更好的解決方案 &gt; SASStake id rethink我不會反對用挖掘機清理災難現場，但我不會拿來整理自己的家。給後代選擇器一個平反的機會，搭配 id 使用效果佳 123456789&lt;!-- 元素展現 --&gt;&lt;div class=\"margin-b-10\"&gt;&lt;/div&gt;&lt;!-- 內容 --&gt;&lt;div class=\"user_info\"&gt;&lt;/div&gt; 自己的理解是這樣。 至於為什麼會造成這樣的原因，或許是因為在網頁發展初期，CSS 的支持性並不好，在語義化跟表現之間很難得到平衡，才會有當時純 style 的 center width 出現。但現在已經不是那個綁手綁腳的年代了。我們應該朝向語義化的年代前進，而且這也是w3c在推廣的事情，身為一個站在網路業尖端的優質網路招聘公司，就由我們來引領風騷吧！ 對 unit class 難道沒有其他辦法解決嗎？我自己非常喜歡語義化的 class，而且很討厭 row col text-center，每次寫起來都會有罪惡感…。 至於用 unit class 的人，通常是因為不想花太多時間重寫 style 架構、節省開發時間、或是他根本不會 css，所以找個 bootstrap 直接套。但我們是前端工程師，我們有能力去組織 css。現在這個語義化年代，正是我們前端平反的好時機。 推行標準的目的是為技術交流構建一個統一的上下文語境平台，提高溝通效率，避免雞同鴨講。 同時標準跟規範的製定是經過一群資深開發者／科學家經過仔細研究及社區討論的，一套完整的一致的基礎架構系統是推進生態發展的必要條件。 就Web語義化這件事情而言，如果你的HTML是基於標準來編寫的，意味著你的頁面具備更多的可能性。比如搜索引擎友好，多終端適配(不是響應式。。是指兼容各種閱讀設備、讀屏軟件等。參見microformats )，更智能的風格查錯能力。 在前端開發體系裡，能體系專業性的地方不多。。拿程序複雜度而言，它跟大型後端系統差不止一個量級(前端的難度在於工程上)。。好不容易有一個能體現專業素養的領域(語義化Web)，為什麼我們不抓住機會為自己正名呢。。 我覺得這並不會增加維護成本，反而會在長期內減少冗餘樣式、不可預知的樣式覆蓋等維護問題。唯一的成本可能就是你在開始一個頁面之前，需要去抽像一下可複用的單元，然後用sass表達出來。不過我感覺如果你採用的是正確的工作流(面向語義)，這些事情都是比較順理成章的。 對於團隊開發如何確保面向語義，這確實是一個比較難解決的問題。除了需要提供一個清晰的團隊sass庫說明之外，貌似只能通過一些工程化手段解決了(加強code review流程、制定規範等等)。 grid system 是個很棒的東西我承認 grid system 的確是個非常好用的模式，在實際場景也會遇到 layout 無法用語義化來表示的問題，但根據語義化的定義，為了寫出更好看的 HTML 跟易讀性，我們或許總有一天還是要把 grid system 拔掉。這會是個大工程，但在目前主站說大不大，說小不小的架構上，還是越早開始越好吧！ Page Visibility API能夠知道目前 user 是否 focus 在這個 page 上。在很多情境下，我們希望當使用者沒有聚焦在這個網頁上（可能跳去別的應用程式、切換分頁時），可以盡量減少不必的請求或操作。facebook 好像也是當你回到網頁時才會有訊息的提示聲音。比較常見的情景是播放影片時，如果使用者跳出頁面，我們可以先自動讓影片停止，等使用者回來之後，影片在繼續播放。 回頭看看 js 的事件傳播最近把犀牛書拿回來翻了翻，主要是為了釐清以前不是那麼明白的觀念。太多 js library 充斥在網路，我們是否已經忘記原生的 js 了？雖然高度的抽象化是科技趨於發達後一定會有的現象，但是了解一下內部的運作也是好的，對於之後寫 code 也會比較有概念！ js 事件傳播js 的事件傳播主要分為兩大類型，bubble 跟 capture，大部分的傳播方式是用 bubble。什麼是 bubble 呢？在註冊對象元素的事件處理器被調用之後，事件就會開始往上漂浮（不包含某些元素的特定事件），然後再調用註冊於祖父元素上的處理器。這種現象會上升到 document 最後到達 window。 在實際應用上，我們時常看到：1234567891011$(\".abc\").on('click', e =&gt; &#123; &#125;);$(\".ass\").on('click', e =&gt; &#123; &#125;);$(\".asass\").on('click', e =&gt; &#123; &#125;); 散亂的事件註冊在角落，不僅維護上困難，在尋找 code 的時候也沒有統一入口，非常難以除錯。於是我們可以利用 js 事件的冒泡特性，為 document 統一註冊事件。jQuery 的 on 第二個函數便提供了事件委託的功能，如下： 123$('document').on('click','.sass', e =&gt; &#123; &#125;); 這樣的好處不僅減少了散亂的事件註冊，還統一了入口。如果要新增事件，只要在 document 統一做擴充即可。我們還可以在 html 這樣寫： 12&lt;a class=\"js_action\" data-action=\"foo\"&gt;&lt;a class=\"js_action\" data-action=\"bar\"&gt; 123456789 var actionList = &#123; foo: function(), bar: function()&#125;$('document').on('click','.js_action', e =&gt; &#123; if(typeof e.target.dataset.action === 'function')&#123; actionList[e.target.dataset.action] &#125;&#125;) 像這樣，以後如果要增加新的 event handlder 只要在 acionList 新增就好，甚至搭配 extend 的方式，可以不用寫在 actionList 也沒關係。充分提高了擴充性 那麼，為什麼那麼少人使用 capture 呢？最大的原因在於因為可愛的 IE 無法使用。再來事件捕捉只適用於 addEventListener 的方式。事件捕捉有點像是反過來，會先從祖父開始，依序向下船，直到事件父元素的事件處理被被調用為止，註冊於事件元素的事件處理器永遠不會被調用。 事件取消我們也常常看到類似 e.preventDefault() 的方法。其實像是舊版的瀏覽器並不支援，我們可以用一些比較 tricky 的方式來做取消。 1234567function cancelDefault(event) &#123; var event = event || window.event; if(event.preventDefault) event.preventDefault() if(event.returnValue) event.returnValue = false return false&#125;","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kjj6198.github.io/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"http://kjj6198.github.io/tags/javascript/"},{"name":"html","slug":"html","permalink":"http://kjj6198.github.io/tags/html/"}]},{"title":"css variable + sass variable = 😍","slug":"css-variable","date":"2016-11-14T11:44:20.000Z","updated":"2016-11-14T12:07:16.000Z","comments":true,"path":"2016/11/14/css-variable/","link":"","permalink":"http://kjj6198.github.io/2016/11/14/css-variable/","excerpt":"","text":"之前寫過了一篇關於自己對 css variable 的想法，原本對這個屬性沒有抱持著太大的期待，自己用習慣了 SASS 變數也覺得這個 css variable 反而像個彆腳的 system，不過如果你也是這樣想的人，可以參考這篇文章 Why should you care Css variables css 的變數已經出來有一段期間了，瀏覽器的支援程度還不算太糟。或許各位都曾經想過，這些變數的功能在 SASS 上幾乎都做得到，而且搭配 SASS 的 function 以及 SASS 的型別（list map）變數的使用彈性更為強大。 不過這邊想要跟大家分享的是，css variable 真正亮眼的地方在哪裡。 這篇文章會假設大家已經有一些 css variable 的基礎。 附帶一提，這篇文章沒有很全面性的寫出如何使用 CSS variable，所以有任何建議都歡迎提出來，之後也會找時間來重新寫一篇比較全面性的文章。 支援度 Browser Version Chrome 49 Firefox 42 Safari 9.1 custom property 只有在你讓他表現得像個 property 的時候，他才會比一般的預處理器強大 首先要澄清的一點是，在 CSS 的 spec 當中，variable 其實叫做 custom property。這是什麼意思？變數跟 property 搞得我好混亂！ 不要著急，意思就是在使用 css variable 的時候，我們應該把他們想成一般的 css 屬性使用，而非一般的變數而已。以下就會來介紹一些有關 css variable 的使用。 為什麼你要用 CSS Variable 你用這些屬性不需要一個預處理器。 可以用 initial inherit 的方式建立階層 瀏覽器會在需要的時候重新 render 你可以訪問並且用JavaScript操縱它們（等等會講到） property 特性既然是 css property 就一定會有以下幾個特性： 有所謂的 initial inherit 的值可以使用 呼叫的方式是 var(--variable-name) 能夠放在 inline-style 裡面 可以用 js 取值、設值 其中，最大的亮點在於 inline-style 跟能夠與 js 搭配取值與設值。這是跟原本 SASS, LESS 等 CSS 預處理器最大的不同之處，也讓 CSS 具備了新的可能性，就讓我們來看一些範例吧！ 12345678:root &#123; --mainColor: #abc; --subColor: #ccc;&#125;h1 &#123; color: var(--mainColor);&#125; 在這邊 :root 所宣告的元素會繼承到所有的元素當中，這就是 custom property 的特性。 inline-style因為是 property，所以當然可以像這樣寫。 123&lt;h1 style=\"color: var(--mainColor);\"&gt; Hello, world&lt;/h1&gt; 這看起來的確不怎麼稀奇，因為同樣的事情也可以用 class 跟 SCSS 變數的方式來達成，不過這讓我們在寫 inline style 的時候又多了一份可能性。 react inline style例如在 react 當中，我們可能會需要寫一些 inline style，但是顏色的制定因為跳脫了 SCSS 的控制，常常顯得很彆扭，要嘛就是直接打上顏色碼，之後要修改的時候再捲起袖子慢慢改；或者用 js 另外保存一份顏色的變數表；最好的方法可能是幫每一個顏色變數賦予一個 class。 現在有了 css variable 我們可以很方便的使用。 1234567891011const styles = &#123; heading: &#123; fontSize: '14px', color: 'var(--mainColor)', &#125;, warn: &#123; color: 'var(--warnColor)' &#125;&#125;;const heading = (&#123;title&#125;) =&gt; &lt;h1 style=&#123;styles.heading&#125;&gt;&#123;title&#125;&lt;/h1&gt; 本篇文章只聚焦在介紹 css variable，事實上也有其他優秀的 react style 管理方式 grid設定 gutter，我們現在可以用 css variable 的方式來做到，也就是說，我們可以用 @media query 的方式來幫變數設值，這是一般預處理器做不到的事情， js 的控制透過 javascript 的操作，我們可以很輕鬆的幫 css 變數設值或取值，來達到 view 跟 js 分離的效果。例如我們有一些效果想要透過 js 來取值，並傳給 css。一般來說，我們可能會透過 javascript 做計算之後，再把計算後的值，用 inline style 呈現。 但這樣子有可能發生一些情形： 這個值可能不是我想要的，或是我也想要自己對值做一些操作。這樣一來就要重新修改 javascript 的程式碼，非常麻煩。 因為是用 inline style 設值，所以 CSS 無能為力。 有了 css variable 之後，設值、取值非常的方便。 取值1HTMLElement.style.getPropertyValue('--mainColor'); 設值1HTMLElement.style.setProperty('--mainColor', '#abc'); 所以，我們當然也可以套用事件註冊器，讓有興趣的數值注入到我們的變數之中。 12345const element = // some HTMLElement;document.addEventListener('mousedown', e =&gt; &#123; element.style.setProperty('--pageX', e.pageX); element.style.setProperty('--pageY', e.pageY);&#125;); 支援度如果要看看當前的瀏覽器是否有支援 CSS variable 的話，可以用 CSS.supports 的語法來檢測。 CSS.supports(&#39;(--css: variables)&#39;) CSS.supports(&#39;not (--css: variables)&#39;) 之後的挑戰因為管理變數的方式越來越多了，也有可能在 javascript 對變數進行設值的動作，所以在控制這些變數時我們應該要更小心一點。 變數的宣告統一處理：全域變數統一放在一個檔案或資料夾當中，之後會比較方便處理，如果是宣告 css variable 也一樣。 如果變數是為了讓 js 設值，可以試著加上前綴當作標記，例如：--js-pageX 等等。 結論這篇文章介紹了 CSS variable 使用方式與場景，之前我也覺得 css variable 很彆扭，不但寫起來醜不拉機，而且也沒有相對應的函數操作。 不過一旦理解 CSS variable 就是 custom property 的概念的時候，就會發現一些 CSS 以往無法突破的可能性。我們沒有必要一定要對 SASS 或是 CSS variable 做取捨，我們甚至可以將兩者搭配使用，做出一些以往無法達到的強大效果。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kjj6198.github.io/tags/css/"}]},{"title":"web development 筆記","slug":"webdevelopment-note3","date":"2016-11-13T16:00:00.000Z","updated":"2018-08-29T14:37:46.000Z","comments":true,"path":"2016/11/14/webdevelopment-note3/","link":"","permalink":"http://kjj6198.github.io/2016/11/14/webdevelopment-note3/","excerpt":"","text":"這個禮拜在思考關於重構的東西，在前端還可以怎麼實踐。css 的部分已經有大致的雛形出來了，把相關的註解跟文件寫完之後再和大家分享心得。 Get your ../../ outreference css 部分重構完之後，再來就是要對 js 下手了。目前比較困擾的幾個點有： component 初期的部分比較亂 有些 flux、有些 redux 再來是我認為最麻煩的，就是路徑管理的問題了，因為檔案裡面有太多類似的 ../.. 出現，導致之後要對檔案做搬遷的時候還要全部重改一次，感覺非常的費工費時，也是讓人不敢輕易重構一大原因。 那時候第一個想法是，「不然我把全部的檔案存成一張路由表好了。」，不是 import 檔案本身，而是每次要 import 時，都到這個路由表去拿路徑，不但方便，而且每次對檔案做搬遷時，我只要維護好這張路由表就了。不過這個想法還沒有實作過，所以可能不是好方法也說不定…。 再來發現的第二個工具是modulesDirectories，主要是幫你把 root 定義好，每次呼叫 component 時都是以 root 當作起點而非檔案本身。 以 sudo 的檔案為例 1234567891011121314require(&apos;../ui/comment_reply.js&apos;);import h from &apos;../utils/sudo_helper/dom.js&apos;;const actionList = &#123; reply: &apos;reply&apos;, edit: &apos;edit&apos;&#125;;import jobsIndex from &apos;../reducers/pages/JobsIndex.js&apos;;import App from &apos;../containers/jobs_index.js&apos;;import configureStore from &apos;../stores/JobSearchStore.js&apos;;var Checkbox = require(&apos;../components/checkbox&apos;);var Slider = require(&apos;../components/slider.js&apos;);var TextInput = require(&apos;../components/text_input.js&apos;); 加入 modulesDirectories 之後，我們可以這樣寫： 123456require(&apos;ui/comment_reply.js&apos;);import h from &apos;utils/sudo_helper/dom.js&apos;import jobIndex from &apos;reducers/pages/JobIndex&apos;;import App from &apos;containers/jobs_index&apos;;import configureStore from &apos;stores/JobSearchStore&apos;; 這樣 component 搬遷的時候，不會因為相對路徑改變的關係，而還要全部重寫一次，重構的意願也相對提高了。 idiomatic-css最近一直在研究如何讓 css 的易讀性更高，並且更好做維護，目前如果搭配 webpack 的話，常見的方法有： css-module postCss radium 這些工具搭配 react 一起使用，其實可以很有效地解決 namespace 的問題。 不過主站目前想要先解決的是變數的統一命名，及 css 的規範。這部分規範好了之後，css 的管理相對也會變得簡單許多。 code smell in css這篇文章介紹了很多關於 css 的 smell code。幾個比較重要的大概念： 避免 magic number 盡量讓 class 是 immutable 利用權重的技巧，而不是過度使用 important selector 盡量簡單 順便來複習一下 selector 的語法吧！除了用 class 來當做 selector 之外還有很多其他實用的 selector 可以使用！像是 input 就是一個非常好使用 attribute selector 的例子： 12345678910111213.sudo-input &#123; input[type=&quot;text&quot;] &#123; // text style &#125; input[type=&quot;submit&quot;] &#123; // submit style &#125; input[type=&quot;number&quot;] &#123; // ... &#125;&#125; 這樣不僅語意清楚，也可以省下不必要的 class。","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kjj6198.github.io/tags/css/"},{"name":"react","slug":"react","permalink":"http://kjj6198.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"http://kjj6198.github.io/tags/webpack/"}]},{"title":"用 Canvas 實作 low-poly art 心得","slug":"low-poly-art","date":"2016-11-01T03:40:41.000Z","updated":"2017-02-28T15:41:53.000Z","comments":true,"path":"2016/11/01/low-poly-art/","link":"","permalink":"http://kjj6198.github.io/2016/11/01/low-poly-art/","excerpt":"","text":"文章待補，圖片。 前言說到 low poly，最讓我驚豔的是 species in pieces 這個網站，他使用 low-poly 的方式畫出 30 種現在地球上瀕臨絕種的動物，是用 CSS 的 clip-path 做出來的，為了兼容瀏覽器，甚至還有做 fallback 的圖片，非常的用心。 之前有在知乎上有看見 low poly 的實作方式，但看了一下原始碼，回答是用 THREE.js 做的。一來我對 three 的掌握程度還太低，再來是 2D 的圖形用 WebGL 加速實在有點奢侈啊。這邊記錄一下思路跟實現過程。 其實要做到 low poly 的效果並不難，最直覺的方式就是在畫面上取點，然後把點連接成三角形。再把三角形著色就完成了。不過隨機取點的方式會造成圖片很大的失真。 有以下四大步驟： 轉為灰階 使用 sobel 做邊緣偵測 選擇 vertices 使用 Delaunay 三角化 幫三角形上色 圖片轉灰階有了 canvas 之後，我們可以使用 getImageData 這個 API 對圖片中的任何 pixel 做操作，這給 canvas 更大的彈性跟靈活度，代表圖片的操作有更多的可能性了。 而灰階的實現並不難，將圖片中的 r g b 相加取平均即可。示意的程式碼大概像這樣： 1234567var resultArr = [];for (var row = 0; row &lt; height; y++) &#123; var i = row * width * 4 + 4; for(var col = 1; col &lt; width; col++, i+=4) &#123; &#125;&#125; 其實在實際應用中，要取得邊緣的方式並不是那麼簡單，有可能會影響的因素有： 陰影 聚焦模糊 Sobel 取邊緣通常檢測邊界的算法原理在於，將此像素的資料與其他像素比較，如果比較起來發現差距很大（顏色），那麼即可判斷這一點是邊緣。取邊界的算法有很多種，一般最暴力也最直接的方法就是 Sobel。 這邊就不解釋 Sobel 的原理了，維基百科上面寫得蠻清楚的。Gx=∣−101−202−101∣Gy=∣−1−2−1000121∣Gx = \\begin{vmatrix} \\mathbf{-1} &amp; \\mathbf{0} &amp; \\mathbf{1} \\\\ \\mathbf{-2} &amp; \\mathbf{0} &amp; \\mathbf{2} \\\\ \\mathbf{-1} &amp; \\mathbf{0} &amp; \\mathbf{1} \\end{vmatrix} Gy = \\begin{vmatrix} \\mathbf{-1} &amp; \\mathbf{-2} &amp; \\mathbf{-1} \\\\ \\mathbf{0} &amp; \\mathbf{0} &amp; \\mathbf{0} \\\\ \\mathbf{1} &amp; \\mathbf{2} &amp; \\mathbf{1} \\end{vmatrix}Gx=​∣​∣​∣​∣​∣​∣​​​−1​−2​−1​​​0​0​0​​​1​2​1​​​∣​∣​∣​∣​∣​∣​​Gy=​∣​∣​∣​∣​∣​∣​​​−1​0​1​​​−2​0​2​​​−1​0​1​​​∣​∣​∣​∣​∣​∣​​將矩陣做乘法之後就可以得到梯度大小了。 取完邊界之後，重頭戲就是如何將它三角化了！ 取點如果是隨機取點，很快就會發現一些盲點，邊緣常常沒有辦法很完整的保存下來，因為取點的方式隨機，三角形就會破壞邊緣的形狀，所以這邊的思路是三角形盡量不要出現在邊緣上，而是用邊緣當做三角形的點，這樣才能將邊緣比較完整的保存下來。 但取邊緣的點也不能全部都取，不然這張圖就根本沒有任何藝術效果了，像這個樣子。 醜不拉機，而且裡頭還有很多過小的三角形造成瑣碎的效果，這顯然不是我們想的樣子。那麼，如果都用邊緣的點當作組成三角形的點呢？ 我們來看看效果，因為都是用邊緣取點，很容易造成三角形過於尖銳的效果，為了避免這樣的情形發生，我們必須有限制地取邊緣的點。所以，除了邊緣上的點會被選中之外，我們也加入一些邊緣外的點，避免銳角三角形的情況發生。 此外，為了更有效的避免銳角三角形發生，我們可以使用 Delaunay 三角化的算法更有效率的取點。這樣子的效果就更完美了，但顯然我的實作上還有一些小問題： 在一些細節當中，如何保存比較完整的圖片訊息 失真太大，有些圖片被三角化之後會完全走樣 結論關於圖學領域真的是一門很深奧的學問啊…，不但要有一定的數學基礎與背景，還需要跟 openCV 或是 webGL、canvas 打交道，而最重要的是創意。 光是圖形的轉換跟變化，就足以寫一本厚厚的教科書了，更何況是用程式語言實作。不過第一次接觸這個領域，挺好玩的。 這個演算法最重要的部分在於選取點的方式，如果更有技巧地取點，那麼三角化後的圖形失真會越少。許多論文跟網路上的實現都比我胡亂湊出來的算法屌多了。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://kjj6198.github.io/tags/canvas/"},{"name":"low poly","slug":"low-poly","permalink":"http://kjj6198.github.io/tags/low-poly/"}]},{"title":"人類也是 context switch 的動物 - 違反直覺的做事方式","slug":"context-switch","date":"2016-10-27T09:52:51.000Z","updated":"2017-02-28T14:58:32.000Z","comments":true,"path":"2016/10/27/context-switch/","link":"","permalink":"http://kjj6198.github.io/2016/10/27/context-switch/","excerpt":"","text":"今天看了這個影片，主要是想要指出其實在多工切換中，可以得到比較好的效率。 聽起來很 trick，對吧？其實剛看完影片我也不太相信，不過這似乎可以用作業系統的角度來解釋。 Context Switch如果學過作業系統，對這個名詞不陌生。當時的疑問是，既然轉換要成本，為什麼不直接一個 process 到底就好？ 這個乍聽起來很蠢，但其實 context switch 並不會讓 process 的完成時間變短，只是將平均等待時間縮短了而已。 不過，這是建立在轉換成本為零的情況下。 儘管如此，這部影片給我的震撼也還蠻大的，如果今天這個數量提升到了某種量級，那麼彼此的差距將會非常驚人。如果我沒看過這部影片，之後遇到類似的作業大概也是也會這樣做吧…？ 結論 如果 context switch 的成本不高，甚至幾乎不需要切換成本，那麼 context swtich 將會提高效率，他減少了每項作業的平均等待時間。但如果今天 switch 的成本高於 mass production 多出來步驟的成本，那麼結果就會反過來了。 之所以 mass production 會比較慢的原因，是因為他多出了拿起跟放下的動作，而這個動作是在 one piece 當中沒有多出來的。如果今天 mass production 不會多出多餘的步驟（目前是還想不到例子啦…），那麼彼此的差距就不會那麼大，或者幾乎相同也說不定。（如果 context switch 成本不高的話） 這兩點都很違反直覺，直覺來想，重複做某件事，大腦會習慣並且逐漸擅長；但是在影片當中，卻要逼你違反大腦的直覺，不斷的在四個步驟之間切換。","categories":[],"tags":[]},{"title":"伊坂幸太郎 - 汽油生活","slug":"gasline","date":"2016-10-16T07:17:01.000Z","updated":"2018-08-28T17:53:12.000Z","comments":true,"path":"2016/10/16/gasline/","link":"","permalink":"http://kjj6198.github.io/2016/10/16/gasline/","excerpt":"","text":"前言自從實習生活開始之後已經很久沒有看小說了，不過仔細想想，如果把滑 FB 的時間拿來看書，應該可以偷到不少時間，於是假日心一狠，把之前很想看的小說全部搜刮起來…。但事實告訴我，這種衝動還是得小心啊！噴了 2200 多…，我得好好省吃儉用了。 汽油生活 🚗🚕🚙這次的作品是從一輛汽車的角度出發，這已經不是伊坂第一次嘗試了，《死神系列作》、《夜之國的庫帕》，都是以非人類的角度來作描寫，觀察人類。 這一次的主角是望月一家，有一次的旅程中望月一家載到一位大名鼎鼎的女藝人荒木翠，之後開啟一連串奇怪的事件中。汽車這次的作品中，由於故事中的敘事者都是以第一人稱出發，所以裡頭也有許多關於汽車的品牌跟故事，裡頭中出現的有關於汽車的心聲，也是讓人莞爾一笑的插曲之一。 新手駕駛反而是安全的，因為一旦開始鬆懈，就是危險的開始。這是我很喜歡伊坂幸太郎風格的原因之一，他很擅長把這些東西拿進作品裡當作比喻，不管是讓我們思考也好；或是劇情的走向也好，我看得挺過癮的。** 喇叭的存在目的 🎺喇叭似乎只是為了發洩憤怒而存在的。 那為什麼喇叭發出的聲音那麼低俗且刺耳呢？如果汽車出廠時可以對喇叭多用點心，想必也可以增加賣點吧！ 而且喇叭聲通常是爭端的來源之一，人類會對這種如突其來的噪音感到煩躁。試著想想喇叭製造的目的，應該是為了提醒行人、前方車輛：「唷，我在這裡哦！唷，前方已經綠燈了哦！」而存在的吧？ 雖然喇叭的音量可以由按下的力道調整，但是那種音量還是會嚇到別人，也有可能引起別人不滿。更不用說有時會在路上看見橫行的汽車，喇叭按著不放，似乎只是想用這種方式宣洩自己的不滿而已，根本沒有任何提醒的作用。 為什麼人類那麼喜歡這種原始而粗暴的方式呢？只因為這樣子很爽，發洩情緒的感覺讓自己產生優越感。備而不用是人類最愚蠢的地方。他們覺得也許會用到，所以就把什麼都保留下來。如果這樣一想，喇叭的聲音就應該被調整才對。 如果想要達到「提醒」的作用，應該不需要那麼尖銳的音量才對。 既然車子可以搭配喇叭，那麼行人也應該配戴喇叭，看到三寶開車或是貪污的政治人物，就應該到他面前吧吧兩下，表達自己微不足道的憤怒。 霸凌二人組關於霸凌這個觀點巧妙地和伊坂筆下出現的霸凌『野菜組』結合。亨因為跟一般的小孩不同，所以在學校時常常被『野菜組』霸凌。但他並不以為意，因為他知道這是人性下的醜陋，這群人只是因為無聊所以只好用這種方式來欺負別人。亨也習慣這樣的事情，「因為我不討人喜歡，所以大家都霸凌我」。當然伊坂幸太郎是不會讓這種人好過的，故事結尾也巧妙地讓亨返回一擊。（讓我感動的是，當圭一說他下定決心要站出來時，亨說的那句：「加油」） 只要有人跟一般人不同，就會有霸凌的存在，因為暴力讓人感覺很爽。 而且在學校時不用負太多責任不是嗎？有哪個學校會希望自己的學生霸凌？有哪個老師希望自己的班級霸凌？有哪個家長希望自己的小孩霸凌？ 所以當霸凌這件事發生，大家採取的動作不是遏止、而是隱瞞，所以他們更加為所欲為，因為不用負責任，而且還有那麼多人在幫你。 關於媒體媒體也常常出現在伊坂的筆下。之前才看過《64》、《虛線的惡意》，都是在說媒體、新聞業下的黑暗面。 但是，這次角度從另外一邊來看。因為這件事更有趣不是嗎？大家都想看，所以就會有人去寫這種報導。然後民眾又可以把罪過全部推給記者，好像自己完全沒有責任似的。那為什麼壹週刊一樣那麼暢銷、為什麼八卦點擊率還是那麼高，民眾對這種報導還不是一樣樂見其成。 所以到底是把媒體搞成這個樣子的？ 但是正如人類中有好人跟壞人，記者也有分好記者跟壞記者，這次是介紹好的記者。裡頭的阿玉因為對自己的報導害死了一位棒球選手感到愧疚，所以決定在這次車禍事件讓翠和丹羽遠走高飛，隱居他處。 故事的橋段還有一句，「咦？你怎麼變得那麼乖，這樣怎麼當記者？」當亨純真地問著這句話時不禁笑了出來。 「鏡頭具有抑制對方行為的力量」，所以在拍攝的時候都有種優越感，彷彿自己可以掌握全世界一樣。隱含在生活中的小道理我喜歡伊坂在敘事的過程中，將生活的小道理信手拈來，巧妙無痕地放入小說中的那種氣氛。就好像有人可以自私地害得整條高速公路都塞車一樣、就好像有人會把全世界的號誌燈都當作綠燈一樣。不管怎麼樣，還是有那些對道德無動於衷的人對吧？ 伊坂不會把這些道理赤裸裸地說清楚講明白，而是用巧妙的比喻帶過，卻又在故事結束後令人深思。 「就好像媽媽說吃青椒才可以吃甜點那樣嗎？」明明只是一個等價交換的道理，伊坂卻可以依照角色上面的不同，描述出不同的說法。想像這樣的話語從一般的小孩口中說出來，真的在適切不過了！ 尾聲（お終い）在小說進入尾聲階段時，亨曾經鼓勵圭一，希望他可以走出被霸凌的陰影，勇敢起身對抗。「那種影片不好玩，所以大家都不會在意的」，然後拿出法蘭克‧札帕的名言出來，說：「人類所嘗試的事情中，有百分之九十九都是失敗，所以失敗是正常的事情」。這句話可以說是老生常談，但是搭配劇情之後，竟然亂熱血一把的。伊坂小說的尾聲，總會讓人意想不到，包括安田太太的帽子、開頭良夫買的青蛙擺飾、殺人埋藏的屍體、牙醫事件、車子最後的下落，都做了一個完美的交代。這次的結局讓人看得十分過癮，還特別將那四台車的第一個字連接變成『お。し。ま。い』 伊坂的小說通常會用一個人物當作代表，引用他說過的名言來貫穿整個故事。 這次的主角是「法蘭克．札帕」是一位歌手，他的生涯我不是很清楚，上了維基百科查了一下，也沒有很明確的資料，所以我就不多做介紹，直接把連結貼給大家看看好了。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"夜之國的庫帕","slug":"isaka-kupa","date":"2016-10-16T06:59:53.000Z","updated":"2018-08-28T17:53:02.000Z","comments":true,"path":"2016/10/16/isaka-kupa/","link":"","permalink":"http://kjj6198.github.io/2016/10/16/isaka-kupa/","excerpt":"","text":"為了不要讓這裡的技術成分太濃厚，我打算直接將之前整理的閱讀筆記也一併 PO 在這裡統一管理比較方便。 從 2013 年以來陸陸續續看了很多本書，也做了厚厚的筆記。趁著部落格還空空的，動力還在，決定把那些擱置已久的筆記一併搬出來曬曬太陽見見世面。 夜之國的庫帕前言「來個慵懶而即興的小革命吧！」這本小說很適合在午後咖啡店，一邊啜飲著咖啡，一邊聽著輕音樂，一邊享受著小說中可愛而有趣的視角和劇情。 有一種慵懶卻又身在其中的感覺，跟著貓的想法一起思考、行動，雖然好像事不關己，但是到後面竟然連自己都開始緊張了起來，「拜託！劇情一定要這樣才對！」，還好，愛好和平的伊坂少年讓結局看起來如此的溫馨。不過，我還是好捨不得就這樣把小說給看完了嗚嗚嗚。 這本小說的筆調是很輕鬆的，但是在這種輕鬆的氛圍中，卻把人類社會中的現實和殘酷丟出來，拋出一個完美的質問。你會在故事的結尾中思考，對呀！我們不也是這樣？ 故事裡，獨眼兵長給了讀者答案：「懷疑。」 故事的內容是在描寫夜之國的人民被鐵國擊敗後，剛開始先假裝和平停戰，卻在一夕之間發生國王被殺（冠人）的事件，搞得整個夜之國人心惶惶、不知所措。 每個登場的角色都有一個小小故事，而這些小小故事結合起來，卻又和主軸互相連結，不會顯得太過凸出，伊坂揉合了不同支線的故事發展，最後將事實完整交代出來。這必須有非常深厚的寫作功力還有架構才有辦法做到。 安穩＝和平？夜之國的人民們深深相信著自己是處於一種和鐵國對立、領土相當的狀態下。他們並沒有產生懷疑，也沒有人想要求證。反正，只要日子過得安穩，就沒有這個必要管那麼多的事情吧！ 人民們依賴城牆內的安穩，卻沒有人願意思考、懷疑現狀的可能性。甚至他們放棄了探究真相，因為只要冠人說出包裝後的故事，他們就會無條件地全盤相信。不需要動腦筋、不需要奔波勞碌就有安穩的生活，何必大費周章確認事實呢？ 庫帕的傳說我好喜歡這個傳說。 「比起公佈真相，維持威嚴更加重要」那麼，要如何維持自己的威嚴呢？冠人的方法是，在外部安排一個又恐怖又強大的敵人（就算是假的也沒關係），然後再對人民說：「別怕，我會保護你們。」並且拿出實際作為（每年派出庫帕士兵）。這樣包裝下來，人民就自然而然地會將領導人視為英雄。冠人確保地位的方式是：欺騙、隱瞞、扭曲這個世界的價值觀 「什麼是對的，什麼事錯的，自己去判斷吧！」獨眼兵長丟出了結論。 「對任何意見都要有同等的懷疑，不然一定會吃虧。」 無知「無知」是一種恐懼，人們會因為不知道而害怕。所以如果領導者將事情處理好了，人民就無所憂慮，無所憂慮後，人民就會感到幸福，感到幸福之後，人民就會依賴領導者了。冠人成功創造了這樣的優勢，所以儘管獨眼兵長將事實說出，他們仍然是半信半疑。 「會不會我們所深信不疑的，都有改變的可能呢？」 貓吃老鼠貓吃老鼠就是天經地義嗎？誰規定的？來自上古的命令告訴多姆，「貓就是要吃老鼠」。但，為什麼呢？ 有人思考過這個問題嗎？故事中有蠻多篇幅是在描寫貓與老鼠間的對立關係及談判。 比自己弱小的東西，誰也不會放在心上。「只要心血來潮，我們就捉弄老鼠」，但弱者就一定要被欺負嗎？貓似乎都沒有想過，直到老鼠長老冒出來要求談判後，多姆才開始思考這個問題。 「我們獵捕老鼠，所以老鼠是低等的」，這是正確的看法嗎？同樣的觀點挪用到人類身上，弱者就應該順應天命的安排嗎？ 「出了門就該好好回家，不都是這樣嗎？」「既然你都能跟貓交談，跟老婆交談也是輕而易舉吧！」如果不改變彼此的關係，就永遠是兩條平行線。光是這樣，就可以有很大的改變了。 後記大約是在兩年多前寫的文章，現在看起來格外稚嫩。不過很慶幸自己當時真的記錄下來了，寫一篇文章真的很累，大概要花一小時構思、兩小時寫文章。 看完心得之後，又能馬上回味當時看小說時的情景，劇情也馬上映入眼簾，感覺真棒。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"},{"name":"推理","slug":"推理","permalink":"http://kjj6198.github.io/tags/推理/"}]},{"title":"smooth animation - （下）easing 的使用","slug":"scroll-animation-2","date":"2016-10-13T09:06:19.000Z","updated":"2016-10-19T06:20:45.000Z","comments":true,"path":"2016/10/13/scroll-animation-2/","link":"","permalink":"http://kjj6198.github.io/2016/10/13/scroll-animation-2/","excerpt":"","text":"但是，為什麼感覺動畫那麼不自然呢？ 有沒有發現，時間與距離是完全呈現線性變化的，這代表我們假設這個物體在所有的時間點，速度都是相同的。真實生活中通常不會有這樣的事情發生，物體一定都是從靜止狀態逐漸加速，再從移動的狀態中逐漸停止。而上一篇的範例當中，動畫是突然開始，突然停止。在現實生活中，物體的移動速度並非成線性變化，這是造成我們動畫看起來不自然的主要原因。 知道了原理之後，就可以馬上來實作了： 計算距離 重新計算每一次的位移 = 距離 * 比例係數（easing） 把我們原本的 function 改寫成這樣： 1234567891011121314151617181920function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) let currentTime = 0; function move() &#123; currentTime += 1 / 60; var p = currentTime / t; var d = Math.cos(Math.PI * pos) - 1); // 利用 cos 函數，重新計算移動的位置。 if (p &lt; 1) &#123; scrollTo(0, scrollY + (targetY - scrollY) * d); requestAnimationFrame(move); // 採用 requestAnimationFrame &#125; else &#123; scrollTo(0, targetY); alert('done'); &#125; &#125; move();&#125; 這邊我們加上了一個簡單的 cos 函數，重新計算位移的位置，達到 easing 的效果。詳細 easing 效果，可以到 easing.js 看看，這裡蒐藏了很多 ease 效果。 小結原本以為篇幅很長，不過基本的動畫原理的確只有這樣而已，加上了 easing 之後，動畫的效果看起來自然很多，當然，你也可以依照自己的經驗調整參數，達到更完美的使用者體驗。 不過，如果可以，盡量不要綁架使用者預設的滾動效果，一來可能會造成效能的問題，二來你綁定的滾動效果如果沒有依照使用者預期反應的話，很容易造成非常差的體驗。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"smooth scoll","slug":"smooth-scoll","permalink":"http://kjj6198.github.io/tags/smooth-scoll/"},{"name":"animation","slug":"animation","permalink":"http://kjj6198.github.io/tags/animation/"},{"name":"easing","slug":"easing","permalink":"http://kjj6198.github.io/tags/easing/"}]},{"title":"smooth scroll","slug":"scroll-animation","date":"2016-10-12T09:06:19.000Z","updated":"2016-10-19T06:21:04.000Z","comments":true,"path":"2016/10/12/scroll-animation/","link":"","permalink":"http://kjj6198.github.io/2016/10/12/scroll-animation/","excerpt":"","text":"在 window 物件當中，提供了 scrollTo(x, y) 的方法，我們可以透過 scrollTo 來操作滾動。但， scrollTo 方法是直接讓滾動軸移到指定的位置，並沒有動畫的效果，如果要藉由動畫的幫助達到良好的使用者體驗，我們必須自己設計。 基本動畫知識在開始之前先來讓我們了解一下動畫的基礎吧！ 動畫最基本的要素有這些： 時間 = 距離（位移）/ 速度 位移 = 速度 * 時間 速度 = 距離 / 時間 有了這些基礎知識就可以來製作簡單的動畫效果了。 第一次嘗試我們要做的事是要讓 scroll 能夠用動畫的方式滑到自己想要的地方。所以，在本例當中，scrollTo(x, y) 將會是我們的位移。速度的話，我們先暫定是 200ms 吧！ 123456/* */function moveScrollY(targetY, speed) &#123; const speed = 200; const scrollY = window.scrollY || window.pageYOffset; scrollTo(0, scrollY + (targetY - scrollY) * t);&#125; 咦？這個 t 是 undefined 吧？ 在定義 t(time) 之前，我們先來思考 t 應該要是什麼。根據剛剛的公式，時間 = 距離 / 速度，所以在本例當中，t 為 targetY - scrollY / speed。這樣寫的話如果 scrollY 大於 targetY 的話時間就會為負了，所以這邊我們要取絕對值。 1234567891011121314/* */function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.abs((targetY - scrollY) / speed); let currentTime = 0; function move() &#123; currentTime += 1 / 60; p = currentTime / t; scrollTo(0, scrollY + (targetY - scrollY) * p); setTimeout(move, 1000/60); &#125; move();&#125; 到目前為止，我們的 scroll 動畫雛形已經出來，不過存在一些問題： 距離太遠的時候，動畫的時間顯得有點長 這個動畫不會停 現在我們來改善一下 scroll 的動畫。 距離太遠顯然如果距離太遠時，動畫完成的時間會變得更長，所以我們需要限制一下 t 的範圍。 1234function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) 以下&#125; 這樣子好多了，在距離太遠時，動畫不會顯得太慢。 動畫不會停在程式碼當中，因為沒有設定停止條件，所以會無止盡的延續下去。芝諾悖論 怎樣才算是完成了呢？這邊的終止條件是目前的時間（禎數）等於 t 的時候，就算終止了。 123456789101112131415161718function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) 以下 let currentTime = 0; function move() &#123; currentTime += 1 / 60; p = currentTime / t; if (p &lt; 1) &#123; scrollTo(0, scrollY + (targetY - scrollY) * p); requestAnimationFrame(move); // 採用 requestAnimationFrame &#125; else &#123; scrollTo(0, targetY); alert('done'); &#125; &#125; move();&#125; 這邊我們將 setTimeout 取代成 requestAnimationFrame，requestAnimation 跟 setTimeout 的差別在於使用 requestAnimationFrame 時，瀏覽器會幫我們做最佳化，在不必要的時候不會進行重繪，達到節省資源的效果。 目前主流瀏覽器都已經支援了（主流當然不包含 IE8 囉！） 但是，為什麼感覺動畫那麼不自然呢？ 有沒有發現，時間與距離是完全呈現線性變化的，這代表我們假設這個物體在所有的時間點，速度都是相同的。真實生活中通常不會有這樣的事情發生，物體一定都是從靜止狀態逐漸加速，再從移動的狀態中逐漸停止。而上一篇的範例當中，動畫是突然開始，突然停止。在現實生活中，物體的移動速度並非成線性變化，這是造成我們動畫看起來不自然的主要原因。 知道了原理之後，就可以馬上來實作了： 計算距離 重新計算每一次的位移 = 距離 * 比例係數（easing） 把我們原本的 function 改寫成這樣： 1234567891011121314151617181920function moveScrollY(targetY, speed) &#123; const scrollY = window.scrollY || window.pageYOffset; const t = Math.min(0.5, Math.abs((targetY - scrollY) / speed)); // 將時間限制在 0.5(500ms) let currentTime = 0; function move() &#123; currentTime += 1 / 60; var p = currentTime / t; var d = Math.cos(Math.PI * pos) - 1); // 利用 cos 函數，重新計算移動的位置。 if (p &lt; 1) &#123; scrollTo(0, scrollY + (targetY - scrollY) * d); requestAnimationFrame(move); // 採用 requestAnimationFrame &#125; else &#123; scrollTo(0, targetY); alert('done'); &#125; &#125; move();&#125; 這邊我們加上了一個簡單的 cos 函數，重新計算位移的位置，達到 easing 的效果。詳細 easing 效果，可以到 easing.js 看看，這裡蒐藏了很多 ease 效果。 結論這邊很簡略地用 scroll 的 API 當作範例，介紹了動畫的基礎。當然還動畫的原理跟使用，又是另外一門深奧的學問了。 到目前爲止，我們的 scroll 動畫就算完成了，但因為位移是線性移動，看起來比較不自然一點，下一篇文章，再來介紹 ease 的概念，讓我們 scroller 變得更 smooth。 原本以為篇幅很長，不過基本的動畫原理的確只有這樣而已，加上了 easing 之後，動畫的效果看起來自然很多，當然，你也可以依照自己的經驗調整參數，達到更完美的使用者體驗。 不過，如果可以，盡量不要綁架使用者預設的滾動效果，一來可能會造成效能的問題，二來你綁定的滾動效果如果沒有依照使用者預期反應的話，很容易造成非常差的體驗。","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"scroll","slug":"scroll","permalink":"http://kjj6198.github.io/tags/scroll/"}]},{"title":"從 legacy code 中尋找出口（中）- HTML 篇","slug":"legacy-code3","date":"2016-09-17T02:40:16.000Z","updated":"2016-10-18T11:32:18.000Z","comments":true,"path":"2016/09/17/legacy-code3/","link":"","permalink":"http://kjj6198.github.io/2016/09/17/legacy-code3/","excerpt":"","text":"講完 CSS 的重構技巧之後，接下來會專注在 HTML 的重構技巧上。本系列的文章將不會談論 js 的重構部分，因為牽扯到較多的程式撰寫技巧，而且網路上類似的文章應該是不勝枚舉。 前言其實 HTML 能夠重構的點並不多，主要就是標籤的正確使用以及顧慮 accessibility 等小細節。 所以這篇文章會著重在如何使用正確的標籤以及語義化；基本的 accessiblity 認識跟 aria 標籤的使用，不僅對 screen reader 較友善，語義化的標籤使用也能夠在之後修改 HTML 時更有效率；最後是模板語言的技巧應用，這邊會用 rails 的 views 為例，不過概念的部分應該是相通的。 語義化首先，我們先來看看 HTML5 新增的 tag 有哪些 section 用來表示網頁裡的一個段落，常見的誤解是用來表示一篇文章。 基本上跟 div 沒有太大的差別，只有語義化的表現。 article 用來表示一篇文章 datalistdl dt dd 如果資訊是以條列式來呈現，可以使用 dt, dd 來區分。 Definition lists, created using the DL element, generally consist of a series of term\\/definition pairs (although definition lists may have other applications). Thus, when advertising a product, one might use a definition list: 123456789101112&lt;dl class=\"information\"&gt; &lt;dt&gt;薪水：&lt;/dt&gt; &lt;dd&gt;100000 ~ 300000&lt;dd&gt; &lt;dt&gt;工作地點：&lt;/dt&gt; &lt;dd&gt;台北市&lt;/dd&gt;&lt;/dl&gt; 任何以成對方式呈現的資訊都可以使用 dt, dd 包裝，像是範例中的：薪水搭配 100000 ~ 300000、工作地點搭配台北市。不過要注意的一點是 dl 預設會將內容縮排（就跟 ul, ol 一樣）。可以將 padding 設置為 0 來解決。 figure figcaption 使用在和主內容相關的圖片、代碼，或其他資訊，不一定只能放圖而已 搭配 figcaption 來定義標題 legend 搭配 fieldset 使用，用來表示輸入表單的內容 預設的邊框很醜，如果要使用這樣的結構可能要重置一下 CSS See the Pen fieldset by 愷開 (@kjj6198) on CodePen. 族繁不及備載，tag 的部分就在此告一段落。我個人覺得有一大部分是因為不知道才沒有使用這些 tag 的，詳情可以到w3c 的網站看看。之後會再將其他 tag 的使用方式補上。 如果都沒辦法滿足怎麼辦？如果以上的 tag 都沒有辦法滿足你的需求，最常見的做法就是用純 div。而 HTML 為了因應這樣的需求，也提出的 ARIA 的 spec，讓開發者可以更容易製作客製化的元件。如果我們想要使用 div 來模擬按鈕的行為，除了在 class 加上 btn 之外，我們同時可以加上 role attribute，並且使用相對應的 aria-* 標籤來做對應的狀態處理（是否按下、disabled、haspopup 等等），除了更加語義化之外，這些看起來有點麻煩的細節，都會大幅地改善使用 screen reader 的體驗。 但是，盡量不要取代原本語義化的標籤的含義，例如將 button 標籤加入 role=&quot;modal&quot; 之後當作 modal 使用。 Web developers must not use the ARIA role and aria-* attributes in a manner that conflicts with the semantics described in the Document conformance requirements for use of ARIA attributes in HTMLtable. Web developers should not set the ARIA role and aria-* attributes to values that match the default implicit ARIA semantics defined in the table. - w3c spec 當然，雖然 spec 這麼說，但某些 tag 像是 input + label 的 hack 對前端開發來講真的很方便。這部分或許就看大家的取捨了。 12&lt;div class=\"btn\" role=\"button\" aria-disabled=\"false\"&gt;Click to Signup&lt;/div&gt; Accessibilityaccessibility 其實可以另外再寫一篇文章來討論，但因為不再本篇的討論範圍內，這邊只列幾點關於 accessibility 的注意要點。 文字的大小 顏色的對比 是否加入適當的 attr。（img 的 alt, link 的 title 等） 適當的 aria-* 使用 如果對 accessility 有興趣，建議大家看看： ARIA w3c 的 aria 標準。 WebAIM checklist WCAG 的 checklist WebAIM inviblecontent 關於 CSS invisible content 的介紹 模板語言（已 rails views 為例）目前市面上有很多模板引擎，像是 ejs erb handlebar jade 等等，都有一套特定的語法、partial、客製化的函數等等幫助你簡化冗長的 HTML。 就 rails views 來說 12345678&lt;%= render 'partial/buttons/primary', locals: &#123; :name =&gt; 'foo' :title =&gt; 'bar'&#125; %&gt; 將常用的元件拆成 partial，並且放在對應的資料夾（我的習慣是將所有 partial 檔統一資料夾管理，除非那個 partial 只有在某一個特定頁面使用）。這樣一來就可以很容易地引入已經撰寫好的 HTML 架構。 123456&lt;%= render 'partial/modal', locals: &#123; :name =&gt; 'foo', :title =&gt; 'bar', :image =&gt; image_path('a.png')&#125; %&gt; 結論HTML 的重構比起 CSS 跟 JS，算是簡單許多（只要 css 撰寫的時候不用 tag 做 styling），不過從頭看下來，要顧慮的事情也不少。正確的使用 tag 以及顧慮 accessibility，能夠有效地增加 UX，同時自己在修改的時候也不會看到一大堆 div 看到心癢癢。 Legacy Code 專欄 從 legacy code 中尋找出口（上） 如何從 legacy code 中尋找出口（中）- CSS 篇","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"重構","slug":"重構","permalink":"http://kjj6198.github.io/tags/重構/"},{"name":"HTML","slug":"HTML","permalink":"http://kjj6198.github.io/tags/HTML/"},{"name":"aria","slug":"aria","permalink":"http://kjj6198.github.io/tags/aria/"}]},{"title":"令人期待的 PostCSS","slug":"go-to-postcss-or-not","date":"2016-09-16T15:58:02.000Z","updated":"2017-02-28T15:04:08.000Z","comments":true,"path":"2016/09/16/go-to-postcss-or-not/","link":"","permalink":"http://kjj6198.github.io/2016/09/16/go-to-postcss-or-not/","excerpt":"","text":"從 SASS 到 PostCSS大約在一年前，PostCSS 開始竄紅在前端生態圈裡，不外乎就是所謂的 preprocessor 的特性、高度客製化自己的 plugin、搶先使用 cssnext 的功能，還能夠搭配各種建構工具（gulp, webpack），用起來非常輕鬆寫意。 變數雖然剛開始看到 PostCSS 的時候還挺興奮的，但隨即思考了一下：「真的有必要馬上把 SASS 取代掉嗎？」。 PostCSS 的優點在於你能夠選擇你想要的 plugin，需要時再使用就好。舉變數的功能為例好了，postcss-simple-vars 能夠模擬 SASS 的變數宣告及使用行為。對我來說怎麼看都彆扭，因為 SASS 除了變數本身宣告之外，還有 map, list 的型別，而且具備了相當完整的 API 操作。例如：取值、判斷式、迴圈功能等。 1234567891011$colors: ( main: #abc, sub: #bac, word: #333);.container &#123; background-color: map-get($colors, $main); color: map-get($colors, word);&#125; 就算使用 css spec 的 var 也是一樣，沒有 map 或 list 取值的功能。 12345678910:root &#123; --wordColor: #333; --bgColor: #fafafa;&#125;body &#123; background-color: var(--wordColor); color: var(--bgColor);&#125; （o.s：而且這樣子寫其實有點醜很醜） 或者，SASS 的 @function 也能夠進一步將 map-get做包裝 12345678910111213141516171819202122232425262728293031323334353637383940414243444546$colors: ( main: #abc, sub: #bac, word: #333);/* alias method for getting color from $colors map/// @param &#123;$key&#125; the key you want to choose////// eg: color: c($word); */@function c($key) &#123; @if map-has-key($colors, $key) &#123; @return map-get($colors, $key); &#125; @else &#123; @error \"Unknown key #&#123;$key&#125;\"; &#125;&#125;.container &#123; background-color: map-get($colors, $main); color: map-get($colors, word);&#125; 因為 PostCSS 生態圈廣泛的原因，不少獨立開發者的插件很可能因為沒有在維護，或是因為疏忽而導致編譯錯誤有小 bug 等等的問題，相對之下 SASS 本身具有的功能相對完整的多。 mixins 跟 function相對應的 plugin 有 postcss-mixins 跟 postcss-functions 雖然模擬的 mixin 的行為，但如果要搭配判斷式使用的話，又要花一番功夫。 123456789101112131415161718192021222324@mixin state($state,$namespace: '') &#123; @if ($namespace != '')&#123; .#&#123;$namespace&#125;-#&#123;$state&#125; &#123; text-transform: uppercase; &#125; &#125; @else &#123; .$&#123;state&#125; &#123; text-transform: uppercase; &#125; &#125;&#125; 而 function 的部分也一樣，如果使用純 CSS 搭配 PostCSS 撰寫，沒有辦法使用 SASS 原生的 function。雖然能夠用 js 自定義 function，這一點其實還蠻吸引人的，但如果要模擬 SASS 相對應 function 的話，又要在重造一次輪子，不免顯得有些麻煩。 相較於 SASS 還不成熟相對於 SASS 來說，PostCSS 其實還算蠻新的工具，雖然生態圈很廣泛，插件也多，但目前版本仍在快速變動中，也還有很多 issue 沒有解完，SASS 因為本身是使用 Ruby 撰寫，雖然速度會比 PostCSS 慢一些（好吧，應該是很多），但其穩定跟完善的 API 跟型別、語法，都是 PostCSS 還無法達到的程度。 PostCSS 的優勢來說說 PostCSS 的優勢吧！目前我最喜歡搭配使用的功能有 autoprefixer cssnano。 autoprefixer 能夠幫你處理 CSS 麻煩的前綴，以往是使用 mixins 來解決，現在完全交給 PostCSS 處理就可以了，相對起來乾淨簡潔多了；cssnano 則是幫你處理 CSS minify，搭配 gulp 使用你可以只要安裝 gulp-postcss gulp-cssnano gulp-postcss gulp-sass 就可以進行 css 編譯跟最小化的動作了。 除了上述的插件之外，我認為很棒的插件還有 postcss-sorting：根據定義的規則排序你的 css properties precss：包含許多 sass-like 的功能 stylelint：lint 你的 CSS stylefmt：根據 stylelint 的規則幫你 format css code doiuse：幫你偵測目前 CSS 的瀏覽器支援度 livereload：搭配 webpack 的淫威之下，css-loader 本身就幫你設定好了 hot reload 的配置，只要一改動 style 檔案，就可以在不用重新載入的情況下將新的 style 套入。 為什麼我不敢離開 SASS搭配 PostCSS 的確非常方便，但我不認為兩者同時套用能夠減少日常開發，畢竟一旦出錯，就得花時間去研究底下的運行機制。有可能 PostCSS 編譯完之後再給 SASS 編譯會報錯；又或者某個套件的 bug 導致檔案沒有完整編譯，某段的 CSS 代碼沒有生效等等，都是潛在的問題，目前的開發我也只有使用 autoprefixer cssnano stylelint 來幫助簡化、檢查 CSS 而已。 結論或許最後 SASS 會完全被 PostCSS 打敗也說不定，但 SASS 本身完整、成熟的架構跟語法，還是讓我不想要輕易完全使用 PostCSS 的最大主因，哪天等 PostCSS 成熟到能夠完全獨立於 SASS 的時候，我可能就會轉移過去了吧！就像當初在學 CSS 的時候，也是猶豫了很久才開始學習 SASS 那樣。不過，這兩者（sass, postCSS）是可以共存、互補的。 既然享受了 PostCSS 高度彈性化的優點，我們接下來也不得不關心抽象化滲透，因為插件有可能因為時代的變遷，或是開發者不在維護的關係而出現錯誤。這些插件分別看來功能微小，但是全部加起來之後能夠省下的時間也是很巨大的。；而 SASS 完整的語法、變數系統雖然需要花一段時間學習，卻能夠用統一的語法大幅提升 CSS 維護度。 在這個組件化盛行的年代，前端工程的開發逐漸傾向於維護模組化的檔案（react, css-modules 等），最後可能不需要那麼多繁雜的操作（此指 sass 的 function、變數等），而是回歸到最原始的純 css 也說不定。 reference PostCSS I’m excited about Postcss, but I’m scared to leaving SASS Breaking up with scss cssnext","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"postcss","slug":"postcss","permalink":"http://kjj6198.github.io/tags/postcss/"},{"name":"sass","slug":"sass","permalink":"http://kjj6198.github.io/tags/sass/"}]},{"title":"webdevelopment 筆記","slug":"javascript-note3","date":"2016-07-31T06:45:18.000Z","updated":"2018-08-29T14:34:34.000Z","comments":true,"path":"2016/07/31/javascript-note3/","link":"","permalink":"http://kjj6198.github.io/2016/07/31/javascript-note3/","excerpt":"","text":"瀏覽器的字體渲染前陣子發現了 font-smoothing 的屬性，雖然 w3c 已經把他從標準刪除，但在 chrome 上面還是可以使用這個屬性。 但令人好奇的是，其他瀏覽器的字體渲染方式呢？ 其實字型渲染是一個一直以來容易被忽略，卻又是極為重要的議題。因為網站的易讀性除了 layout 之外，再來就是字體了。 為了確認網站在瀏覽器的一致性，稍微研究了一下字體渲染的方式。分享在這邊給大家做參考。 每個字，在電腦當中都會被當作一個向量圖像。而當我們把字體渲染在螢幕上的時候，就會把字型用像素渲染的方式呈現在螢幕上，所以每個字其實都是由一個個小方塊組合起來的。 但問題發生了，用小方塊的壞處就是在邊緣會出現無可避免的鋸齒狀，造成閱讀體驗不佳。 基本解法 grayscale這個解法是讓邊緣的像素補上一些灰階的像素，讓字型遠遠看起來比較圓滑，用這些灰階的像素來補償字體本來應該有的面積。這個方法很聰明又優雅，讓人不禁佩服。 進階解法 subpixel顏色信息，如果我們把屏幕截圖不斷放大，可以看到字體邊緣有紅藍兩色出現，這就是亞像素渲染了。 在LCD屏中，一個像素是由紅綠藍三個緊密排列的亞像素構成的，它們決定了這一像素的顏色和亮度。由於它們是如此之小，以至於肉眼不會把它們看作是一個個獨立的色點。如果我們仔細看看上圖中被白點標記的「紅色」像素，就可以發現它所採用的渲染策略：所有的亞像素都可以單獨控制開或關的；若「空白」像素最右側的亞像素是紅色的話，則此像素都將填滿紅色。 問題點：百家爭鳴的瀏覽器每個瀏覽器實作字型渲染的方式都不盡相同，甚至不同的 OS 下也是。更蛋疼的是，在Windows下還可能採用兩種技術來渲染—— GDI或者DirectWrite。 Windows在Windows系統下，字體格式對其渲染效果有很顯著的影響，比如PostScript字體和TrueType字體之間就存在著巨大的差別。但這種差別並不是由瀏覽器所引起的，只要底層的字體一樣，我們就可以看到完全相同的渲染效果。 儘管這種方法並不十分可靠，但從字體的命名中我們可以大致推斷該字體所採用的渲染技術，比如，EOT和.ttf格式一定是TrueType技術，反之.otf通常是PostScript技術。但是還有一中封裝的字體格式WOFF，它可以包含其中任意一種字體格式。因此光看文件名 ​​是不可能清楚它所採用的渲染技術的。除了EOT​​和.ttf格式文件可以斷定是TrueType渲染技術外，其他文件格式所包含的是哪種字體都無法確定。因此在你購買字體時，你最好對想要購買的字體做一番了解。（@Ryekee :我覺得這一句根本不用翻譯，中國還有人會買字體麼？） TrueType和PostScript的區別在於描繪曲線時所採用的數學方法不同，但這一差異對柵格器並不會造成太大的影響，只有字型設計人員才需要考慮著兩者的差別。另一個重要的區別就是所採用的字體微調的方法。PostScript只包含了組成字體的各種元素的抽象位置信息，而TrueType則包含了非常詳細的底層命令，直接接管了渲染的進程。然而造成兩種渲染技術的差異並不是它們的設計理念上的差別，而是源於Micro$oft採對TrueType採用了新的渲染引擎。 操作系统OS提供了支持不同的字体渲染方法的API。在windows下是GDI(Graphics Device Interface)和DirectWrite，OS X下是Quartz。 GDI分为GDI Grayscale和GDI ClearType。前者为灰阶渲染API，后者是亚像素渲染API。由于GDI ClearType并未对字体进行垂直方向的平滑，因此当字体较大时会出现边缘不平滑的情况。为了弥补GDI ClearType的不足，MS实现了DirectWrite API，它在GDI ClearType的基础上增加了垂直方向的平滑。但是！字体渲染的API都是由浏览器厂商自己选择的！ 使用同一颜色，感官上的颜色深浅为：黑白渲染&gt;grayscale&gt;sub-pixel。 Chrome35/36采用的是GDI ClearType，因此在字体较大时边缘会出现毛刺，而FF30采用的DirectWrite则没有此类问题。如下图所示： 不過最近看了一下 windows 的字型渲染，不得不說微軟在這方面還真是下了不少功夫。 越來越多的字體設計師都開始注意到Web字體所帶來的技術問題，尤其是TrueType字體的微調。隨著Web字體產業的崛起，他們願意付出精力為屏幕顯示而優化字體。在不遠的將來，我們將看到大量精心設計的字體問世（或者至少是對現有字體的更新）。 隨著屏幕分辨率的增加（以及對柵格器的重大改進），我們慢慢地不再擔心字體渲染的技術細節。採用GDI渲染模式的瀏覽器必將拖後腿，正因為此，未來數年內，我們都還無法放心的使用無微調的TrueType字體。只有當這一類瀏覽器用戶比例降到足夠低的程度的時候，TrueType字體微調（耗時又需要高超的技巧）才可以被扔到一邊。儘管目前市面上幾乎所有Web字體都是TrueType格式的，我仍希望字體行業能夠大規模轉向PostScript格式，因為這種字體能為設計師減少絕大部分的工作。 不過好處是，科技日新月異。希望之後不用再擔心字型渲染的東西。 MAC 使用他們自己的引擎來渲染字體，不管 truetype 跟 posttype 渲染方式都一樣。這個渲染引擎只有一個字，屌。 truetype 跟 posttype 的差別。 結論如果想直接看結果，在網頁的時候，可以使用反鋸齒的技術來增加易讀性。但如果在手機上建議關閉，因為反鋸齒的演算需要比較多的 GPU 來做計算。通常直接採用灰階的渲染方式就夠用了！ 事件控制如果可以，希望在每個檔案都能夠新增一個 EventManager 的方式，統一管理事件。我很喜歡事件委託的方式。 善用 data attribute 的方式來給標籤一些好用的屬性。 microdataRails view最近希望把一些常用的 tag 跟撰寫方式拆成 helper，於是開始去研究 rails 裡面的 view helper method。發現裡面的 helper 撰寫大有學問，這邊跟大家分享： 1234567891011def link_to(name = nil, options = nil, html_options = nil, &amp;block) html_options, options, name = options, name, block if block_given? options ||= &#123;&#125; html_options = convert_options_to_data_attributes(options, html_options) url = url_for(options) html_options['href'] ||= url content_tag(:a, name || url, html_options, &amp;block)end 這邊用 link_to 方法舉例，可以看到這邊分成了兩種方式，如果有給定 block 的話，會將傳入的參數作轉換，如果沒有的話，則是將 option 做處理之後，傳給 content_tag 這個方法。注意到這邊的 block_given? 方法，有這個方法我們就可以很容易的判斷是否有傳入 block。 所以在設計 helper 的時候，可以適時包裝這些方法，簡化 helper 的複雜度： 12345678910def link_to_with_noopener(name = nil, options = &#123;&#125;, html_options = nil, &amp;block) html_options.merge!(&#123; :ref =&gt; \"noopener\" &#125;)if block_given? link_to(name, options, html_options, &amp;block)else link_to(name, options, html_options)endend 請參考：About rel=noopener 再來就是 viewhelper 裡面有很多還蠻好用的方法，我們不用再花很大的功夫重造輪子，像是： link_to_if link_to_unless link_to_unless_current 不過每次只要一動到 helper 就很容易出包…，但直接用原生的 HTML 不但很醜，又不好維護，所以在撰寫 helper 的時候，為了保險還是寫一下 test 吧！ 最近的有個想法是將常用的片段程式碼拆成 partial，並且用比較統一的方式管理！，每次接到新的頁面就要先思考哪些會是局部代碼，哪些會是共用代碼。 partial 設計的幾個要點：經過這次標籤消失的事件，首先先跟顆顆說聲道歉之外，更應該檢討的是以下幾點： 預設值很重要！ if else 判斷式要思考更全面 如果害怕沒有預設狀況，就乾脆讓他噴例外 第三點的實作方法如下： 123456789101112131415161718# in component_helper.rb# ui_component 方法是對 render 的進一步包裝。def ui_component(url, props = &#123;&#125;) render \"components/#&#123;url&#125;\", locals: propsend# in error_helper.rbdef check_required_options!(locals, *options) options.each do |option| raise MissingOptionError, %Q&#123;option \"#&#123;option.to_s&#125;\" is required.&#125; if locals[option].nil? end end private class MissingOptionError &lt; StandardError end 然後在 partial 的程式碼裡面： 12// in _tags.html.erb&lt;% check_required_options locals, :propA, :propsB, :propsC %&gt; 這樣如果 locals 裡面的 option 不夠完整，就會在使用的時候噴出例外，不知道這樣的設計夠不夠完整。而且 partial 設計的時候很容易因為時間久的關係，忘記了 locals 裡面的選項，在 partial 裡面養成檢查 locals 的習慣，可以幫助我們補上遺落的 option。不知道這樣的設計夠不夠恰當跟完整？還請顆顆提出意見。 component 化這邊的 component 化並不是指全部使用 react 改寫，畢竟我們的頁面也還沒有到這種需求。但是既然 rails 有強大的 partial 機制跟 view heleper 方法，我們可以在撰寫的時候做更進一步的拆分： 1234567891011121314151617&lt;div id=\"page_id\"&gt; &lt;header&gt; &lt;%= load_component(\"company_header\") %&gt; &lt;/header&gt; &lt;main&gt; &lt;aside&gt; &lt;%= load_component(\"company_sidebar__header\") %&gt; &lt;%= load_component(\"company_sidebar__content\") %&gt; &lt;/aside&gt; &lt;%= load_component(\"company_summary\") %&gt; &lt;%= load_component(\"company_introduction\") %&gt; &lt;%= load_component(\"company_section\") %&gt; &lt;/main&gt; &lt;footer&gt; &lt;%= load_component(\"company_footer\") %&gt; &lt;/footer&gt;&lt;/div&gt; 但其實目前主站的頁面都仍時常變動，所以過早的抽象化反而會浪費更多成本吧！不過未來如果能用這樣的方式來撰寫程式碼，相信應該是非常好維護的！","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/tags/前端/"}]},{"title":"javascript 筆記","slug":"javascript-note2","date":"2016-07-17T01:48:34.000Z","updated":"2018-08-29T14:33:53.000Z","comments":true,"path":"2016/07/17/javascript-note2/","link":"","permalink":"http://kjj6198.github.io/2016/07/17/javascript-note2/","excerpt":"","text":"別跟我說你懂 margin拿捏 margin 跟 padding 可以很容易地看出前端工程師對 CSS 的掌握程度。說真的超多眉眉角角的，不過看完文章發現原來 margin 的妙用這麼多。以後的實踐或許有比較容易的方法也說不定！ MutationObserver這個鮮為人知的 API，被喜歡翻 MSDN 的我挖掘到了，基本上已經支持目前主流的瀏覽器（IE11+)。 看完介紹會發現他很像事件，專門給 DOM 的變化使用的，不過不同的是，一般的事件是同步的，而 MutationObserver 是非同步的。 這可以幫助我們在 DOM 有變化的時候，做出相對應的反應。 利用這個特性，我們可以達到以下幾個應用： lazy loading initialize 因為在 HTML 實際被 render 之前，DOM 就已經先下載下來了，所以我們可以在 rendering 之前就改變 DOM 的內容。 123456789101112var observer = new MutationObserver ( function ( mutations )&#123; for ( var i = 0 ; i &lt; mutations . length ; i ++)&#123; for ( var j = 0 ; j &lt; mutations [ i ]. addedNodes . length ; j ++ )&#123; lazyLoad ( mutations [ i ]. addedNodes [ j ]); &#125; &#125; &#125;);observer . observe ( document . documentElement , &#123; childList : true , subtree : true &#125;); astrum這是一個很炫砲的 style guide library。做得非常精緻。最近像這些 styleguide 的 library 一直推陳出新，其實就像潘大所說的。寫文件是好的，但是一定要評估成本、其他人的熟悉成本、要建構的時間等等，不能只是因為又潮又炫就自己跳下去自幹。而是要讓寫文件這件事情逐漸被引入。 不過當作 side project 或是自己想玩玩看就另當別論了。 新的問題每個框架都是為了解決某個問題而出現的。但使用了某個框架之後，好像逐漸又會萌生新的問題。我把一些自己在開發上常會碰到的問題整理了一下： 文件切換 我覺得很麻煩的一點就是要一直在 component 之間跳來跳去，有時候還要切過去看看 action, reducer 之類的，久了很容易阻礙思考。 Webpack 打包過慢 要 bundle 的檔案越來越多，webpack 逐漸變得沒有那麼快了。每次寫完 code 還要等他 bundle，而且每次更新都會 reload 一次，說真的還挺麻煩的。 SudoDashboard其實只是想練習 dashboard 的 UI 跟 Websocket 的實作。不過感覺做起來還蠻實用的，最近空閒的時候應該會開始組織一下。還請潘大多多擔任設計指導。","categories":[{"name":"前端週刊","slug":"前端週刊","permalink":"http://kjj6198.github.io/categories/前端週刊/"}],"tags":[{"name":"sudo週刊","slug":"sudo週刊","permalink":"http://kjj6198.github.io/tags/sudo週刊/"}]},{"title":"如何從 legacy code 中尋找出口（中）- CSS 篇","slug":"legacy-code2","date":"2016-06-14T04:01:52.000Z","updated":"2016-10-18T11:32:00.000Z","comments":true,"path":"2016/06/14/legacy-code2/","link":"","permalink":"http://kjj6198.github.io/2016/06/14/legacy-code2/","excerpt":"","text":"前言我們的第一步是先從 CSS 下手，因為 css 是相對於其他前端部分來說比較容易重構的部分。很容易髒亂的 code 也是 CSS。 上一篇描述了在大型專案中引入新框架及技術的困難點，這一篇主要會專注在如何透過現有的工具及框架來重構現有的代碼。 本次的重構技巧會以 SCSS 為主，所以在閱讀本文之前，我先假設你已經有基本的 SCSS 以及 CSS 的基礎。其他預處理器的概念應該是相通的。 引入 style linter 及 editorconfig我們採取的第一步是先引入審查代碼工具。目前比較流行的 css linter 是 stylelinter，他能夠針對 scss sass 語法做 lint。也可以搭配其他 IDE、文字編輯器 plugin。這邊的範例是使用 sublime，其他的 IDE 應該也有類似的功能。 1. 加入 stylelintstylelint 除了可以針對 scss 語法做 lint 之外。由於其本身是用 js 撰寫的，可以客製化自己的 rule 跟加入其他開源的 plugin。 因為 stylelint 是以 AST 的方式解析，所以可以很容易的對文件中的節點做操作。 關於 stylelint 的深入使用，已經超過本文篇幅，有興趣的人可以參考 css trick 的教學 首先，先來安裝 stylelint，run npm install -g stylelint。 再來設置 .stylelintrc 檔，詳細的 rules 可以到這裡 查看。如果你不想要那麼麻煩自己手動一個一個設定的話。可以考慮使用 stylelint-config-standard 這個插件，再根據自己的需求做調整。 npm install --save-dev stylelint-config-standard 這邊還是建議花時間瞭解一下專案的需求來制定 rule，不然有時候太嚴格的 rule，滿江紅看到也懶得改了。 2. 加入 .editorconfigEditorConfig 是一個為了統一代碼風格的解決方案。每個人文字編輯器的環境可能不盡相同，為了統一彼此之間的環境，這邊我們採用的 editorconfig 設定非常簡單，只要新增一個檔案就好。editorconfig。 目前幾乎主流的文字編輯器都有支援 editorconfig。 常見的 code smell 以及 refactor 方式在開始捲起袖子做事之前，還是先來確認一下目前的專案是否需要 refactor： 許多元件（如 button input）等放在同一個檔案內，查找非常不易。 覆寫了許多 class 造成預期之外的行為發生 早期沒有統一的代碼規範，tab、空白夾雜在一起，閱讀性大幅降低 !important 四散各處 變數的命名跟管理不夠統一 團隊開始擴增 相關的文件不足 接下來介紹一些比較常見的 code smell Orderclass 變多之後，如果 rule 裡面沒有一定的排列順序的話，其實查找很不方便。而且易讀性並不高，像是下列的 code 123456789101112131415161718.class &#123; position: absolute; display: none; padding: 30px; cursor: pointer; list-style: none; font-size: 20px; background: white; margin:0; top:0; left:0; width: 250px; padding-left: 15px; overflow-y: scroll; overflow-x: hidden; border: 1px solid $hr-gray; z-index: 9999999;&#125; 那麼要怎樣排序會比較好呢？這邊提供幾個大原則： display、position box-model font、typography layout(包含 color、border-radius 等) 其他屬性(如animation) 原因：對一個 class 來說，最重要的就是 display 與 position ，所以應該擺在最上面。而其次重要的內容是文字，所以擺第二，最後才是 layout 與其他屬性。至於屬於同屬性的話不限制順序，例如 padding margin 順序調換沒有關係，因為找起來都很方便。只要維持一定的邏輯即可。 123456789101112131415161718192021222324.class &#123; display: none; position: absolute; top:0; left:0; z-index: 9999999; width: 250px; padding: 30px; padding-left: 15px; margin:0; font-size: 20px; background: white; border: 1px solid #aaa; list-style: none; cursor: pointer; overflow-y: scroll; overflow-x: hidden; &#125; 善用 sass map 管理變數style 檔案變多了之後，相對的要管理的變數也會變得越來越多。除了在命名時加上前綴之外，我們也可以利用 sass map 的方式來統一管理。而且 sass map 提供了一些很方便的 function 來操作，像是 map-get map-has-key等等，可以很有效地把變數 group 起來。很像 js 的 object。 以 z-index 來說，我們可以改寫下面的 code 123456789101112131415161718192021/* before */$zindex-navbar: 100;$zindex-dropdown: 200;$zindex-tooltip: 300;$zindex-modal: 400;.navbar &#123; z-index: $zindex-navbar;&#125;/* after */$zindex: ( navbar: 100, dropdown: 200, tooltip: 300, modal: 400);.navbar &#123; z-index: map-get($zindex, 'navbar');&#125; 用 map 的方式取值，看起來好像比較厚工一點，我們可以用 sass 的 function 包裝起來： 1234567891011121314/** * z alias for z-index * get zindex map value */@function z($key) &#123; @if(map-has-key($zindex, $key))&#123; @return map-get($zindex, $key); &#125; @else &#123; @error \"unknown key #&#123;$key&#125;\"; &#125;&#125;.navbar &#123; z-index: z($zindex, 'navbar');&#125; 當然還有其他的應用像是 color typography 等等，都可以搭配 sass map 的方式來操作。 如果你認為上述的方式跟用前綴的方式分類變數沒有什麼不同的話，不套用也沒關係，重構是為了讓之後的開發更舒服。 大量的巢狀 class我的建議是不要超過三層，第一是易讀性非常低，再來很容易覆蓋到權重。可以採用一些目前比較熱門的 css 命名規範如 OOCSS 或是 BEM，或者搭配兩者一起使用。 但最重要的一點是自己寫起來的感覺，不要讓規範箝制你了。 如果想要使用 scss 的巢狀功能方便閱讀，又不想要讓巢狀 class 覆蓋權重的話，可以使用 @at-root，@at-root 在編譯的時候會幫你把巢狀拆出來到 root。 另外可以使用 &gt; 子元素選擇器來取代後代選擇器。 1234567891011121314.classA &#123; @at-root .classB &#123; // bla &#125;&#125;// compiled.classA &#123; &#125; .classB &#123; // bla &#125; 實際的 use case 如下： 12345678910111213.alert-modal &#123; @at-root &amp;__header &#123; &#125; @at-root &amp;__body &#123; &#125; @at-root &amp;__footer &#123; &#125;&#125; 以上的代碼好像沒有想像中的好看，等下可以搭配 mixin 把它進一步做簡化。 善用 Mixin 簡化程式除了一般使用 mixin 來加入 prefixer 之外，mixin 能夠做的事情還有很多，這邊提出幾個方法給大家參考。 BEM mixinBEM 的命名方式，如果一直手動 key 的話，感覺也挺麻煩的，而且 key 錯的機率也蠻高的，我們可以利用 mixin 來簡化他。 順便一提，如果你的專案已經套用了 postCSS，可以使用 postcss-bem 來幫助命名。 如果你不喜歡他的命名方式，或是當前還無法套用 postCSS 的話也沒關係，我們可以自己做一個。 上面的 code 可以改成下面的形式： 123456789101112131415161718192021222324252627282930313233343536373839@mixin block($block_name) &#123; .#&#123;$block_name&#125; &#123; @content; &#125;&#125;@mixin element($element_name) &#123; @at-root &amp;__#&#123;$element_name&#125; &#123; @content; &#125;&#125;@mixin modifier($modifier_name) &#123; @at-root &amp;-#&#123;$modifier_name&#125; &#123; @content; &#125; &#125;@mixin state($state_name) &#123; &amp;.is-$&#123;#state_name&#125; &#123;@content;&#125;&#125;// modal.scss// before.alert-modal &#123; @at-root &amp;__header &#123; &#125; @at-root &amp;__body &#123; &#125; @at-root &amp;__footer &#123; &#125;&#125;// after@include block(\"alert-modal\") &#123; @include element(\"header\") &#123;&#125; @include element(\"body\") &#123;&#125; @include element(\"footer\") &#123;&#125;&#125; 這樣一來簡單的 BEM mixins 就製作完成了。注意到這邊我們使用 at-root 的方式來避免巢狀 class。 可以按照自己的喜好來調整命名方式，或者嚴謹一點對參數做一些處理（轉為小寫等等）、加入判斷式等等，或者今天你想要使用巢狀 class 的話可以加入額外的判斷參數。 123456789@mixin element($element_name, $at-root: true) &#123; @if($at-root) &#123; @at-root &amp;__#&#123;$element_name&#125; &#123; @content; &#125; &#125; @else &#123; &amp;__#&#123;$element_name&#125; &#123; @content; &#125; &#125; &#125; util mixin舉例來說，在設置 padding margin 的時候，我們常常會將上下或是左右的值設為一樣。寫久了難免會嫌麻煩，這時候就可以拜託 mixin 了。 123456789101112131415161718// before.classA &#123; margin-right: 10px; margin-left: 10px;&#125;// after/* * lr Alias for left right */@mixin lr($box_model, $value) &#123; #&#123;$box_model&#125;-left: $value; #&#123;$box_model&#125;-right: $value;&#125;;.classA &#123; @include lr(\"margin\", 10px);&#125; 這邊沒有寫得很嚴謹，你可以另外加入判斷式來保證輸入的值是合法的，類似的概念也能套用到 top left 設值上。 或是常常遇到的 clearfix。 1234567891011@mixin clearfix() &#123; &amp;:before, &amp;:after &#123; display: table; content: \"\"; clear: both; &#125;&#125;.column &#123; @include clearfix;&#125; child selector mixin常常會遇到使用 child selector 的情境。我們可以用 mixin 進一步包裝起來。 1234567891011121314151617// before.list &#123; &amp;:first-child &#123; //bla &#125; &amp;:nth-child(2n) &#123; //bla &#125;&#125;// after @mixin first() &#123; &amp;:first-child &#123; @content; &#125;&#125;.list &#123; @include first() &#123;&#125;;&#125; 這邊推薦 Family.scss，搜集了許多好用 child selector mixin。 p.s：我認為剛入門 CSS 的人還是從純 CSS 開始學習比較好，以免被 SCSS 的語法糖給寵壞了 善用 Comment在缺乏 function 的 css 下，使用 comment 來解釋 class 更為重要。這邊提供一些，comment 的技巧。 註解不但方便自己閱讀，之後別人接手也會比較快理解這個 class 該如何使用、在哪個場景使用。 目錄如果文件包含的 class 較多，可以考慮在文件最前面加入目錄，方便之後查找。 123456789/** * INPUT * text * select * number * BUTTON * primary * warn */ 魔術數字、HACK、使用方式12345678910111213/* * for input[type=\"text\"] * e.g: &lt;input type=\"text\" /&gt; */ .text-input[type=\"text\"] &#123; padding: 20px; /* page offset */ top: 27px; /* IE 8+ hack */ // ...&#125; CSS 結構基本上分成幾個大方向：module base config helper modulemodule 資料夾裡存放所有模組化的元件，像是 button input modal 等等。如果元件拆得更細的話，可以再另外開資料夾，像是 button 有可能樣式比較多，這時候我們可以另外開一個 button 資料夾，裡頭存放所有 button 的樣式。 basebase 裡頭放置了像是 grid normalize reset typography 等比較基本的架構。 config存放變數跟 color 的地方，設定的內容統一存放在這個資料夾統一管理。 helper存放客製化的 function 跟 mixin。 寫在最後如果你有額外的時間，建議你還是可以去看看像是 postCSS、css-modules、webpack 等優秀的開源工具。不然整天跟 CSS 打架總有一天會精神耗弱的XD。 做了一個DEMO，非常陽春。 如果你也想分享自己在前端跟 legacy code 奮鬥的過程，或是有更好的解決方案，歡迎在下面留言。 持續關注前端趨勢這裡分享幾個覺得蠻優質的資源。 掘金網 碼天狗（但最近前端的分享不多） TechBrige CSS wizard referenceCSS guideline Why Stylelint CSS coding techniques why you should refactor your css rsscss.io Legacy Code 專欄 從 legacy code 中尋找出口（上） 從 legacy code 中尋找出口（中）- HTML 篇","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"重構","slug":"重構","permalink":"http://kjj6198.github.io/tags/重構/"},{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/tags/前端/"}]},{"title":"從 legacy code 中尋找出口（上）","slug":"legacy-code","date":"2016-06-11T00:56:15.000Z","updated":"2016-10-18T11:31:38.000Z","comments":true,"path":"2016/06/11/legacy-code/","link":"","permalink":"http://kjj6198.github.io/2016/06/11/legacy-code/","excerpt":"","text":"在我第一次進入主產品開發後，把代碼從 Github 上面 pull 下來。 「這是什麼鬼東西？」 結構混亂，大量覆寫的 class 各處都是，以及很可怕的巢狀 ID。view 的部分也有些地方非常雜亂……。看來 legacy code 跟 refactor 永遠都在進行式。 對於日新月異的前端來說，要接觸一個新技術、框架並不是太困難的事。但困難點在於如何在現有的大型專案中做取捨，我們常常會有其他考量。例如團隊的接受度、team leader、其他政治因素等等而無法輕易地將新框架套用在目前的專案上。 這個系列的文章主要會分享如何在既有的專案中小心地進行重構。希望對各位有些幫助。 目前遇到的問題HTML 的架構混亂肥大，許多 util class 四散各處，在 CSS 中更可以看到大量的覆寫 class。雖然聽說之前已經有整理過了，但顯然這個房間還充滿許多灰塵。 我認為前端常常遇到的 smell 問題有： 復用性不足：儘管已經採用 React，但仍有許多高耦合的 component。而且其中還夾雜著 flux 與 redux 兩種不同的 library 大量混雜業務邏輯的代碼（如 API ability 的判斷等），不僅要實際去了解業務流程外，還要知道檔案放在哪，必要時可能還要去看後端的程式碼 HTML 的撰寫不夠語義化，充斥太多 util class 及 atomic class，後面接手的人比較難搞懂這行 view 裡頭所要表達的東西。 CSS 檔案的撰寫不夠模組化。有太多混雜的模組都放在同一隻檔案中，查找非常不方便。 大量的覆寫 class 造成上版時有很多意外的狀況發生。 沒有統一的規範跟撰寫方式，很快代碼就會往指數性的肥大邁進。 身為一個前端工程師，經驗還稍嫌不足的我來說，雖然目前正在孤軍奮戰中，但其實還能做一些事。有問題對我來說是一件非常值得興奮的事，至少對我來說，那是一個可以捲起袖子來做事的大好機會。 解法那麼，到底該怎麼做呢？我認為可以從以下幾點開始下手 著手撰寫 styleguide，讓自己與之後的前端團隊快速上手，並且有一定的準則可以遵守 技術選型：自動化工具、code quality 工具、選擇與淘汰 test 框架：前端代碼大部分都還沒寫 test，未來等架構穩定的時候希望可以趕快補上。 讓重構變得簡單 讓 comment 及 doc 變成習慣： comment 的 doc 永遠是工程師的好朋友！ 提交代碼的規範 本系列的文章主要會著重在重構的部分，最後一篇會再跟大家分享文件應該寫些什麼，以及前端如何提交代碼及發送 pull request 給 code reviewer。 目前已經大致撰寫了 styguide 的架構，下一步是逐漸重整 CSS 的架構以及拆分 HTML 組件。 這不是一朝一夕就能完成的東西，甚至就某種角度來看會拖延到專案的進度。有點像是默默付出的工作吧…！畢竟在原有的專案中做改變本來就有較大的阻力。 何時應該重構隨時重構，不要為了重構而重構。再來可以參考三次法則) 上版的時候對現有的 HTML 及 CSS 重構，或者對應的 component 寫新的 js 模組時重構，順便撰寫 Comment 及文件 送 pull request 的時候：不過要確定自己有寫上詳細的 comment 及 doc，才能提高 code reviewer 的 review 意願，而 senior 總是能更快看出代碼裡面的問題。 我們常常對一些既有代碼的架構感到心癢，或者很想要趕快重構。但在 workaround 的情況下，有時重構的成本是非常大的。 何時不應該重構其實比起重構來說，更重要的應該是拿捏不應該重構的程度。身為工程師或多或少都會對別人的代碼嗤之以鼻，恨不得趕快把 code 清掉。但，既然 code 有某種程度的肥大，代表他或多或少解決了問題。而且重構是需要成本的。就算是以目前的開發來說，通常也是先著重於將功能實作後，在有限度地作小幅度的調整以及逐漸補齊文件及註解。對於重構來說，最重要的是 consistency。s 目前的解法雖然不漂亮，但確實解決問題的時候。 目前的代碼重複率還不高的時候 重構的成本太大，甚至影響到系統本身的時候。 保持心平氣和重構的時候記得控制自己的情緒。我們很可能一不小心就在咒罵代碼或前任，然後在情緒上頭反而過度重構，造成更多的問題也說不定。 代碼的存在是有歷史的 有可能是進度太趕、有可能是政治因素、又或者當時的技術還沒到位。但可以確定的是，情緒化完全無法解決問題。 don’t let anger contol you Talk is cheap. Show me the code. 下一篇，我會開始分享一些重構的技巧。 Final Word最後還是要聲明一下，這篇文章雖然會著重在一些重構的技巧上，但其實從 legacy code 中尋找出口的方法不只是重構而已。希望大家不要過往矯正，一看到髒 code 就急著捲起袖子重構。退一步評估一下成本跟重構的價值再做決定。 Legacy Code 專欄 如何從 legacy code 中尋找出口（中）- CSS 篇 從 legacy code 中尋找出口（中）- HTML 篇","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"重構","slug":"重構","permalink":"http://kjj6198.github.io/tags/重構/"},{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/tags/前端/"}]},{"title":"2016 g0v summit 心得","slug":"2016-g0v-summit","date":"2016-06-10T16:00:00.000Z","updated":"2017-07-20T07:19:51.000Z","comments":true,"path":"2016/06/11/2016-g0v-summit/","link":"","permalink":"http://kjj6198.github.io/2016/06/11/2016-g0v-summit/","excerpt":"","text":"因為一則廣告而創立的 g0vg0v 的由來其實是因為經濟動能推升方案（就是那個史上最腦殘的廣告) 這群熱血的工程師決定組成 g0v。致力於推動政府開放，並且以網路的方式推廣給大眾。 g0v 能夠紅，是從 318 學運開始。因為 hackfold 的共筆資料夾引入、直播工具…，讓大眾更了解…。 然後在場的 700 多位參與者中，大約有一成左右是來自政府的事務員，甚至連即將卸任的張善政也到了 g0v 分享推動政府開放資料的過程。 「把夢做大，然後相信總有一天會被別人看見，屬於自己的故事。」這大概是參加 g0v 最大的感觸。 只能說，方心沒辦法參與實在是很可惜的一件事，不過 g0v 有直播以及大會的共筆，能夠看看筆記、影片過過乾癮也好。 TL;DR沒人想得到，目前遍佈三大洲、超過500名公民黑客的零時政府，當初是因為台灣政府的無效廣告而催生。這群黑客村裡的工程師除了會寫程式，普遍英語能力好，他們關注世界各國公民科技對政府的影響。高嘉良在2014年就曾花兩個月的時間到各國城市，與開放組織、社群交流，吸取當地經驗，回台分享給社群。就這樣，本來應該平淡度日的程式工程師們，因為改造社會的熱情，一腳踏入公民科技。 第一次參加 g0v summit，聽說（和與會者聊天）這次的主題「拆後重建」有把主題拉廣。以前的議題技術性比較濃厚，吸引到的與會者也大多為工程師。這次不但有來自各國的與會者、講者，還有將近一成的與會者是政府機構的事務員。 你會發現 g0v 不會抱有特定立場，而是用一種中介者的角度幫你把事情記錄下來。直播也好、他們開源的小工具也好，都是如此。如果你有時間，可以看看這次的直播或是大會共筆，如果真的抽不出時間來，就來看看我的筆記吧！ 大會共筆 筆記.org 到 .ngo分享者是 ngo 的工程師，所以在講述自己在 NGO 的同時，也分享蠻多在開發時遇到的問題的。 分享者提到，環境資訊協會目前遇到的挑戰有： 2000 年到 2016 年：關於環境的議題根本沒有報社要報，頂多出現在生活版。=&gt;當時代開始逐漸變遷時，工具勢必要做改變 程式翻修：產品從剛上線開始就是 legacy system，通常要做好準備，在早期的沒有時間讓你 refactor，而是穩定之後才會開始重構，而且當時還導入了外部工程師幫忙 當 nobody 變成 somebody：面對的問題越來越多 人：有了組織、人、主管、薪水，管理變得困難 世代變遷：新人不斷輪替、老人沒時間談理想 =&gt; 溝通出現問題 既得利益者：當 nobody 變成既得利益者之後，我們還記得自己的初衷嗎 最後他將 NGO 扮演的角色做了總結： 匯聚資訊與力量的平台 Proxy：代理政府，快速回應議題 Agent：公民代理人 結論： 公司是除了國家以外，最重要、影響大家最多的組織。 民主與公民參與之開放媒體講者是 VOXE 的創辦人。VOXE 的概念跟台灣的(立委投票指南)[http://vote.ly.g0v.tw/]很像，46% US 的選民在總統大選時根本沒有出來投票。70%年輕人在2014的歐洲議會選舉都沒有出來投，很多人認為沒差。很多人認為選出來的人不在意民意，所以就乾脆不投。所以希望能夠透過工具來改善，而創立了這個平台。 其中有個問題讓我印象比較深刻，「怎麼讓大家付諸行動？這是最困難的一部份」，講者的回答是，透過工具的使用。畢竟一般人不可能整天抗議、整天看政見，有小孩老婆工作等等要顧，所以工具一定要夠簡單，才會刺激別人去用。 原本還有人問到，阿你們要怎麼募資，他的回答是 google 給了他們 20 萬歐元XD。完全不用擔心了啊！ 結論：工具是用來解決問題的。 強震即時警報系統這幾天大家應該都有收到地震的預報簡訊。講者開頭先敘述了 921 的實際經驗，提醒大家防震的重要性。先提一些地震小知識。wiki P 波的傳播速度最快，每小時兩萬八千里。地震預報就是用這樣的原理。當 P 波到達之後就是 S 波，S 波之後就是最可怕的表面波。 也就說在 P 波抵達時，接下來在表面波到達時所採取的動作是關鍵 今天，假設我們收到了這樣的簡訊，該怎麼辦才好？ 確認是否能在 30 秒內跑到屋外。 30 秒無法跑走，就需要知道房屋裡最安全的地方。 不要打卡，有可能 30 秒之後你就消失在這個世界上了 有些地震盲區，可能在震完之後才收到簡訊。日本大阪神地震，根據統計有七成受難者是自救，兩成是靠親友，剩下一成才是官方。這代表日本人真的把防災當作一回事。 額外加碼 精美東京防災手冊 我們的心態、以及相對應的防範措施，我們準備好了嗎？講者認為基金會會是一個解法。 結論： 防災，要從自己做起 我在新聞界臥底的日子講者是 Kirby。是 零傳媒 的創辦人 奇怪欸！女師二度爬山後來調查發現，這個女老師根本沒有男朋友。新聞的資料錯誤百出，媒體報導普遍素質低落。於是決定創辦零傳媒、以及提供資料視覺化的工具幫助記者在報導時有資料可以引述。而且可以提供給非技術人好上手的工具。 目前好用的資料搜集工具： open refine spreadsheet p5.js kimono 同時講者也分享了幾個真實案例： 冰桶挑戰：發現冰桶盛行的那幾週，佔了總捐款金額的 70% 急診人生 發現了以下情況： 資料記者要會寫程式嗎？進入成本會不會太高 找得到會設計、會寫文章、會採訪、又會技術的工程師非常難 新聞網站的文章表現沒有精練 開源的工具有可能沒有再維護了 服務有可能會終止 於是希望透過 piotDB 幫助到記者，也能夠幫助工程師在以後資料收集、視覺化中有更好的選擇。 秒退頂新地圖聽完講者分享之後，其實會發現這場看似臨時起意的秒買秒退，背後其實是有經過縝密計算的。到最後竟然還出現發起人上台分享心得。 因為秒退發起人已經先研究過好市多的商業結構，100% 滿意是買賣雙方的保證行為，對好市多來說這個活動達到需宣傳的效果，對於使用者來講則是滿足了購買滿意的條件。雙方利害一致、提高曝光度，好市多沒有理由拒絕。 先講結論 2015 營收少 15 億，淨虧損 19 億。（總資產 2.5 兆，佔全台灣的六分之一） 直接擊垮頂新大魔王是比較困難的一件事，所以先從小頭目開始。人民的力量是分散的，秒退地圖縮短長期抗戰的時間，秒退的挑戰第一個是爭議性的問題，第二個是行動本身的問題（需要親自到目的地去，忍受民眾和店員的目光）。秒退地圖可以把秒退狀況視覺化，把數據視覺化之後，比較可以組織與策劃下一步的目標。需要有人維持系統、推廣、蒐集登入資料等（系統本身的）挑戰。 不過身為一位正常公民，要做的事情實在太多了。誰跟你每天秒買秒退，今天林鳳營特價還是跑去小確幸一下。 長大是什麼感覺 來看看日本當初是怎麼讓雪印倒閉的連結。 從社群的角度來看： ptt 大部分是贊成，偶爾會有噓出現 Dcard 罵聲連連。一大堆反秒買秒對的文出現 Facebook 偶爾出現反秒買秒退的動態 先不論這個活動本身的道德辯證（講者說他只 focus 在解法）。 不管這個活動本身正不正確，他也已經有效地引起關注及思考，而大家一起討論、尋求解答，其實就是一種開放協作(open collcation)。 秒買秒退地圖 結論： 頂新或許什麼都可以買，但他買不到公民行動的良心跟憤慨 從 g0v 到 gov – 潛入衛福部 400 天讓我噴淚的一場分享，潛入衛福部第 400 天。也是我今天聽下來覺得最棒的演講 直播影片 公共政策網路參與平台 這個平台仿效美國、英國的機制，只要超過 5000 人連署，政府就要在 2 個月內作出回應。 講者從原本的 g0v 進入 gov，在引入協作工具中，也開始反思。政府要面對民間訴求很難嗎？詳細介紹一個公民提案到法案修正經過的過程與遭遇到的問題，點出社群參與者與政府觀點的落差。可以發現到，政府裡頭的公務員其實還是很願意做事情的。而這個案例最後政府回覆並且承諾修法，可惜提案人在法令公告前已經過世，而這項法案修正很可惜的沒有在他在世時協助到提案人。 我還記得聽完演講之後，掌聲大概持續了三十秒有吧！雖然最後真的很可惜沒有幫助到提案人，但我相信他的分享已經間接影響很多人對政府的觀點了。 政府要面對民間訴求，還真的挺難的 開放，是有成本的。 工程師要避免 single point of failure，公務員要避免 single point of success 不開放、不透明的黨產在選前常常看到國民黨黨產的相關圖表。 講者還開玩笑說具有所謂的地址，做成了地圖，可以看到國民黨在台北的土地，在台南白河有很大的地方都是國民黨的！一看街景種滿了檳榔香蕉。以後搞不好會做出國民黨黨產觀光app。 國民黨黨產尋訪車遊 在台灣因為沒有政黨法的關係，所以沒有特別限制黨產的來源。這造成了國民黨無私地接收了當時國家徵收的土地和營收。 國民黨： 225 億 民進黨： 4 億 其他： 1900 萬 可以看到這樣懸殊的落差，造成小黨生存不易，光是打廣告就先輸一半了。 開放的問題 歷史檔案的保存與修復 資訊的完整性 黨產解密 gitbook 結論：國民黨不倒，台灣不會好 unconference在 unconference 裡主要是讓與會者發起自己的想法，第二天早上在交誼廳互相討論自己的想法。 時間有限，我只聽一些自己有興趣的主題： 轉型正義如何降低討論的門檻，吸引一般人關注是討論重點。通常除了 228 受害的家屬、親友會去關注之外，一般社會大眾比較不會關心。一來是台灣歷史教育對 228 的輕描淡寫，再來是因為大部分人沒有經歷過 228。 歷史學家的instagram 二二八事件地圖 轉型正義遊戲 建構大眾對議題的興趣 對抗資本主義的共享經濟談大家對共享經濟的想像 維納斯計畫 日本共生住宅 Uber AirBnB又是共享主義，但又是資本主義的代表。沒有辦法自己對抗自己。另外一本書「零邊際成本的社會」，才能夠更去了解。屬於中產階級的共享，並非理想中的共享 只能從內部被摧毀，不能從外部去征服。當邊際成本走到零的時候，資本主義就不會繼續做那件事了，所以就會變成共享經濟了。 寫在最後花了 1200 參加 conference，感覺不做點什麼也不太好。所以就把自己的心得跟筆記一起寫下來了。除了給方心過過乾癮，也順便給公司一個交代（？）。 是真的看到、也學到挺多東西的啦！而且便當好吃又環保，但是他們賣的那雙環保筷一組要 300 塊耶！跟漁夫一樣完全下不了手啊！ 這次也有 unconference 的 session 跟與會者互動的小遊戲（搜集杯子）換獎品。感覺之後聚會的主角會越來越偏向與會者本身。","categories":[],"tags":[{"name":"g0v","slug":"g0v","permalink":"http://kjj6198.github.io/tags/g0v/"}]},{"title":"重新思考 rails helper","slug":"重新思考 rails helper","date":"2016-06-09T16:00:00.000Z","updated":"2018-08-29T14:31:49.000Z","comments":true,"path":"2016/06/10/重新思考 rails helper/","link":"","permalink":"http://kjj6198.github.io/2016/06/10/重新思考 rails helper/","excerpt":"","text":"在逐漸重構 css 跟 html 的過程中，常常會忘記 helper 的存在，最近寫一寫才恍然大悟，對啊！我不是有 helper 嗎？目前對於比較複雜的邏輯判斷已經會習慣性地去使用 helper，但在 view 裡頭，有沒有 helper 可以幫上忙的可能性？ 雖然用 partial 也可以做到類似的事情，但跟 helper 做搭配會更強大啊！ 而且因為 partial 有時候還要去對應路徑，而 helper 則是全域都可以使用。對高度重複的頁面來說或許用 helper 會更加簡單！ 例如我們很常用到的 tags。 當初 sudo tags 改版的時候花了不少時間去更動，因為幾乎每個 tag 裡面都重寫了一次 each，class 命名有時候也不盡相同。 不過使用 partial 又好像太小題大作，畢竟 tag 的架構並沒有如此複雜。 1234def tag_of_tags(tags, options = &#123;&#125;, html_options) raw tags.collect &#123; |tag| content_tag(:span,tag.name, options, html_options)&#125;end 這樣一來，每次我需要用到 tag 的時候就只要 1&lt;%= tag_of_tags(@post.tags) %&gt; 當然也可以做一些調整，例如加入 namespace 來符合我們的使用情境。 123def tag_of_tags(tags, namespace,options = &#123;&#125;, html_options) raw tags.collect &#123; |tag| content_tag(:span,tag.name, :class =&gt; namespace)end 1&lt;%= tag_of_tags(@post.tags, \"sudo\") %&gt; 這樣一來每次 tag 要更新的時候，我只要安心修改 helper，其他地方全部都會生效。寫起來自然輕鬆！ 以上只是一小部分的例子，舉凡 navbar button dropdown 等，幾乎是每個網站開發必備的元素。我們在新增 partial 的同時，說不定也可以搭配 helper 一起思考更多的可能性！","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"Ruby On Rails","slug":"Ruby-On-Rails","permalink":"http://kjj6198.github.io/tags/Ruby-On-Rails/"}]},{"title":"draftJS","slug":"draftJS","date":"2016-05-29T16:00:00.000Z","updated":"2018-08-29T14:30:23.000Z","comments":true,"path":"2016/05/30/draftJS/","link":"","permalink":"http://kjj6198.github.io/2016/05/30/draftJS/","excerpt":"","text":"假日閒來無事、天氣燥熱，在咖啡廳喝咖啡、聽音樂、寫 code 也蠻愜意的。所以就趁著假日的時光研究了一下科科所說的draft-js 所有的骯髒事（selection 兼容、檔案拖曳、編輯器內的樣式）draft-js 幾乎都幫你搞定了。當然因為這個 open source 還非常新（react conf 的時候才推出來），有時候噴錯也不知道從哪邊找起。但這的確是值得令人關注的 editor 解決方案。 目前編輯器會遇到的問題1. input 跟 textarea 是有極限的 他們只能渲染 plain text，如果想要對文字做加粗、斜體、標記等動作，需要花很大的功實作 當你的文字輸入到下一行時，textarea 高度不足不會自動幫你移位。你可能需要計算下一行文字的位置，然後做相關的操作。這也很費工，而且對使用者的體驗非常糟糕。(備註：現在已經有了新的解法 ) 2. contenteditable is terrible因為是將文字內容放在非 input 的 tag 裡面，每種瀏覽器的實作都不太一樣，也很容易就會有意想不到的問題發生。不過 contenteditable 的好處是他活得夠久，瀏覽器也都幾乎實作了，所以反而可以利用這樣的特性來解決當前編輯器遇到的問題。 draft 的概念其實也跟 react 很像，將 editor 跟 content 的狀態存放起來，而非依賴在 DOM 上面。而且他們的狀態不是用純 string 去儲存，而是用 Record(他們實作的資料結構)來代表每個節點。 而 API 文件也寫得挺清楚的，同時也完全實作 immutable 的概念。每次對編輯的內容做操作，就是完全更新狀態。剛開始會覺得很麻煩，我明明只是要一段 text，還要呼叫 getCurrentContent() 回傳的竟然還是一個 Map 在從裡面呼叫 getText()；或者我想要更動狀態時，還要做類似這樣的操作：RichUtils.toggleInlineStyle(curState,&#39;BOLD&#39;)，然後再把新的 state 傳進去。看似麻煩，不過這樣的方式到後期的開發顯然是有好處的。容易測試，易讀性高，容易修改、除錯。 facebook 也提供了蠻實用的範例 看完之後可以更瞭解 draft 到底是怎樣運作的。 這邊是我看了官方文件之後實作的範例：draft-example 。還不算太完整，之後會再慢慢補上。 reference a guide to draftJS","categories":[{"name":"前端","slug":"前端","permalink":"http://kjj6198.github.io/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kjj6198.github.io/tags/react/"},{"name":"immutable","slug":"immutable","permalink":"http://kjj6198.github.io/tags/immutable/"}]},{"title":"【筆記】易讀程式碼之美學","slug":"readble-code-art","date":"2016-03-19T16:00:00.000Z","updated":"2017-02-28T16:16:13.000Z","comments":true,"path":"2016/03/20/readble-code-art/","link":"","permalink":"http://kjj6198.github.io/2016/03/20/readble-code-art/","excerpt":"","text":"比較短的程式碼比較好嗎？雖然減少程式碼會提高易讀性，但縮短讀程式碼的時間才是重點。 表層結構 清楚的命名方法跟變數名稱 方法不需要用 do 選擇詞彙的時候不要用模擬兩可的名稱，ex: pop popItem 在方法名稱加入更多的資訊 1234 function getPage() &#123;&#125; // 對方可能不知道 getPage 的實作方式？爬蟲？ ajax？function fetchPage() &#123;&#125;// 可能比較清楚是用 ajax 的方式並且回傳 json。 找尋更明確的詞彙 send =&gt; deliver dispatch announce route find =&gt; search extract locate recover start =&gt; launch create begin open make =&gt; create setup build generate add new compose 清楚明確比可愛更重要 就算是 tmp 變數，也可以提供多一點資訊。 tmpNumber tmpFile tmpUsrData 如果迴圈的 i,j 有意義，那麼就取個適當的名字。 ex: row col index 選擇具體的方法名稱。 如果變數具有單位，把單位放進去。 startSec delayMs 重要屬性的變數命名 plainData entryptedData 如果變數的作用範圍比較大的時候，用比較長（or 包含資訊較多）的變數是比較好的選擇，相反的如果只有幾行程式碼就結束，其他人可以馬上看出這個變數在做什麼，那麼就算用 alias 也沒關係。 不被誤解的名稱 filter 是把東西 filter 掉，還是留下？ min max 前綴 布林值 computeData =&gt; 比較像執行一個耗費較大的 function 排版一致 符合排版一致 調整程式碼有的相似外觀 相關程式碼為一個段落。 註解的美學 為什麼排版那麼重要？第一個是其他人（或者是你）以後再看程式碼的時候，至少比較容易（也比較願意）看得懂，再來是你可以花更少的時間去理解你的 code 在幹麻，何樂不為？ 代碼品質工具 eslint stylelint ​ 用方法消除混亂？ 如果你發現你在做某一件事情感覺很混亂的時候，就該使用 method 包裝。 用精美不實的包裝來欺騙消費者是人類的本性（誤）。能不能欺騙別人不是重點，重要的是是否能夠欺騙你自己。連你自己都不尊重的 code 別人也不尊重的。 例如說： 123assert(checkTime('12:00')) === \"12:00\";assert(checkName('kalan', 20)) === &#123;name: \"kalan\", age: 20&#125;;assert(checkPaid(20000, true)) === 20000; 仔細觀察一下上面的 code ，不難發現它們都是在做一些同樣的事情，而且還有一些重複出現的字串。而且太長了，我們需要一點時間才能知道這幾行 code 在幹嘛。 這個時候就需要重構啦，我們可以用 method 把它包裝起來。 1234567891011121314151617181920function checkValue(type, value) &#123; if (type === \"time\") &#123; assert(checkTime(value)); &#125; if (type === \"name\") &#123; assert(checkName(value) === value; &#125; if (type === \"paid\") &#123; assert(checkPaid(value)) === value; &#125;&#125;// checkValue(type, value);// [string] [depend]checkValue(\"name\", kalan);checkValue(\"time\", 12:00);checkValue(\"paid\", 20000); 這樣一來 code 比較簡潔，易讀性也提升了！再次強調，並不是比較精簡的程式碼就是好 code ，容易讓人理解的 code 才是好 code。除了這些之外，還有一些好處： 清楚呈現測試的部分。 更容易加入其他測試！ 照順序及段落區分：落落長的程式碼不僅是別人，連自己都不會想看。在變數宣告、陳述式表達的時候，可以依照所做的行為不同拆分。這個寫文章也需要段落是同樣的道理。 123456789function getUserInfo(userName, age) &#123;&#125;getUserInfo(\"kalan\", 20);// getUserInfo(userName, age)// [string] [number]getUserInfo(\"kalan\", 20) 如果有相同的函式呼叫的話，可以讓參數對齊方便閱讀。 123456command = &#123; &#123; \"timeout\" , null, cmd_spec_timeout&#125;, &#123; \"timestamping\" , bull, cmd_adj_boolean&#125;,f&#125; 在寫註解的時候，其實不需要太拘泥，把自己當時想到的想法，以及這個 function 應該做的事情寫下來就好了，有時候過了一段時間你會忘記這個 function 在幹麻。 – #2. 註解篇： 註解是為了讓其他人了解程式設計者的想法而存在的。同時也讓自己了解自己當初的想法。 如何撰寫好的註解，以及哪些東西不需要註解。 不該註解的部分 為讀者設身處地著想 不要讓註解搶走了程式該有的位置 避免寫作抗拒。這通常需要一段時間才能體會到。但當專案架構還沒有變得複雜之前就盡快寫註解絕對是件好事。不然你只能寫下違背良心的 // TODO: refactor 然後就再也沒有下文了。 結語 選用特定寫法的原因 程式碼中的缺陷。 使用者會對哪個部分感到疑惑 維持註解簡潔 用更精確的方式來描述自己的程式碼，並且不要用代名詞來描述參數。 如果參數的行為較複雜，可以直接給範例讓使用者一目了然。 #3. 流程控制： 最常見的就是 if/else 的判斷。書中提供一個準則，就是肯定的條件句先擺前面、先處理簡單的狀況。如果你的 function / method 是有返回值的，就盡快讓他 return 吧！ 善用迪摩根定律：這個定律應該理工科都有印象吧！他可以把一些比較複雜的邏輯判斷簡化。 與複雜的邏輯搏鬥：書中提到一個蠻有趣的方式，我想把它記錄下來。在實作 range 的時候，我們可能有一個方法 overlapWith ，來判斷兩個 range 之間是否有重疊。比起使用直接比對這兩個 range 是否有重疊，不如比對這兩個 range 是否不重疊更簡單。因為只要比對兩種狀況 =&gt; other 的 end 在 range 之前。 other 的 start 在 end 之後。 將龐大的表示式用變數裝起來。123456789101112131415$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');// refactorconst $thumbUp = $('.thumb_up');const highLight = \"highlighted\";$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');$('.thumb_up').removeClass('highlighted');// #4. 變數： 變數存在越久，就越難 debug 減少不必要的變數宣告。 什麼是不必要的變數？ 無法讓意思變得更言簡意賅 本身的邏輯不複雜，不需要再用變數取代 只使用一次 使用一次性寫入的變數 在 functional programming 當中，我們希望 function 是 pure 且 immutable 的，對於變數來說也是，盡量讓你的變數為 const 或 immutable 的。這樣子不僅你對 function 可以一目了然，也比較容易掌握出錯的點在哪裡。 將想法轉為程式碼：先用口語敘述行為，再把程式的行為轉換為程式碼。這樣子可以幫助程式設計師寫出更自然的程式碼。 避免撰寫不必要的程式碼 了解需求 重新思考需求 定期閱讀 API 以維持對標準函式庫的熟悉度","categories":[{"name":"程式筆記","slug":"程式筆記","permalink":"http://kjj6198.github.io/categories/程式筆記/"}],"tags":[]},{"title":"春季限定草莓塔事件 - 動盪的青春生活","slug":"春季限定草莓塔事件","date":"2015-12-02T16:00:00.000Z","updated":"2018-08-28T16:46:06.000Z","comments":true,"path":"2015/12/03/春季限定草莓塔事件/","link":"","permalink":"http://kjj6198.github.io/2015/12/03/春季限定草莓塔事件/","excerpt":"","text":"這本小說是米澤穗信小市民系列的第一作。米澤穗信他很擅長描寫青春校園推理的小說，尤其是在描寫青春心理的動盪，還有發生在日常生活中的推理，米澤穗信都有辦法把他寫的很自然，而且會讓讀者忍不住好奇：「咦？到底發生了什麼事了呢？」 這次的主角是兩位高中生，因為想要平凡地過著高中生活，兩人立下約定，以成為「小市民」為目的。男主角喜歡推理，卻常常因為把真相說出來而受到同學嘲諷；女主角喜歡甜點及復仇。 不得不佩服米澤穗信的寫作功力，清楚地傳達出高中生的日常生活，也將彼此的心理、個性描寫的淋漓盡致。 青春嘛，都經歷過這樣動盪的歲月。思考自身、家人、朋友、同儕的關係，還要應付考試、作業、師長的期待，難免會想要在這段看似苦悶的生活裡找些樂子。小鳩喜歡推理，卻讓同學倒盡胃口；小佐內本身也擁有聰明的頭腦，願意聽小鳩的牢騷。兩個人就這樣維持「互惠」關係。 這一集的劇情比較單純，一方面是小鳩的日常推理；而另一個主軸就是，小佐內的腳踏車被偷而且被弄壞，忍無可忍的她展開了復仇計劃。我們都曾經想要讓自己的青春生活過得更加精彩，但是他們害怕受到同學異樣的眼光而不敢去做喜歡的事情，而選擇成為了平凡的「小市民」。儘管到了故事尾聲，小佐內還是忍不住露出了本性呢！ 這是米澤穗信很擅長的題材，有一位看似平凡頭腦卻聰明的人物（奉太郎、追想五斷章、尋狗事務所、再見妖精），都是以這樣的設定為基底而創造出來的角色。隨著故事的發展，事件的發生、解決，角色的心境上漸漸產生變化。 這大概就是青春的最佳寫照吧！當時的我們對世界只有某個程度上的了解，如果想要改變什麼，就只能從經驗當中學習、改變。有時笨拙、有時青澀、有時痛快，這是青春中的必然，也是青春如此迷人的原因。這些事件，就是要發生在這樣的背景，才格外引人注意啊！(笑)","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"米澤穗信","slug":"米澤穗信","permalink":"http://kjj6198.github.io/tags/米澤穗信/"}]},{"title":"摩登時代","slug":"摩登時代","date":"2015-10-13T16:00:00.000Z","updated":"2018-08-29T12:30:23.000Z","comments":true,"path":"2015/10/14/摩登時代/","link":"","permalink":"http://kjj6198.github.io/2015/10/14/摩登時代/","excerpt":"","text":"《摩登時代》原本是喜劇天王卓別林最著名的一部默劇電影。並且被認為是美國史上最偉大的電影之一。 在討論社會學以及國家、個人、家庭之間的關係時，這部電影也常常會被拿出來討論。 雖然是用戲謔而滑稽的手法詮釋的電影，卻又將殘忍的事實完整的描述出來。 這部電影非常推薦各位去看，從卓別林的眼中，看見這個國家所隱含的殘酷現實。 這就是我們所知的城市，儘管醜陋，卻是我們必須賴以維生的重要場所。就是這樣令人哭笑不得的劇情，才是卓別林突出的功力。 - 這本書是伊坂幸太郎在2010發表的長篇小說，配上花澤健吾的插畫，更富有戲謔感。伊坂幸太郎將這個故事從頭說起，主軸仍然是在討論這個國家、組織的運作，卻更有戲劇性，更引人入盛了，不得不佩服他的寫作功力啊！ 這次連伊坂幸太郎都跳入這個故事中，「我的小說無法改變世界」、「小說啊！只能滲進讀者的體內，然後溶解」似乎隱約道出他的無奈。 但不管如何，唯一能確定的是，他深厚的寫作功力以及架構，的確讓這篇故事相當精彩。 讀完後，似乎能用更寬廣的角度來看待事情，也彷彿在這個社會中找到努力下去的勇氣。 「你有沒有勇氣？」這大概是讀完小說後，最深刻的印象之一。故事從一位系統工程師發現某個交友網站的程式內部隱藏著某個驚人的事實，愈是深入了解，愈發覺事情的不對勁，因為鍵入特定的關鍵字而受害，這位工程師開始深入調查，然後開始展開了一連串的故事。 書中寫到了許多名人故事，不僅和劇情有呼應，也似乎在傳達著這個社會下所顯現出來的殘酷。以下就把我看到的名人小故事寫出來吧！這本書是我在月初看完的，剛好 10/14 是政治理論家漢娜鄂蘭 Hannah Arendt 的 108歲生日誕辰。 當時她最著名的理論就是「邪惡的平庸」，強調平庸才是邪惡的源頭。 事情拉回到二次世界大戰，猶太人被納粹黨大量屠殺的喋血事件。當時的劊子手「艾西曼」被批評為惡魔。但是後來才發現，他並不是懷抱著對猶太人的憎恨而屠殺，而是依照著上級命令行事罷了。 然後呢？他就不需要懷有內疚感或是責任感，一切都只是遵照指示，不需要受到良心的譴責。每個人都只是機械性地完成工作，卻對整個工作流程一無所知。只是遵守著龐大的組織運作而已。 然而這樣的思想並不只存在於當時。在忙碌的現代中，我們似乎已經忘記去思考，去關心這個社會所發生的事。只要懂得操控情報，就不會有人知道真相是什麼。 怎麼辦？我怎麼覺得跟最近的食安事件有異曲同工之妙？「我只是按照上級指示行動。」這句話聽起來多令人心寒。 捨棄思考的我們、努力(而盲目？)工作的我們，真的只是完成工作就好了嗎？在這樣下去豈不是就像被操控的小丑一樣？ 算是一種巧合嗎？還是一種帶有歷史性、諷刺的無奈輪迴？漢娜鄂蘭、伊坂幸太郎所要表達的觀念竟然不約而同地出現在現代。 伊坂幸太郎給我們的答案是「如果因此做什麼都不會覺得不痛不癢的話，這個人就完了」。 之後男主角的威能老婆給了那位兔男應該是很震憾的制裁吧！ 芥川龍之介他的作品也都是關注社會醜惡的現象，並不會直接對社會做出最直接的評論，但是卻會用很簡短而冷竣的文字來描述。「羅生門」應該算是他最有名的作品之一(也不過是在高中國文課本看過而已！)。他的書我還沒有翻過幾本，等期中考完我要來瞧瞧！ 人生就好比一盒火柴，如果很小心翼翼的對待它，是有些可笑的；可是如果不認真對待它，又是很危險的。 這句話想要表達出什麼意思呢？我也看不太懂 規矩分兩種，重要和不重要男主角半夜出門，卻因為不敢闖紅燈而被老婆教訓了一頓。這讓我想到孔子曾說過的一句話：「大德不逾閑，小德出入可也」 大概就是說，有時候為了顧全大局，並不一定要對小細節錙銖必較。雖然看起來是很老生常談的論調，可是有時我們還是會不禁跳進去思考的胡同裡。難道只有一種解決方法？難道必須非得那樣做不可？ 沒有經過思考的言論是最致命的。 「偽善的博愛主義是最可怕的」，比起只敢用溫柔迎人的傢伙，還是直來直往的個性舒服多了。沒有猜忌，沒有同情的憐憫，不需要假惺惺的做作。 人生是不能被簡化的在程式裡頭我們希望程式越簡單越好，但人生不一樣，日常生活是構成人生的一大部份。 人是會習慣的動物剛開始數學不熟悉，因為反覆的練習而純熟的解題技巧；打排球時漸漸能夠掌握球的方向及力道；彈鋼琴時靠著手指記憶便彈完了一首曲子。面對不熟悉的領域，因為害怕和恐懼而不敢踏出第一步。但其實因為這樣而不敢接觸世界的話，未來也一定會更膽怯吧！那麼比起什麼都不做，笨拙地成長雖然緩慢，但至少不是停滯不前的。 比起支配人，我更想要幫助人這是卓别林在大獨裁者當中的經典台詞。 我也很想幫助人，可是我現在的身份，只能處於被幫助的狀態。雖然很感動，但是那份不適感依舊存在。 「我真的有資格受到這樣的幫助嗎？明明就還有人在挨餓受凍。」關於這點，我尚未找到令自己滿意的答案，但是我目前得出的結論是：「為了不辜負那些幫助我的人，所以我必須更努力地往自己目標前進。」 以上是我把書中各種觀點拿出來做分享，當然這並不代表真理，因為這種事情本來就沒有正確的答案不是嗎？ 但對我來說，伊坂幸太郎將那麼多的觀點揉合在一本小說，同時又有個主軸讓故事進行著，真的是讓我在書中，找到了小小勇氣。真的很過癮，屬於那種捨不得看完的類型哦！ 故事結尾，作者將真相揭開，時代下包裝的英雄，因為讓真相蒙蔽而存在。視而不見也是一種勇氣，知道真相也是一種勇氣 人又不是為了遠大的目標而活著，渺小的目標才能成為生存意義。 你有勇氣嗎？","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"OH!FATHER - 男人的約定和浪漫","slug":"OHFATHER","date":"2015-06-04T16:00:00.000Z","updated":"2018-08-28T17:54:18.000Z","comments":true,"path":"2015/06/05/OHFATHER/","link":"","permalink":"http://kjj6198.github.io/2015/06/05/OHFATHER/","excerpt":"","text":"這一本小說的設定相當天馬行空，不過喜歡伊坂小說的讀者們大概也已經習以為常了吧！ 以劇情內容來說，我個人是覺得情節太過鬆散、冗長，導致整個小說的步調都很平淡，直到將近後段的時候才開始出現高潮，結尾的關聯性也沒有完全交代清楚，算是比較不精彩的一本小說。 不過伊坂的風格還是一樣：碎碎念的功夫了得，那四位爸爸鮮明的性格讓小說增添許多娛樂性。故事中有很多對話內容是在討論社會、政治以及各式各樣的人生觀，讓小說仍然具有一定的可看性。被綁架那一段，旗語的應用、暗號，還有主角由紀夫的思考推論，我覺得還蠻精彩的。 還有一點我想小小吐嘈的點是，主角四位爸爸的設定也太過強大了吧！有這樣子的爸爸，我一輩子都不怕被欺負了。那伊坂在這本小說中，想要傳達的是什麼呢？我的回答是：強大而幽默的親情，還有男人之間為了彼此願意付出犧牲的浪漫吧！ 人生中有意義的事，乍看之下都是在做白工這句話的正確與否，可能要決定於自身對「有意義的事」所下的定義為何。 我會想到自己的打工經驗。當時為了不讓家裡在承擔我的支出，所以找了份餐廳服務生賺生活費。服務生的薪資通常並不高，大約每個小時115元左右。領最低工資，卻又要付出極大的體力來換，有時候還真的覺得是在做白工呢！ 那，如果換個念頭想呢？從服務生做起，你可以實際進入一間公司，觀察廚房內部的作業是怎麼進行的，盤點、分析客層、如何和客人交流、和同事以及上司的相處……，都會成為未來很有用的助益。（不過後來證明沒什麼用） 群眾效應當越來越多的人都和你進行同一個行為時，你對行為本身會造成的感受會降低。例如：一群人一起作弊時，罪惡感會降低。但是，如果本身的行為就是錯誤的話，會因為一群人都在做的緣故而變成對的嗎？我想不是。人們在面對資訊不夠充足的情況下，會自然而然根據大多數人的行為做出反應，一方面是減少自己的尷尬，一方面也不會讓自己太過突出。 小說中，當由紀夫被包圍時就產生這樣的念頭，所以面對這種情況，逃才是上策。就算認為自己的體格和實力有辦法超越對方，也會因為恐懼、緊張還有大量的腎上腺素分泌所造成的肌肉僵硬而有落差。 可以花錢解決的，都是小事雖然我認同這句話，可是能夠抬頭挺胸說出這句話的人，應該並不多吧？ 可以花錢解決的都是小事，可是如何賺錢卻是一件大事啊！當連要花錢的小事都拿不出錢來的時候，該怎麼辦才好呢？我常會落入這樣的沉思。不是每個人都有辦法拿出錢來解決事情的。當一個家庭已經面臨到「錢就是一切」的時候該怎麼辦？總要先填飽肚子，才有資格擁有夢想吧！我還沒找到答案。 人們只相信自己想相信的事物我們大腦中有兩種系統，一種是比較「直覺性」的，另外一種是比較「思考性」的。至於為什麼大腦中有這兩個系統呢？因為在大多數類似的情況下，我們大腦會偏向啟動直覺性的系統，讓大腦不必使用到那麼多的資源就可以完成日常生活中的事務。 不過有時候這樣「直覺性」的系統反而會讓我們不去思考。因為一遇到類似的情形，我們會偏向於使用過去的經驗。這恐怕沒辦法怪罪任何人，畢竟人類大腦就是如此運作的。 大家都是煩悶地在過活劇情有一段話是在說：「人生並不會因為努力過活就找得到解決方法。大家都是在沒有正確答案的情況下煩悶地過活。」 覺得非常中肯啊，所以我們能做的只有「承認黑暗面的存在」，然後解決他。 每個星期開一次家庭會議那四個爸爸為了確保由紀夫能夠順利成長，每個禮拜都會開一次家庭會議，討論孩子的成長過程中該如何應變。像是如果遇到霸凌該怎麼辦、如果被綁票是誰要去救人之類的問題。可以看出這群老爸個性鮮明的一面，還有想要保護兒子的心。 我認為這樣做非常好，等孩子長大後甚至也可以讓孩子加入討論中，一起練習如何表達自己的想法，如何一起做決策，在無形之中還可以增進彼此的感情。 但前提是，必須要有這樣的時間才行。現在的台灣，加班、責任制打卡的文化已經深植在國人的腦海中，往往孩子們都上床睡覺了，父母親卻還在公司努力掙錢。這是無可奈何的現實，也是台灣需要被正視與改變的制度之一。 畫圖表來整理歷史會忽略許多東西由紀夫在準備段考時，曾經用畫圖來表示歷史。但是畫圖來呈現歷史只會得到兩種結果，戰爭和制定的條約。我們只會看見條約的簽訂日期，戰爭發生的始末和因果。很少人會去過問當時政治家的心情、願望、野心、動機是什麼，戰爭中的士兵也會默默地在過程中犧牲，比起那些流名萬世的將軍，更多的是戰死沙場的無名小卒。 這告訴我們，默默救人是不會被發現的。要嘛就是掀起戰爭、要嘛就是革命、要嘛就是制定條約。 考試高分不代表頭腦聰明高分並不代表聰明，充其量只能說是比較會唸書而已。如果青春時期就能夠了解這一點，那麼就不會對成績那麼在意了，就算考試成績再好、再爛，人生也不至於毀於一旦。 不過青春時期嘛，誰的內心沒有過動盪呢？社會、父母、學校對自身的要求和期待、同儕之間的相處、自己的想法，都是令人煩惱的麻煩事，常常與自己的想法碰撞，卻又找不到答案。少年的我們，內心裡的壓力並不亞於社會人士啊！ 真正重要的是，願意去理解問題的精神。比起有固定答案的考試，社會上還有更多無解的問題在等著我們。一遇到抽象的問題就想逃跑的話，那麼一輩子都要亡命天涯的。 人類不懂得面對出糗人類不懂得如何面對出糗，所以只好用發怒來回應。因為一定得讓自己看起來很強。表現出害怕、恐懼的神情的話，就會被對方欺負。如果發怒的話，又好像中了對方的意。這個時候必須要靜下心來，用冷靜的思考和判斷來應對。 工作就是要好好做伊坂真的對認真工作這件事情很要求，有好多本小說都會出現類似的句子。不過這句話確實是旨哉斯言。一旦怠忽職守，就會造成別人的困擾。這樣的話是一種不負責任的表現。 現在的年輕人打工，很多時候做了一個禮拜就一聲不響走掉了，後來家長才打電話來說要辭職；不然就是沒有遵守約定的面試時間出現，事前也沒有打電話取消；工作的時候吊兒郎當，不聽主管的話一意孤行，這樣的人以後一定不會受到重用的，因為誠信是做人的根本，沒有禮貌比沒有專業更糟糕。當然公司有沒有按時付薪水又是另外一回事了。 書中可以看見那四位 SUPER 老爸為了兒子而願意犧牲的親情，也可以看見兒子對父親的依賴與信任有多麼重要。伊坂製造了幾個壞人角色，也讓壞人的性格變得很鮮明，並不是絕對的壞，他們也是在生活中打滾，選擇了做壞事這條路當作生活的手段。 我也好想成為一位超級老爸，陪伴孩子走過人生中的各個階段，幽默教導他們處世之道和與人相處的點滴。在他們的心目中，可以把老爸視為世界第一！ 能夠被依賴的感覺，真棒！","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"死神的浮力","slug":"死神的浮力","date":"2015-05-05T16:00:00.000Z","updated":"2018-08-28T17:52:33.000Z","comments":true,"path":"2015/05/06/死神的浮力/","link":"","permalink":"http://kjj6198.github.io/2015/05/06/死神的浮力/","excerpt":"","text":"死亡就是一切的盡頭嗎？ 小說的封面，寫了這樣一個質問。但是在書的最後仍然沒有答案。 關於死亡的沉重，沒有體驗過也無法體驗的我們，只能從自身的經驗（親人的去世）、社會的經驗（跳樓）以及小說中的劇情裡反思、辯證。 答案是什麼沒有人知道，至少我們對死亡可以有更深一層的體會。連伊坂都說，我仍然無法找出答案啊！ 喜歡伊坂的人，印象深刻的大概是《死神的精確度》。沒錯，這本書正是伊坂沉澱八年之後所寫出來的死神系列第二作。死神的精確度是伊坂三十多歲的作品，現在的他已經邁入不惑之年，文筆的掌控和深度又更厲害了，讓我又想重讀一次《死神的精確度》，畢竟八年前，我還是一個不懂世事的小屁孩，能對這樣的作品有什麼感想呢？ 這一次的作品角度一改，死神千葉直接融入了一個親人意外被謀殺，家庭破碎，準備動用私刑，還給女兒正義的山野夫婦。不同於前作，死神千葉的距離似乎離我們更近了。 沉重的劇情設定，仇恨值破表的夫婦，原本會是個陰暗的走向，卻在千葉的加入後變得相當活潑。心態依舊，卻因為千葉各種無厘頭的行為、近乎碎碎念的發言、對音樂的偏執、故意隱藏神力的俏皮，都讓整個小說步調變得很輕鬆，甚至還會因為千葉的滑稽行為（儘管他本意不是如此）噴笑。那一對失去生存意義的夫婦，也在谷底中因為千葉的出現而有了歡笑，「既然都已經掉到谷底了，幹嘛不多一點幽默呢？」。在過程中，伊坂好像也順便調侃了一些社會制度。當然，這也要搭配上伊坂的寫作功力、還有相對應的劇情設定，才能夠讓故事變得如此精彩。 故事的最後依舊溫馨。在山野夫婦的角度中，本城早已沉入湖底死亡，算是不完整地報了一箭之仇。但看在讀者眼中，他們的計劃也算是成功了。因為本城得在湖底動彈不得20年，還得跟鱷魚相處呢！情報局的紕漏政策變成了對壞人的制裁，這一連串的巧合不禁令人莞薾。(原本我還在心裡暗罵：本城竟然還可以活20年，給我交代清楚！) 而山野的妻子成為了幼稚園園長，山野則因為救在路邊摔倒的兒童而送命(大概是千葉的認可吧！) 關於記者的存在目的「比別人更早到達終點，炒熱觀眾的情緒」。這是主角山野成為知名作家後，對記者的感想。沒辦法，群眾的發言永遠是難控制的。掌握這些民眾的好奇心，就是掌握了收視率。咦，這會不會也是伊坂的小心聲呢？ 對於「強迫陷入悲傷的公眾人物發言」，他們經驗豐富。關於媒體，我們想說的東西太多太多。 每次災難發生，在電視、報紙上，都可以看見血淋淋的罹難者照片、斷垣殘壁的災難現場，還有強迫受害者二度傷害的過度質問。但是，我們真的需要這樣嗎？為了餵飽民眾的胃口，不擇手段地搶獨家、搶著播報畫面、搶著得到第一手訊息，可是這並不是媒體該做的事情啊！我認為媒體應該做的是，安撫民眾的心。災難發生無可避免，我們只要平實客觀地報導，不要過度渲染和聳動的標題，對大家而言，這樣就已經足夠了。 再來，關於災難現場我們已經看的夠多。比起讓民眾知道情況有多慘多慘，不如播報乘客名單以及正在搜救的消息，這才是我們願意而且想要的事情。不要再讓受害者承受更大的心靈壓力了，他們此時最想要的是安靜的生活，那是他們唯一的奢求。 「所謂媒體，就是名為群眾的無頭怪物」-卓別林 工作就是要認真去做這點好像是千葉除了聽音樂的偏執外，最大的特點。他痛恨那些不認真工作的傢伙，只是搭訕個兩句就隨便交差。「既然是工作就要認真去做」，於是，即便工作內容單調乏味，千葉還是會仔細觀察七天後再交差。 是啊！人生有一大部份的時間都在工作，甚至可以說，工作是人生不可或缺的一部份。人會因為工作有了目標和成就感。「不辛苦的工作沒資格稱之為工作」，想必伊坂也是很認真地在工作吧！畢竟，人類大部分的行為，都是為了成就感嘛！ 人類最美好的發明是音樂從這句話不僅可以看見千葉對音樂的執著，也可以看見創造這個角色的伊坂受音樂的影響有多深。幾乎每本小說都會有音樂的出現，這大概也是伊坂對於音樂的偏執吧！ 機率和統計往往不具任何意義，但人們只能依賴機率和統計來學習事物的確，機率不過是一種比例，而統計簡略來說就是將資料作一種有系統的彙整後，來做出決策。 任何對掌權者不利的事，都不會留下任何官方紀錄「Winner writes history.」統治者創造歷史。 我們學習的歷史就一定是正確的嗎？還是經過包裝後呈現在我們面前的完美故事？ 待在和平、恬適、宛如天國的環境下，是不會進步的「人類是種矛盾的生物」 安穩過後就會想要改變，改變之後就會想要安穩。這就是為什麼戰爭不斷的原因。─千葉如此說著。但是矛盾一定是貶意詞嗎？正因為有這些願意改變的人，我們的生活才會越來越進步。 相似的概念也在「夜之國的庫帕」裡出現過。夜之國的小市民過著安逸的生活，一切都由領導者冠人打點好了。這樣的心態反而讓他們被蒙騙著，原來夜之國只是鐵國的一小部分。只有在生活不平順的時候，人民才會思考。 走出舒適圈，這五個字如此簡單。但是實踐的難度卻很高。 二十五分之一的無良根據小說裡的設定，每25個人裡面，就有一個缺乏良知的精神病態者。這些人並不受到道德、法律的限制，他們以控制、站在絕對的優勢為樂。就如同當時納粹黨虐待猶太人一樣，他們不但不會有罪惡感，甚至還樂在其中，那麼當最低限度的道德制裁沒有用時，我們該如何制裁兇手？ 但是諷刺的是，無良者大部份都是功成名就。他們不會被外在的感情因素影響，只會著眼於自己的目標。 英文的良心 Conscience 這個詞源於拉丁文 conscientia ，這是一個複合的介詞，意思是「知道在一起」 ， 「共同的知識與他人」 ， 「我們的知識共享是另一套。 」，所以也可以解釋成，這些無良者沒有共同的知識、價值觀，他們只相信他們的理念。 米爾格倫曾經做了實驗，參與者為老師，而學生是實驗助手擔任。當然參與者並不知道。老師要教導學生單字，如果學生答錯，則必須加強椅子上的電壓。實際上椅子並沒有電壓，學生會播放已經錄製好的尖叫聲。而老師則會不斷被實驗人員指示加強電壓。 結果發現，有 60% 的人雖然不願意，但仍會在實驗人員的要求下加強電壓。 儘管不願意，仍然有 60% 的人會服從權威。這大概也是為什麼無良者可以功成名就的原因。只要讓人們服從命令，那麼掌權者便可以假他人之手做到很多事情。 帕斯卡《思想錄》帕斯卡在這次故事中很常出現呢，他的名言中有很多是探討死亡的句子，大概是因為這樣才會被伊坂大量引用吧！ 「我們總是在想辦法擋住自身的視線，才能安心朝著懸崖前進」。這裡所說的懸崖，就是所謂的死亡。書中提到了很多伊坂對於死亡的看法，但到最後我們依然找不到答案。這些答案就留給各位自行尋找了！ 不過有件事情可以確定。「人類能做的，就是努力摘取每一天，努力在生活中獲得快樂」，因為人總有一天會死。 勉強執行一套剛出爐的制度，往往會出紕漏還記得情報部為了延長人類的壽命，提出「回饋大放送」的方案，「放行」後延長了 20 年的壽命，結果反而在湖中動彈不得。 現實中大概也是如此吧！「隨便改變規則，往往會出問題」 因為怕死所以自殺實在是匪夷所思的行為要從高樓跳下、喝毒藥、燒炭，都需要極大的勇氣吧！可是矛盾的地方是，為什麼人類有勇氣自殺，卻沒有勇氣渡過人生中的難關呢？這個世上有許多名人最後也是走上自殺一途。我目前還得不到答案。 或許現在的我還沒有碰到困難度大於自殺的人生難關，我不知道以後會不會有那種：「這個難關的解決方法唯有自殺」的情況出現。 浮力的大小與物體的重量無關伊坂用浮力來比喻死亡。這樣的比喻還真是貼切。 浮力的大小與物體的重量無關，體積才是。就算死亡了，死者依然或多或少會融入生者的回憶裡頭，所以總量並不會減少。 這種理科組的解釋還真是浪漫呢！我很喜歡。就像山野夫婦在執行復仇計劃的過程中，因為千葉的出現，開始回想起女兒存在時，那些平凡卻又珍貴的回憶。 人類判斷價值的標準，永遠都是朝三暮四的人的價值觀很容易在一夕之間改變。因為我們太常用片段的訊息來理解事物，然後又在自以為了解之後做出另外一種價值觀。 什麼是對的，什麼是錯的，自己思考吧！ 跌倒的經驗，千金也買不到「那要多少錢？」千葉很認真的問。 我不知道多少錢，但是一定超過千金。 「千金難買少年窮」因為經歷過挫折、因為有體驗過窮的滋味，才會思考自身的可能性，「反正最差也不過就是這樣了」。所以才會願意努力改變現狀，並且常常反思。因為當過窮人，所以很清楚金錢的重要性；因為跌倒過才知道傷口有多痛，也才知道下次怎麼樣才不容易再跌倒。關於這方面我可是經驗豐富了！因為小時候野孩子的個性，常常跑著跑著就摔倒了，腳上的傷口和瘀青可是數不清的。 對付不寬容的人「我是個寬容的人，但面對不寬容的人時，我會改變我寬容的態度。」 渡邊一夫曾經對這個問題提出回答：「寬容的人不應該為了不寬容的人改變寬容的態度」 至於要不要信仰這句話，是個人的選擇。山野夫婦的回答是：「我們怎麼做，由我們自己決定」。 面對毫無理由的惡意，我們該怎麼做？書中沒有提出正確解答，只提供了一種方式。在伊坂的書中，壞人終究會被懲罰。可是現實中卻有太多太多「明明如此惡毒，為何還能夠消遙的活在世上？」這樣的案例。(又貪污又舞弊之類的…) 罪大惡極的兇手在群眾的眼中，最好的方法就是「死亡」，將他排除在這個社會外，讓社會維持安穩的和平。可是對於受害者呢？他們的傷痛不可能平息，甚至裡頭夾帶著強烈的個人情緒，想要動用私刑給予制裁。就像山野夫婦每次看見本城都會有難以克制的怒火那樣。 Epilogue小說的情節中，壞人都將得已制裁。但是現實中呢？我們真的可以因為復仇的心而動用私刑嗎？法律就是避免「以牙還牙，以眼還眼」而產生的。可是，當法律無法制裁這些兇手時又該如何呢？一直以來這都是個沉重而無解的問題。我們只能從討論中得到不同的觀點，該怎麼做還是得依照法律。法律真的是保護弱者嗎？ 不過小說嘛！重點是讀者的情緒有沒有獲得滿足。我想是有的。看到本城陷在湖裡的那段，真的是大快人心啊！而山野的死也在伊坂的筆下有了完美的收尾。 你有努力摘取每一天嗎？","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"夜之國的庫帕","slug":"夜之國的庫帕","date":"2015-02-22T16:00:00.000Z","updated":"2018-08-28T17:52:05.000Z","comments":true,"path":"2015/02/23/夜之國的庫帕/","link":"","permalink":"http://kjj6198.github.io/2015/02/23/夜之國的庫帕/","excerpt":"","text":"來個慵懶而即興的小革命吧！ 這本小說很適合在午後咖啡店，一邊啜飲著咖啡，一邊聽著輕音樂，一邊享受著小說中可愛而有趣的視角和劇情。 這本小說的筆調是很輕鬆的，但是卻在這種輕鬆的氛圍中，把人類社會中的現實和殘酷丟出來，拋出一個完美的質問，你會在故事的結尾中思考，對呀！我們不也是這樣？還好故事裡那位獨眼兵長給了讀者答案：「懷疑。」 這本書的視角是從「貓」的眼睛看世界，相關的劇情設定相信許多人也都知道（夏目漱石《我是貓》）。故事的內容是在描寫夜之國的人民被鐵國擊敗後，剛開始先假裝和平停戰，卻在一夕之間發生國王被殺(冠人)的事件，搞得整個夜之國人心惶惶、不知所措。每個登場的角色都有一個小小故事，而這些小小故事結合起來，卻又和主軸互相連結，不會顯得太過凸出，伊坂揉合了不同支線的故事發展，最後將事實完整交代出來。這必須有非常深厚的寫作功力還有架構才有辦法做到。 安穩＝和平？從書中我們可以發現，夜之國的人民們深深相信著自己是處於一種和鐵國對立、領土相當的狀態下。他們並沒有產生懷疑，也沒有人想要求證。反正，只要日子過得安穩，就沒有這個必要管那麼多的事情吧！就跟「進擊的巨人」一樣，人民們依賴城牆內的安穩，卻沒有人願意思考、懷疑現狀的可能性。甚至他們放棄了探究真相，因為只要冠人說出包裝後的故事，他們就會無條件地全盤相信。為什麼？因為不需要動腦筋、不需要奔波勞碌就有安穩的生活，那麼幹嘛需要大費周章地去確認事實呢？ 所謂的庫帕傳說我喜歡這個傳說。因為作者用很可愛的神話論述，將社會上存在著的殘酷事實給表達出來了。讀來不會有沉重的感覺，卻會讓你在不知不覺中開始反思。 比起公佈真相，維持威嚴更加重要 那麼，要如何維持自己的威嚴呢？冠人的方法是，在外部安排一個又恐怖又強大的敵人（就算是假的也沒關係），然後再對人民說：「別怕，我會保護你們。」並且拿出實際作為（每年派出庫帕士兵）。這樣包裝下來，人民就自然而然地會將領導人視為英雄。冠人確保地位的方式是：欺騙、隱瞞、扭曲這個世界的價值觀。 但是，我不得不承認，要控制民眾的心，你就不能把所有的真相都全盤拖出。你必須讓整個局面看起來都是沒有問題的。「不要說多餘的話」，這對領導人來說是必要的。所以，冠人的作法到底是不是正確的？或許就要看各位的價值觀而定了。 「什麼是對的，什麼事錯的，自己去判斷吧！」獨眼兵長丟出了結論。「對任何意見都要有同等的懷疑，不然一定會吃虧。」 「無知」是一種恐懼，人們會因為不知道而害怕。所以如果領導者將事情處理好了，人民就無所憂慮，無所憂慮後，人民就會感到幸福，感到幸福之後，人民就會依賴領導者了。冠人成功創造了這樣的優勢，所以儘管獨眼兵長將事實說出，他們仍然是半信半疑。 「會不會我們所深信不疑的，都有改變的可能呢？」 所謂的貓吃老鼠貓吃老鼠就是天經地義嗎？誰規定的？來自上古的命令告訴多姆，「貓就是要吃老鼠」。但，為什麼呢？有人思考過這個問題嗎？ 故事中有蠻多篇幅是在描寫貓與老鼠間的對立關係及談判呢！而且看起來格外可愛。 比自己弱小的東西，誰也不會放在心上。「只要心血來潮，我們就捉弄老鼠」，但弱者就一定要被欺負嗎？貓似乎都沒有想過，直到老鼠長老冒出來要求談判後，多姆才開始思考這個問題。「我們獵捕老鼠，所以老鼠是低等的」，這是正確的看法嗎？ 同樣的觀點挪用到人類身上，弱者就應該順應天命的安排嗎？我不這麼覺得。 所謂的領導者如果沒有能幹的中心領袖就不會有向心力。如果沒有不曾一起做決定，然後互相遵守，那麼團結心就不會強大。 這點從當總召、當班代之後可以有深刻的體悟。只有當大家一起完成、討論一件事情的時候，向心力才會出現。這個時候領導人就非常的重要，領導人不同，方針就會不同。最重要的是創造出契機，讓人們有一起合作、發聲的機會。 這樣說起來的話，創造共同敵人這招好像是非常好用的耶！我好像也曾經這樣用過。當大家有共同的敵人時，那個合作的決心還真不是蓋的啊！ 思考現狀的可能性（讓高牆倒下吧！）其實看完之後，對照現在的台灣，既然有種深深的既視感。 會不會我們就是那些夜之國的小國小民，被蒙蔽在城牆之中？自以為的小確幸、自以為的安穩，其實都包裝在一個完美故事裡頭？ 伊坂已經給了我們明確的指示了，「思考、懷疑，然後行動。」，對周遭的事物做平等而適當的懷疑，然後呢？ 然後繼續踏上這場屬於自己的人生之旅。 小說的結尾依舊溫馨，所有的真相在最後娓娓道來。原來夜之國和鐵國都是小人國，而那位「我」的體型佔有決定性的優勢。庫帕的傳說似乎也是有人誤闖這座小島而產生的。 奇妙吧！由伊坂架空出來的世界，卻又在最後土崩瓦解，但是看來依舊過癮，一不注意，眼角甚至還會噙滿淚水哦！ 那麼最後，我想用小說裡的節錄作為結尾。如果不改變彼此的關係，就永遠是兩條平行線。光是這樣，就可以有很大的改變了。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"家鴨與野鴨的投幣式置物櫃","slug":"家鴨與野鴨的投幣式置物櫃","date":"2015-02-04T16:00:00.000Z","updated":"2018-08-28T17:53:45.000Z","comments":true,"path":"2015/02/05/家鴨與野鴨的投幣式置物櫃/","link":"","permalink":"http://kjj6198.github.io/2015/02/05/家鴨與野鴨的投幣式置物櫃/","excerpt":"","text":"今天又要來跟大家介紹伊坂幸太郎的小說囉！ 取名非常的無厘頭，卻會讓你想要了解裡頭到底有怎麼樣好玩的故事。這招是伊坂幸太郎常用的法之一。 這次，伊坂用了倒敘手法，並且以多人視角將故事層層推進到現在。為了送一位外國朋友書而去書店搶《廣辭苑》。這種看似無理的劇情和理由，在故事最好得到的完美解釋。 伊坂一樣在故事設定中留下了伏筆，在可愛的角色對話，有點黑暗的劇情中慢慢得出答案。那位新來的大學生「我」不知不覺中加入了這場戰役，而一切又是因為Bob Dylan 而起……。 還記得當初上文藝發展與流行音樂文化時，老師介紹他介紹的好起勁。最有名的當然就是這首《Blowing in the wind 隨風而逝》、《The times they are changing 變革的時代》。這個傢伙和約翰藍儂一樣，常常在小說中出現。 這本小說中有三個重點，一是表達日本人普遍對外國人（不丹人）的刻板印象。「因為怕麻煩，因為需要解釋所以乾脆直接拒人於千里之外。」、「他們什麼都不懂，看起來真蠢。」小說中一點一滴地透露出這種概念，讀來令人深思：「如果是我呢？我是否會對外國人有著既定印象，先入為主的概念？」 第二個重點是寵物，故事的主軸是寵物被大學生凌虐至死，而主角因為氣憤而想要揪出兇手，開始展開一連串的調查。 「為什麼豬是食物，狗是寵物？」這本書是我大一時曾經讀過的一本書。裡頭是在探討一個很困難的道德難題。為什麼同樣是動物，豬是食物而狗卻是寵物？狗被做成狗肉會被法律制裁，但豬做成豬肉卻不會。 同樣的道理，為什麼他們是動物，卻又非得承受我們的無理的虐待、飼養？ 第三部份則是無可避免的惡意。就算你沒有做壞事，仍然會有毫無理由的惡意。「做壞事並不需要理由」。但，這或許也是每個時代下必定會出現的悲劇吧！諷刺的是，這種悲劇還具有輪迴。 那麼以下摘錄某些片段的句子，以及自己看到的概念。沒有什麼正確答案 我認為輕率的考慮，對任何人來講都是一種負擔沒有錯。 最近剛好迎新宿營辦完，已經深深發現這個道理。你必須將責任和權利賦予在值得你信任的人身上，不然到最後的結果就是自己去收爛攤子！還有很重要的一點就是，不要再超出自己能力的範圍內答應別人事情，因為輕率的答應卻無法拿出相對應的成果，只會給人添麻煩而已。不要因為想到當好人而接受，最後又找藉口把責任推掉，這樣真的很糟糕。 趁心意還沒有改變之前趕快行動看起來很簡單的口號，又有誰可以真正做到呢？ 我覺得最重要的是環境！讓環境變得可以毫無顧慮地做自己想要的事情。例如：如果在家就會想要睡覺、看FB、遊手好閒，那麼就直接到圖書館或是自修中心；如果想要練琴，就把譜拿出來，把飲料放在旁邊，設定一個鬧鐘規定自己要練習多少的時間才可以、要練到哪個小節可以順利彈出；這邊分享一個我覺得還蠻有用的方法，就是紀錄你的目標。如果你想要讀 100 本書，那麼你就紀錄自己看了哪些書，書名、作者、閱讀日期是什麼時候，久而久之，當你看見紀錄表越來越多筆資料，你真的會有種成就感哦！就跟看著自己的部落格逐漸壯大一樣。 用敬語說話，只會被人看扁這裡想要表達的並不是不遵守禮節，而是如何做到「不卑不亢」。 剛學日文的人，為了統一加上禮貌，所以基本上都會從敬語開始。由於敬語的變化很簡單，大家習慣之後就不想學習常語。這樣和日本人說話不僅有著隔閡，還會讓別人覺得你很好欺負。 想要學習一種語言，只有一個秘訣：每天拼命練習，重複地聽和說，直到習慣為止。現在想來真的是如此耶！可惜台灣的教育太少教孩子開口，一律變成制式的選擇題和單字背誦，根本無法培養日常對話的能力。學習單字是拼湊不出來句子。 因為我不想要你把我當成外國人我之前上美國流行文化的時候，老師也這樣跟我們說著。他說，他很不喜歡美國人被叫作「foreigner」，他認為這樣是一種排擠。雖然並不是所有人都這樣認為，不過一定也有很多從國外來的人，不想要被以「外來人」的身份被看待吧！ 故事的結束，主角和不丹人拿著收音機，播放著 Bob Dylan 的《blowing in the wind》，然後把他塞進投幣式置物櫃。蛤？","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"歌詞-アイロニ","slug":"アイロニ","date":"2015-01-22T16:00:00.000Z","updated":"2018-08-28T17:08:36.000Z","comments":true,"path":"2015/01/23/アイロニ/","link":"","permalink":"http://kjj6198.github.io/2015/01/23/アイロニ/","excerpt":"","text":"這首歌的旋律真的超級棒的！每次遇到人生低潮或是不如意的事都會聽這首歌，目前最喜歡的版本是 majiko 翻唱的版本。 歌曲介紹日文中，如果要表達很感動的歌曲，常常會用「淚腺崩壞」這個詞來描述。而這首歌正屬於這樣的類型。 其實人生中不乏這樣的場景。忘了從什麼時候開始，總是開心時也笑、不開心時也笑，隨著人群起舞，恰如其分地扮演著每個角色。在忙碌而緊湊的生活中，我們似乎都失去了與生俱來的能力。單純的笑、無憂無慮的笑、純真的笑。但是，收拾完心情中的憂鬱後，卻又要繼續踏上人生，繼續在這樣的世界裡打轉。 這首歌描述的世界觀大概是如此，算是把很多人的心聲都給說出來了吧！（尤其是日本上班族那麼龐大的壓力） 累了嗎？疲倦了嗎？這首歌讓你好好發洩一次。 歌詞作詞：すこっぷ 作曲：すこっぷ 編曲：すこっぷ 少し歩き疲れたんだ 少し歩き疲れたんだ 稍微走的有點累了呢 稍微走的有點累了呢 月並つきなみみな表現だけど 人生とかいう長い道を 雖然是很平凡的表現 來表達人生漫長的道路 少し休みたいんだ 少し休みたいんだけど 有點想休息了呢 雖然是有點想休息了 時間じかんは刻一刻残酷ざんこくと 私を 引っぱっていくんだ 但時間還是一分一秒 殘酷地拉著我 うまくいきそうなんだけど うまくいかないことばかりで 雖然看起來好像很順利 但全是一些不順利的事 迂闊うかつにも泣いてしまいそうになる 情なさけない本当にな 快要難過地哭出來了 還真是丟臉 惨みじめな気持ちなんか 嫌というほど味わってきたし 這樣悲慘的心情 已經快要受夠了 とっくに悔しさなんてものは 捨ててきたはずなのに 明明就打算將這樣後悔的心情 全部丟掉的 絶望ぜつぼう抱くほど 悪いわけじゃないけど 雖然也不是到如此絕望的地步 欲しいものは いつも少し手には届かない 但想要的東西 卻一直都得不到 そんな半端だとねなんか 期待してしまうから 像這樣半途而廢的事 卻又讓我開始期待 それならもういっそのこと ドン底まで突き落と（つきおと）してよ 既然如此不乾脆的話 乾脆直接掉到谷底好了 答えなんて言われたって 人によってすり替わってって 說出答案什麼的 也會因為人而有所不同吧 だから絶対なんて絶対 信じらんないよねぇ 所以絕對絕對 不能相信的對吧 苦しみって誰にもあるって そんなのわかってるから何だって 苦澀什麼的誰都會有 這種道理我是明白的 なら笑って済ませばいいの？ もうわかんないよバカ！ 那就笑著過去就好了吧 夠了 我不知道了啦 笨蛋 散々言われてきたくせに なんだまんざらでもないんだ 明明是被狠狠地訓了一頓 但卻不一定是這樣 簡単に考えたら楽らくなことも 難関なんかんに考えてたんだ 明明很簡單的事情 也想得很複雜 段々と色々めんどくなってもう 淡々と終わらせちゃおうか 一大堆事情都如此麻煩 夠了 讓它平凡的結束好嗎 「病やんだ？」とかもう 嫌になったから やんわりと終わればもういいじゃんか 「你病了嗎？」之類的話語已經厭煩了 能溫和的結束不就好了嗎？ 夢だとか希望とか 生きてる意味とか 夢想什麼的希望什麼的 生存的意義什麼的 別にそんなものはさして 必要ないから 也不是一定要有的吧 具体的でわかりやすい 機会をください 請給我具體而易懂 的機會 泣き場所探すうちに もう泣き疲れちゃったよ 在找到能夠放聲大哭的場所之前 就已經哭累了啊 きれいごとって嫌いだって 期待しちゃっても形になんなくて 討厭綺麗的事 期待著卻捉不到的形狀 「星が僕ら見守って」って 夜しかいないじゃん ねぇ 「星星會守護我們」 這種話也只會出現在晚上對吧！ 君のその優しいとこ 不覚ふかくにも求め(もとめ）ちゃうから 你的溫柔 我不知不覺就想要依賴 この心やらかいとこ もう触んないで ヤダ！ 這樣的心如此柔弱 不要再觸碰了 討厭！ もうほっといて もう置いてって 夠了就這樣讓我一個人在這裡吧！ 汚よごれきったこの道は もう変わんないよ嗚呼 骯髒的這條路 已經無法改變了 疲れちゃって弱気よわき になって 逃げ出したって無駄なんだって 疲倦了也變懦弱了 想要逃走也只是徒勞無功 だから内面耳塞いで もう最低だって泣いて 所以將心情藏起來 邊哭邊說著「真是夠了！」 人生って何なのって わかんなくても生きてるだけで 人生到底是什麼呢 這種東西不明白也可以生存吧 幸せって思えばいいの？ もうわかんないよバカ！ 那就想著幸福快樂的事就好了吧？ 我不知道了啦 笨蛋！","categories":[{"name":"雜談","slug":"雜談","permalink":"http://kjj6198.github.io/categories/雜談/"}],"tags":[]},{"title":"某王者 - 那個夏天，名符其實的棒球夢","slug":"某王者","date":"2014-10-19T16:00:00.000Z","updated":"2018-08-28T17:13:52.000Z","comments":true,"path":"2014/10/20/某王者/","link":"","permalink":"http://kjj6198.github.io/2014/10/20/某王者/","excerpt":"","text":"這並不是熱血指數報表的青春棒球夢類型的小說，而是充滿悲劇性的天才傳奇。這點在封面已經有告知過囉！請不要抱著熱血沸騰的心翻看故事，不然你會後悔的。 屬於伊坂的馬克白悲劇寓言 這個形容還真是貼切。 沒錯，這本書是伊坂寫出來的關於天才的一生。山田夫婦因為是仙醍國王隊的死忠球迷，決定要把王求訓練成王牌打者。而這個孩子的出生並沒有辜負山田夫婦的期盼，甚至造成的日本職棒界極大的轟動。伊坂用一種觀察者的角度來說這個故事，寫盡了他所謂的「天才的一生」。 當你的厲害成為了慣例，大家就不知道要怎麼辦了這是王求的好朋友曾經對他說過的話。對於天才，我們一向又羨慕又嫉妒，羨慕的是他令人難以超越的才能、嫉妒的是為何這樣的人可以逍遙地活在世界上，擾亂我們生存的秩序？這是人性中共同的醜陋，世間存在著的負面倫理。 所以故事尾聲，這位令人羨慕忌妒恨的王者，招致了殺身之禍。 一邊讀著這本小說，一邊想著自己曾經擁有的小小棒球夢。在國中時期，我也曾經是個喜歡棒球的小男孩，只要有時間就會找朋友一起去大魯閣打球，或是在草皮上練球、投球，每個假日還會組隊打友誼賽。名符其實地追逐著代表夏天的小白球，現在想來格外懷念啊！ 最令人懷念的大概就是那個時候超級熱血的「棒球大聯盟」吧！到現在我還是會看看那些很熱血的橋段。 那時候有一個很紅的線上遊戲「全民打棒球」，現在已經沒有在玩了。不過以前真的很喜歡看棒球轉播，和同學一起買票，騎著腳踏車衝到澄清湖棒球場看我們最熱愛的「兄弟象」。現場的氣氛跟看轉播可是完全不同的！跟著觀眾一起吶喊、歡呼、尖叫，整個氣氛和心情也會變得興奮起來。 那時候覺得「廖于誠」投球很帥，所以模仿他低肩側投的姿勢；覺得「恰恰」打擊超厲害，是我最喜歡的球員之一；覺得「陳致遠」的鬍子令人印象深刻，買家瑞王金勇郭一峰小林亮寬……，還有好多好多。 然後呢？ 然後假球風波就爆發了。一想到就覺得無奈。除了恰恰一身乾淨之外，幾乎所有喜歡的球員都跟這次的假球風波有關。那個時候，傻傻的我只是單純覺得，職棒不是薪水夠多了嗎？幹嘛還要打假球？ 長大以後才發現，黑道的威脅、台灣對運動產業的狀況、內心的壓力，都是難以去衡量的。 咦？這不就跟某王者一樣嗎？ 如果加油有用的話，人生就輕鬆多了雖然加油不一定有用，可是如果因此什麼都不做的話，不是更奇怪嗎？於是，在不知道該說什麼的情況下，說聲加油應該不算奢侈吧！儘管人生不會因此變得輕鬆，但是至少或多或少可以從加油之中獲得一點點的勇氣。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"伊坂幸太郎","slug":"伊坂幸太郎","permalink":"http://kjj6198.github.io/tags/伊坂幸太郎/"}]},{"title":"【鋼琴社成發】陽炎days カゲロウデイズ","slug":"鋼琴社成發","date":"2014-10-14T16:00:00.000Z","updated":"2018-08-28T16:51:24.000Z","comments":true,"path":"2014/10/15/鋼琴社成發/","link":"","permalink":"http://kjj6198.github.io/2014/10/15/鋼琴社成發/","excerpt":"","text":"雖然有蠻多音MISS掉，不過整體來說我覺得還不錯啦（自己講XD）","categories":[{"name":"雜談","slug":"雜談","permalink":"http://kjj6198.github.io/categories/雜談/"}],"tags":[{"name":"鋼琴社","slug":"鋼琴社","permalink":"http://kjj6198.github.io/tags/鋼琴社/"},{"name":"大學生活","slug":"大學生活","permalink":"http://kjj6198.github.io/tags/大學生活/"}]},{"title":"夏季聖代水果事件 - 青春","slug":"夏季聖代水果事件","date":"2014-09-19T16:00:00.000Z","updated":"2018-08-28T16:47:10.000Z","comments":true,"path":"2014/09/20/夏季聖代水果事件/","link":"","permalink":"http://kjj6198.github.io/2014/09/20/夏季聖代水果事件/","excerpt":"","text":"「身為一位小市民，有資格過一個充滿回憶的暑假嗎？」 兩位過著平凡高中生活的小市民，這次時間軸拉到了暑假。小佐內要求小鳩陪她一起吃遍《小佐內甜點指南書‧夏季版》，而百思不得其解的小鳩感到好奇，決定加入這場鬥智遊戲。暑假不知不覺接近尾聲，小鳩漸漸發現，原來這份地圖，卻暗藏著不為人知的陰謀……。 我也想在青春時期留下好多回憶雖然米澤穗信為了劇情需要，將故事描寫的比較誇張一些。但是身為高中生，一定也會對這樣的生活產生憧憬吧！因為有了目標，讓這個暑假變得更有意義。 我也好想吃甜食哦！ 水果聖代水蜜桃派特製奶油水果冰淇淋千層派冷凍西瓜優格宇治金時芒果布丁千層起司蛋糕可麗餅水果塔安伯羅瓦士蛋糕義大利鮮乳酪巧克力戚風蛋糕提拉米蘇夏洛特蛋糕。 小說裡面出現的甜點，在米澤穗信的描述下，還有幻想小佐內那種滿足的神情，就覺得口水直流了。有空我也要計劃一個甜點指南。(不要有空了，想要就趕快去做。) 紀伯倫曾經說過：「你不能同時擁有青春又擁有有關於青春的知識。因為青春忙著生活，顧不得去了解，而知識為著要生活，而忙於自我追求。」 看起來很哲學對不對？其實要表達的意思就是：當你身處在那個青春時期時，並不會有特別的感覺，也不會領悟出特別的意義。要等到你已經經歷過那個時期，才會慢慢從自身的經驗中，領悟出什麼道理出來。 全班一起準備運動會，放學時大家留在大草皮上合照，忙進忙出的，理想再大，不就是期待這一刻？每次段考完，一群臭男生總要到網咖廝殺的沒完沒了，現在想起來格外懷念。 一起用功的夜讀生活、補習班上的黃色笑話、那家好吃到不行的炒飯章魚燒咖哩飯、永遠充滿回憶氣味的三川冰城……。 為了掩飾自己的渴望，卻也忽略了自己的內心看到故事的後段和尾聲，除了佩服作者的推理功力之外，自己也會陷入沉思。「我們是否害怕與眾不同，而放棄了改變自己的機會」就如同書中一直想壓抑自己，過著「小市民生活」的兩人。 我覺得尾聲他們兩個人的談話描寫的非常精彩！有興趣的人可以自己去看看，會有一種高中生吵架的感覺。 這個世界充滿著謊言當時懵懂無知的我們，都曾經擅自對這個世界下定義，以自我中心為準，生出一套屬於自己的信條或是座右銘。 認定誰就是誰的一切，對戀愛有無盡的想像，為賦新詞強說愁的幼稚。雖然現在看起來是尷尬不已，不過無法否定的是，那曾經是我們以為的世界。 這大概就是青春小說如此歷久不衰的原因吧！正處於青春的孩子從小說裡去探尋自身存在的意義，跟著小說一起享受青春的動盪；而大人們則是用一種緬懷過去的心情，去品嚐青春的酸甜苦辣，讓自己再一次進入美好的幻想裡。","categories":[{"name":"讀書心得","slug":"讀書心得","permalink":"http://kjj6198.github.io/categories/讀書心得/"}],"tags":[{"name":"米澤穗信","slug":"米澤穗信","permalink":"http://kjj6198.github.io/tags/米澤穗信/"}]}]}